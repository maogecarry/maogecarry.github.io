<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","images":"/images","scheme":"Pisces","version":"8.2.1","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>
<meta name="description" content="数据结构简介 数据结构是相互之间存在一种或多种特定关系的数据元素的集合  栈（stack) 栈是一种操作受限的线性表只允许从一端插入和删除数据。 栈有两种存储方式，即线性存储和链接存储（链表）。栈的一个最重要的特征就是栈的插入和删除只能在栈顶进行，所以每次删除的元素都是最后进栈的元素，故栈也被称为后进先出（LIFO）表。每个栈都有一个栈顶指针，它初始值为-1，且总是指向最后一个入栈的元素，栈有两种">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构和算法">
<meta property="og:url" content="http://example.com/2021/03/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%80%BB%E7%BB%93%E7%89%88/index.html">
<meta property="og:site_name" content="Colorfuls-Blogs">
<meta property="og:description" content="数据结构简介 数据结构是相互之间存在一种或多种特定关系的数据元素的集合  栈（stack) 栈是一种操作受限的线性表只允许从一端插入和删除数据。 栈有两种存储方式，即线性存储和链接存储（链表）。栈的一个最重要的特征就是栈的插入和删除只能在栈顶进行，所以每次删除的元素都是最后进栈的元素，故栈也被称为后进先出（LIFO）表。每个栈都有一个栈顶指针，它初始值为-1，且总是指向最后一个入栈的元素，栈有两种">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/27/XLHYj2UJDnf8g4I.png">
<meta property="og:image" content="https://img-blog.csdn.net/20180502195346635">
<meta property="og:image" content="https://i.loli.net/2021/02/27/hf1Lld9nB2AFZY5.png">
<meta property="og:image" content="https://images2015.cnblogs.com/blog/1146465/201704/1146465-20170429154748350-758050755.png">
<meta property="og:image" content="https://i.loli.net/2021/02/27/PZybI8rs74BgjUD.png">
<meta property="og:image" content="https://i.loli.net/2021/02/27/5lgpkNYFSyzKrXh.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200404122342926.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5ODEwMg==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200404123845995.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5ODEwMg==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://i.loli.net/2021/02/27/xiCFyMAd89n4qzN.png">
<meta property="og:image" content="https://i.loli.net/2021/02/27/kA7awjPhRQYx3tX.png">
<meta property="og:image" content="https://i.loli.net/2021/02/27/3NHWPUmhrfbKXly.png">
<meta property="og:image" content="https://i.loli.net/2021/02/27/ReksFliDnWt5TPj.png">
<meta property="og:image" content="https://i.loli.net/2021/02/27/eagT1pLnc4iJIMX.png">
<meta property="og:image" content="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/1.png">
<meta property="og:image" content="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/2.png">
<meta property="og:image" content="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/3.png">
<meta property="og:image" content="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/4.png">
<meta property="og:image" content="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/5.png">
<meta property="og:image" content="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/6.png">
<meta property="og:image" content="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/7.png">
<meta property="og:image" content="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/8.png">
<meta property="og:image" content="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/9.png">
<meta property="og:image" content="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/10.png">
<meta property="og:image" content="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/11.png">
<meta property="og:image" content="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/12.png">
<meta property="og:image" content="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/13.png">
<meta property="og:image" content="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/14.png">
<meta property="og:image" content="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/15.png">
<meta property="og:image" content="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/16.png">
<meta property="og:image" content="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/17.png">
<meta property="og:image" content="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/18.png">
<meta property="og:image" content="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227182900.png">
<meta property="og:image" content="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227182903.png">
<meta property="og:image" content="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227182909.png">
<meta property="og:image" content="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227182911.png">
<meta property="og:image" content="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227182913.png">
<meta property="og:image" content="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227182918.png">
<meta property="og:image" content="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227182920.png">
<meta property="og:image" content="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227182922.png">
<meta property="og:image" content="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227182924.png">
<meta property="og:image" content="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227182930.png">
<meta property="og:image" content="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227182932.png">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/4064751-9ef7887aca675269.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/526/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/4064751-98d670ae394f3695.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/651/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/4064751-7d75da02d729e64c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/824/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/4064751-c9ece5586fa955f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/824/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/4064751-0f7469ff0be704de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/485/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/4064751-af16c3d5a506e610.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/634/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/4064751-afa3948a9e805a67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/457/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/4064751-8f5334960c871d0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500/format/webp">
<meta property="og:image" content="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227182940.png">
<meta property="og:image" content="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227182947.png">
<meta property="og:image" content="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227182951.png">
<meta property="og:image" content="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227182955.png">
<meta property="og:image" content="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227183000.png">
<meta property="og:image" content="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227183008.png">
<meta property="og:image" content="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227183014.png">
<meta property="og:image" content="https://img-blog.csdn.net/20170327144317062">
<meta property="og:image" content="https://img-blog.csdn.net/20170327162904721">
<meta property="og:image" content="https://img-blog.csdn.net/20170327162956884">
<meta property="og:image" content="https://img-blog.csdn.net/20170327164357916">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMzMwNDMxNjgtMTg2NzgxNzg2OS5wbmc?x-oss-process=image/format,png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMzMyMjA2MzctMTA1NTA4ODExOC5wbmc?x-oss-process=image/format,png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMjMyMzg0NDktMjE0NjE2OTE5Ny5naWY">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMjU2NDUyNzctMTE1MTEwMDAwMC5naWY">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMzA1NTcwNDMtMzczNzUwMTAuZ2lm">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMzEzMDg2OTktMzU2MTM0MjM3LmdpZg">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMzE3NDA4NDAtNjk2ODE4MS5naWY">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMzIxMDcwOTAtMTkyMDcwMjAxMS5wbmc?x-oss-process=image/format,png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMzI0NTM2NjgtMTM5NzY2MjUyNy5naWY">
<meta property="article:published_time" content="2021-03-19T08:32:00.000Z">
<meta property="article:modified_time" content="2021-03-19T08:32:44.612Z">
<meta property="article:author" content="Colorfuls">
<meta property="article:tag" content="数据结构和算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/27/XLHYj2UJDnf8g4I.png">


<link rel="canonical" href="http://example.com/2021/03/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%80%BB%E7%BB%93%E7%89%88/">


<script data-pjax class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<title>数据结构和算法 | Colorfuls-Blogs</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Colorfuls-Blogs</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">追风去</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-article"><a href="/article" rel="section"><i class="fa fa-newspaper fa-fw"></i>文章</a></li>
        <li class="menu-item menu-item-teach"><a href="/teach" rel="section"><i class="fa fa-address-card fa-fw"></i>教程</a></li>
        <li class="menu-item menu-item-site"><a href="/site" rel="section"><i class="fa fa-star fa-fw"></i>站点</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">1.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88%EF%BC%88stack"><span class="nav-number">1.2.</span> <span class="nav-text">栈（stack)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#javascript-%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%88%E7%BA%BF%E6%80%A7%E5%AD%98%E5%82%A8%EF%BC%89"><span class="nav-number">1.2.1.</span> <span class="nav-text">javascript 栈的实现（线性存储）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">1.2.2.</span> <span class="nav-text">栈的应用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%9F%E5%88%97-queue"><span class="nav-number">1.3.</span> <span class="nav-text">队列(queue)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#js-%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%88%E7%BA%BF%E6%80%A7%E5%AD%98%E5%82%A8%EF%BC%89"><span class="nav-number">1.3.1.</span> <span class="nav-text">js 队列的实现（线性存储）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84"><span class="nav-number">1.4.</span> <span class="nav-text">链表结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E7%AE%80%E4%BB%8B"><span class="nav-number">1.4.1.</span> <span class="nav-text">单向链表简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#js-%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.4.2.</span> <span class="nav-text">js 单链表的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%AE%80%E4%BB%8B"><span class="nav-number">1.4.3.</span> <span class="nav-text">双向链表简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#js-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.4.4.</span> <span class="nav-text">js 双向链表的实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E7%BB%93%E6%9E%84"><span class="nav-number">1.5.</span> <span class="nav-text">集合结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B-1"><span class="nav-number">1.5.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#js-%E9%9B%86%E5%90%88%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.5.2.</span> <span class="nav-text">js 集合实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E5%85%B8%E7%BB%93%E6%9E%84"><span class="nav-number">1.6.</span> <span class="nav-text">字典结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="nav-number">1.7.</span> <span class="nav-text">哈希表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91%EF%BC%88tree"><span class="nav-number">1.8.</span> <span class="nav-text">树（tree)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E6%A0%91%E7%BB%93%E6%9E%84%E7%AE%80%E4%BB%8B"><span class="nav-number">1.8.1.</span> <span class="nav-text">一、树结构简介</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3%E6%A0%91%E7%BB%93%E6%9E%84"><span class="nav-number">1.8.1.1.</span> <span class="nav-text">1.1.简单了解树结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-%E6%A0%91%E7%BB%93%E6%9E%84%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E5%BC%8F"><span class="nav-number">1.8.1.2.</span> <span class="nav-text">1.2.树结构的表示方式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">1.8.2.</span> <span class="nav-text">二、二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%80%E4%BB%8B"><span class="nav-number">1.8.2.1.</span> <span class="nav-text">2.1.二叉树简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8"><span class="nav-number">1.8.2.2.</span> <span class="nav-text">2.3.二叉树的数据存储</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">1.8.3.</span> <span class="nav-text">三、二叉搜索树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%A4%E8%AF%86%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">1.8.3.1.</span> <span class="nav-text">认识二叉搜索树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B"><span class="nav-number">1.8.3.2.</span> <span class="nav-text">二叉搜索树应用举例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.8.3.3.</span> <span class="nav-text">二叉搜索树的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%BC%BA%E9%99%B7"><span class="nav-number">1.8.3.4.</span> <span class="nav-text">二叉搜索树的缺陷</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE%E7%BB%93%E6%9E%84"><span class="nav-number">1.9.</span> <span class="nav-text">图结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E7%AE%80%E4%BB%8B"><span class="nav-number">1.9.1.</span> <span class="nav-text">图简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%9B%BE%EF%BC%9F"><span class="nav-number">1.9.2.</span> <span class="nav-text">为什么要使用图？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B6%E7%82%B9%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="nav-number">1.9.3.</span> <span class="nav-text">顶点的表示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.9.4.</span> <span class="nav-text">图的实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%EF%BC%88algorithm%EF%BC%89"><span class="nav-number">2.</span> <span class="nav-text">算法（algorithm）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B-2"><span class="nav-number">2.1.</span> <span class="nav-text">简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7"><span class="nav-number">2.1.1.</span> <span class="nav-text">算法的基本特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E7%9A%84%E8%A6%81%E6%B1%82"><span class="nav-number">2.1.2.</span> <span class="nav-text">算法设计的要求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E7%9A%84%E5%BA%A6%E9%87%8F"><span class="nav-number">2.1.3.</span> <span class="nav-text">算法的度量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">2.1.3.1.</span> <span class="nav-text">算法时间复杂度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">2.1.3.2.</span> <span class="nav-text">算法空间复杂度</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="nav-number">2.2.</span> <span class="nav-text">排序算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B-3"><span class="nav-number">2.2.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%EF%BC%88Bubble-Sort%EF%BC%89"><span class="nav-number">2.2.2.</span> <span class="nav-text">冒泡排序（Bubble Sort）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%88Insertion-Sort%EF%BC%89"><span class="nav-number">2.2.3.</span> <span class="nav-text">插入排序（Insertion Sort）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%EF%BC%88Merge-Sort%EF%BC%89"><span class="nav-number">2.3.</span> <span class="nav-text">5、归并排序（Merge Sort）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7%E3%80%81%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%88Heap-Sort%EF%BC%89"><span class="nav-number">2.4.</span> <span class="nav-text">7、堆排序（Heap Sort）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8%E3%80%81%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%88Counting-Sort%EF%BC%89"><span class="nav-number">2.5.</span> <span class="nav-text">8、计数排序（Counting Sort）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9%E3%80%81%E6%A1%B6%E6%8E%92%E5%BA%8F%EF%BC%88Bucket-Sort%EF%BC%89"><span class="nav-number">2.6.</span> <span class="nav-text">9、桶排序（Bucket Sort）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%88Radix-Sort%EF%BC%89"><span class="nav-number">2.6.1.</span> <span class="nav-text">基数排序（Radix Sort）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95"><span class="nav-number">2.7.</span> <span class="nav-text">查找算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-number">2.7.1.</span> <span class="nav-text">二分查找</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Colorfuls</p>
  <div class="site-description" itemprop="description">前路浩浩荡荡，万事皆可期待。</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/maogecarry" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;maogecarry" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%80%BB%E7%BB%93%E7%89%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Colorfuls">
      <meta itemprop="description" content="前路浩浩荡荡，万事皆可期待。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Colorfuls-Blogs">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数据结构和算法
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-03-19 16:32:00 / 修改时间：16:32:44" itemprop="dateCreated datePublished" datetime="2021-03-19T16:32:00+08:00">2021-03-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>数据结构是相互之间存在一种或多种特定关系的数据元素的集合</p>
</blockquote>
<h2 id="栈（stack"><a href="#栈（stack" class="headerlink" title="栈（stack)"></a>栈（stack)</h2><blockquote>
<p>栈是一种操作受限的线性表只允许从一端插入和删除数据。</p>
<p>栈有两种存储方式，即线性存储和链接存储（链表）。栈的一个最重要的特征就是栈的插入和删除只能在栈顶进行，所以每次删除的元素都是最后进栈的元素，故栈也被称为后进先出（LIFO）表。每个栈都有一个栈顶指针，它初始值为-1，且总是指向最后一个入栈的元素，栈有两种处理方式，即进栈（push）和出栈（pop），因为在进栈只需要移动一个变量存储空间，所以它的时间复杂度为 O(1)，但是对于出栈分两种情况，栈未满时，时间复杂度也为 O(1)，但是当栈满时，需要重新分配内存，并移动栈内所有数据，所以此时的时间复杂度为 O(n)。以下举例栈结构的两种实现方式，线性存储和链接存储。</p>
</blockquote>
<h3 id="javascript-栈的实现（线性存储）"><a href="#javascript-栈的实现（线性存储）" class="headerlink" title="javascript 栈的实现（线性存储）"></a>javascript 栈的实现（线性存储）</h3><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;封装栈类
   function Stack() &#123;
     &#x2F;&#x2F;栈中的属性
     this.items &#x3D; []
     &#x2F;&#x2F;栈的相关操作
     &#x2F;&#x2F;  1、将元素压入栈
     Stack.prototype.push &#x3D; function (element) &#123;
       this.items.push(element)
     &#125;
     &#x2F;&#x2F; 2、从栈中取出元素
     Stack.prototype.pop &#x3D; function () &#123;
       return this.items.pop()
     &#125;
     &#x2F;&#x2F;3、查看栈顶元素
     Stack.prototype.peek &#x3D; function () &#123;
       return this.items[this.items.length - 1]
     &#125;
     &#x2F;&#x2F; 4、判断栈是否为空
     Stack.prototype.isEmpty &#x3D; function () &#123;
       return this.items.length &#x3D;&#x3D; 0
     &#125;
     &#x2F;&#x2F; 5、获取栈中元素的个数
     Stack.prototype.size &#x3D; function () &#123;
       return this.items.length
     &#125;
     &#x2F;&#x2F; 6、toString方法
     Stack.prototype.toString &#x3D; function () &#123;
       let resultString &#x3D; &quot;&quot;
       for (let i &#x3D; 0; i &lt; this.items.length; i++) &#123;
         resultString +&#x3D; this.items[i] + &#39; &#39;
       &#125;
       return resultString
     &#125;
   &#125;
   &#x2F;&#x2F;栈的使用
   var s &#x3D; new Stack()
   s.push(&#39;2&#39;)
   s.push(&#39;3&#39;)
   s.push(&#39;4&#39;)
   console.log(s);
   console.log(s.size()); &#x2F;&#x2F;3
   console.log(s.peek()); &#x2F;&#x2F;4
   console.log(s.isEmpty()); &#x2F;&#x2F;false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h3><p><strong>1、把十进制数转为二进制数</strong></p>
<p>​ 要把十进制转化成二进制，我们可以将十进制数字和 2 整除(向下取整)（二进制是满二进一），直到结果是 0 为止。</p>
<p>​ 举个例子，把十进制的数字 10 转化成二进制的数字，过程大概是这样：</p>
<p>​ <img src="https://i.loli.net/2021/02/27/XLHYj2UJDnf8g4I.png" alt="image-20210116173230197" style="zoom:80%;" /></p>
<p>代码实现（栈实现代码继续使用上面的代码）：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 函数：将十进制转成二进制
     &#x2F;&#x2F; 十进制  二进制
     &#x2F;&#x2F; Decimal binary
   function dec2bin(decNumber) &#123;
     &#x2F;&#x2F; 1、定义栈对象
     let stack &#x3D; new Stack()

     &#x2F;&#x2F; 2、循环操作
     while(decNumber &gt; 0)&#123;
       &#x2F;&#x2F; 2.1、获取余数，并且放入到栈中
       stack.push(decNumber % 2)

       &#x2F;&#x2F;2.2、获取整除后的结果，作为下一次运行的数字
       decNumber &#x3D; Math.floor(decNumber &#x2F; 2)
     &#125;

     &#x2F;&#x2F; 3、从栈中取出0和1
     let binaryString &#x3D; &quot;&quot;
     while(!stack.isEmpty())&#123;
       binaryString +&#x3D; stack.pop()
     &#125;
     return binaryString
   &#125;
   &#x2F;&#x2F;测试十进制转二进制的函数
   console.log(dec2bin(5));  &#x2F;&#x2F;101
   console.log(dec2bin(50)); &#x2F;&#x2F;110010<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="队列-queue"><a href="#队列-queue" class="headerlink" title="队列(queue)"></a>队列(queue)</h2><blockquote>
<p>只允许在一端插入数据操作，在另一端进行删除数据操作的特殊线性表；</p>
<p>进行插入操作的一端称为队尾（入队列），进行删除操作的一端称为队头（出队列）；队列具有先进先出（FIFO）的特性。</p>
</blockquote>
<h3 id="js-队列的实现（线性存储）"><a href="#js-队列的实现（线性存储）" class="headerlink" title="js 队列的实现（线性存储）"></a>js 队列的实现（线性存储）</h3><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;封装队列类
    function Queue() &#123;
      &#x2F;&#x2F;队列中的属性
      this.items &#x3D; []
      &#x2F;&#x2F;栈的相关操作
      &#x2F;&#x2F;  1、将元素加入到队列中
      Queue.prototype.add &#x3D; function (element) &#123;
        this.items.push(element)
      &#125;
      &#x2F;&#x2F; 2、从队列中删除前端元素
      Queue.prototype.delete &#x3D; function () &#123;
        return this.items.shift()
      &#125;
      &#x2F;&#x2F;3、查看队列前端元素
      Queue.prototype.front &#x3D; function () &#123;
        return this.items[0]
      &#125;
      &#x2F;&#x2F; 4、判断队列是否为空
      Queue.prototype.isEmpty &#x3D; function () &#123;
        return this.items.length &#x3D;&#x3D; 0
      &#125;
      &#x2F;&#x2F; 5、获取队列中元素的个数
      Queue.prototype.size &#x3D; function () &#123;
        return this.items.length
      &#125;
      &#x2F;&#x2F; 6、toString方法
      Queue.prototype.toString &#x3D; function () &#123;
        let resultString &#x3D; &quot;&quot;
        for (let i &#x3D; 0; i &lt; this.items.length; i++) &#123;
          resultString +&#x3D; this.items[i] + &#39; &#39;
        &#125;
        return resultString
      &#125;
    &#125;
    &#x2F;&#x2F;队列的使用
    let q &#x3D; new Queue()
    q.add(&#39;22&#39;)
    q.add(&#39;33&#39;)
    q.add(&#39;44&#39;)
    q.delete()
    console.log(q);
    console.log(q.size());
    console.log(q.front());
    console.log(q.isEmpty());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>优先级队列的实现：</p>
<p>​ 实现优先级队列主要考虑两个方面：</p>
<p>​ 1、封装元素和优先级放在一起（可以封装一个新的构造函数）</p>
<p>​ 2、添加元素时，将新插入元素的优先级和队列中已经存在的元素优先级进行比较，以获得自己正确的位置。</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;封装优先级队列
    function PriorityQueue() &#123;
      &#x2F;&#x2F;在PriorityQueue重新创建了一个类：可以理解为内部类
      function QueueElement(element, priority) &#123;
        this.element &#x3D; element
        this.priority &#x3D; priority
      &#125;
      &#x2F;&#x2F;封装属性
      this.items &#x3D; []
      &#x2F;&#x2F;实现插入方法
      PriorityQueue.prototype.add &#x3D; function (element, priority) &#123;
        &#x2F;&#x2F;1、创建QueueElement实例
        let queueElement &#x3D; new QueueElement(element, priority)

        &#x2F;&#x2F; 2、判断队列是否为空
        if (this.items.length &#x3D;&#x3D; 0) &#123;
          this.items.push(queueElement)
        &#125; else &#123;
          let added &#x3D; false
          for (let i &#x3D; 0; i &lt; this.items.length; i++) &#123;
            if (queueElement.priority &gt; this.items[i].priority) &#123;
              this.items.splice(i, 0, queueElement)
              added &#x3D; true
              break
            &#125;
          &#125;
          if (!added) &#123;
            this.items.push(queueElement)
          &#125;
        &#125;

      &#125;
      &#x2F;&#x2F; 2、从队列中删除前端元素
      PriorityQueue.prototype.delete &#x3D; function () &#123;
        return this.items.shift()
      &#125;
      &#x2F;&#x2F;3、查看队列前端元素
      PriorityQueue.prototype.front &#x3D; function () &#123;
        return this.items[0]
      &#125;
      &#x2F;&#x2F; 4、判断队列是否为空
      PriorityQueue.prototype.isEmpty &#x3D; function () &#123;
        return this.items.length &#x3D;&#x3D; 0
      &#125;
      &#x2F;&#x2F; 5、获取队列中元素的个数
      PriorityQueue.prototype.size &#x3D; function () &#123;
        return this.items.length
      &#125;
      &#x2F;&#x2F; 6、toString方法
      PriorityQueue.prototype.toString &#x3D; function () &#123;
        let resultString &#x3D; &quot;&quot;
        for (let i &#x3D; 0; i &lt; this.items.length; i++) &#123;
          resultString +&#x3D; &quot;&lt;——&quot; + &quot;[&quot; + this.items[i].element + &#39;，&#39; + this.items[i].priority + &quot;]&quot;
        &#125;
        return resultString
      &#125;
    &#125;
    let q &#x3D; new PriorityQueue()
    q.add(&#39;三级(a)&#39;, 1)
    q.add(&#39;一级(b)&#39;, 100)
    q.add(&#39;二级(c)&#39;, 10)
    q.add(&#39;三级(d)&#39;, 1)
    q.add(&#39;一级(e)&#39;, 100)
    q.add(&#39;二级(f)&#39;, 10)
    console.log(q.front())    &#x2F;&#x2F; QueueElement &#123;element: &quot;一级(b)&quot;, priority: 100&#125;element: &quot;一级(b)&quot;priority: 100__proto__: Object
    console.log(q.size())	&#x2F;&#x2F;6
    console.log(q.toString()) &#x2F;&#x2F;&lt;——[一级(b)，100]&lt;——[一级(e)，100]&lt;——[二级(c)，10]&lt;——[二级(f)，10]&lt;——[三级(a)，1]&lt;——[三级(d)，1]
    q.delete()
    console.log(q.size()) 	&#x2F;&#x2F;5
    console.log(q.toString()) &#x2F;&#x2F;&lt;——[一级(e)，100]&lt;——[二级(c)，10]&lt;——[二级(f)，10]&lt;——[三级(a)，1]&lt;——[三级(d)，1]
    q.add(&#39;二级(g)&#39;, 10)
    console.log(q.size())     &#x2F;&#x2F;6
    console.log(q.toString()) &#x2F;&#x2F;&lt;——[一级(e)，100]&lt;——[二级(c)，10]&lt;——[二级(f)，10]&lt;——[二级(g)，10]&lt;——[三级(a)，1]&lt;——[三级(d)，1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="链表结构"><a href="#链表结构" class="headerlink" title="链表结构"></a>链表结构</h2><h3 id="单向链表简介"><a href="#单向链表简介" class="headerlink" title="单向链表简介"></a>单向链表简介</h3><blockquote>
<p>链表是一种物理<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E5%8D%95%E5%85%83/8727749">存储单元</a>上非连续、非顺序的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/350782">存储结构</a>，<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0/715313">数据元素</a>的逻辑顺序是通过链表中的引用或者<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88/2878304">指针</a>链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0">数据元素</a>的数据域，另一个是存储下一个结点地址的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88/2878304">指针</a>域。</p>
</blockquote>
<p><img src="https://img-blog.csdn.net/20180502195346635" alt="img"></p>
<p><strong>相对于数组，链表有以下优势：</strong></p>
<p>​ 1、内存空间不是必须连续的，可以充分，利用计算机的内存，实现灵活的内存动态管理</p>
<p>​ 2、链表不必在创建时就确定大小，并且大小可以无限的延伸下去</p>
<p>​ 3、链表在插入和删除数据时，时间复杂度可以达到 O(1),相对数组效率高很多</p>
<p>注：插入操作复杂度：单链表 表头 O(1) 表尾 O(n)<br>循环链表 表头 O(1) 表尾 O(n)<br>双向链表 O(1)</p>
<p><strong>相对于数组，链表有以下缺点：</strong></p>
<p>​ 1、链表访问任何一个位置的元素时，都需要从头开始访问。（无法跳过第一个元素访问任何一个元素)</p>
<p>​ 2、无法通过下标直接访问元素，需要从头一个个访问，直到找到对应元素，时间复杂度为 O(n),而线性表和顺序表相应的时间复杂度分别是 O(logn)和 O(1)。</p>
<h3 id="js-单链表的实现"><a href="#js-单链表的实现" class="headerlink" title="js 单链表的实现"></a>js 单链表的实现</h3><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;封装单向链表类
    function LinkedList() &#123;
      &#x2F;&#x2F;内部类：节点类
      function Node(data) &#123;
        this.data &#x3D; data
        this.next &#x3D; null
      &#125;
      &#x2F;&#x2F;属性
      this.head &#x3D; null
      this.length &#x3D; 0
      &#x2F;&#x2F;1、append追加方法
      LinkedList.prototype.append &#x3D; function (data) &#123;
        &#x2F;&#x2F; 1、创建新的节点
        let newNode &#x3D; new Node(data)
        &#x2F;&#x2F;2、判断是否添加的是第一个节点
        if (this.length &#x3D;&#x3D;&#x3D; 0) &#123;   &#x2F;&#x2F;2.1、是第一个节点
          this.head &#x3D; newNode
        &#125; else &#123;                   &#x2F;&#x2F;2.2、不是第一个节点
          &#x2F;&#x2F;找到最后一个节点
          let current &#x3D; this.head
          while (current.next) &#123;
            current &#x3D; current.next
          &#125;
          &#x2F;&#x2F;最后节点的next指向新的节点
          current.next &#x3D; newNode
        &#125;
        this.length++
      &#125;
      &#x2F;&#x2F; 3、insert插入方法
      LinkedList.prototype.insert &#x3D; function (position, data) &#123;
        &#x2F;&#x2F; 1、对position进行越界判断
        if (position &lt; 0 || position &gt; this.length) &#123;
          return false
        &#125;
        &#x2F;&#x2F;2、根据data创建newNode
        let newNode &#x3D; new Node(data)
        &#x2F;&#x2F; 3、判断插入的位置是否是第一个
        if (position &#x3D;&#x3D;&#x3D; 0) &#123;
          newNode.next &#x3D; this.head
          this.head &#x3D; newNode
        &#125; else &#123;
          let index &#x3D; 0

          let previous &#x3D; null
          while (index &lt; position) &#123;
            index++
            previous &#x3D; current
            current &#x3D; current.next
          &#125;
          newNode.next &#x3D; current
          previous.next &#x3D; newNode
        &#125;
        &#x2F;&#x2F; 4、length ++
        this.length++
        return true
      &#125;
      &#x2F;&#x2F;2、toString将链表转成字符串形式
      LinkedList.prototype.toString &#x3D; function () &#123;
        let str &#x3D; &#39;&#39;
        let current &#x3D; this.head
        &#x2F;&#x2F;while循环中的括号会进行隐性转换
        while (current) &#123;
          str +&#x3D; current.data + &quot; &quot;
          current &#x3D; current.next
        &#125;
        return str
      &#125;
      &#x2F;&#x2F; 3、get方法 获取对应位置的元素
      LinkedList.prototype.get &#x3D; function (position) &#123;
        &#x2F;&#x2F; 1、对position进行越界判断
        if (position &lt; 0 || position &gt;&#x3D; this.length) &#123;
          return false
        &#125;
        &#x2F;&#x2F; 2、获得对应的data
        let current &#x3D; this.head
        let index &#x3D; 0
        while (index &lt; position) &#123;
          index++
          current &#x3D; current.next
        &#125;
        return current.data
      &#125;
      &#x2F;&#x2F; 4、indexOf 返回元素在列表中的索引
      LinkedList.prototype.indexOf &#x3D; function (data) &#123;
        &#x2F;&#x2F; 2、获得对应的data
        let current &#x3D; this.head
        let index &#x3D; 0
        while (current) &#123;
          if (current.data &#x3D;&#x3D;&#x3D; data) &#123;
            flag &#x3D; true
            return index
          &#125;
          index++
          current &#x3D; current.next
        &#125;
        return -1
      &#125;
      &#x2F;&#x2F; 5、update方法 修改某个位置的元素
      LinkedList.prototype.update &#x3D; function (position, newData) &#123;
        &#x2F;&#x2F; 1、对position进行越界判断
        if (position &lt; 0 || position &gt;&#x3D; this.length) &#123;
          return false
        &#125;
        &#x2F;&#x2F; 2、查找正确的节点
        let current &#x3D; this.head
        let index &#x3D; 0
        while (index &lt; position) &#123;
          index++
          current &#x3D; current.next
        &#125;
        &#x2F;&#x2F; 3、将position位置的node的data修改成newData
        current.data &#x3D; newData
        return true
      &#125;
      &#x2F;&#x2F; 6、removeAt 从列表的特定位置移除一项
      LinkedList.prototype.removeAt &#x3D; function (position) &#123;
        &#x2F;&#x2F; 1、对position进行越界判断
        if (position &lt; 0 || position &gt;&#x3D; this.length) &#123;
          return false
        &#125;
        &#x2F;&#x2F; 2、判断是否删除的是第一个节点
        if (position &#x3D;&#x3D;&#x3D; 0) &#123;
          this.head &#x3D; this.head.next
          this.head.next &#x3D; null
        &#125;
        else &#123;
          let index &#x3D; 0
          let current &#x3D; this.head
          let previous &#x3D; null
          while (index &lt; position) &#123;
            index++
            previous &#x3D; current
            current &#x3D; current.next
          &#125;
          &#x2F;&#x2F; 前一个节点的next指current的next即可
          previous.next &#x3D; current.next
          current.next &#x3D; null
          &#x2F;&#x2F; 3、length - 1
          this.length--
          return true
        &#125;
      &#125;
      &#x2F;&#x2F; 7、remove从列表中移除一项
      LinkedList.prototype.remove &#x3D; function (data) &#123;
        &#x2F;&#x2F; 1、获取data在列表中的位置
        let position &#x3D; this.indexOf(data)
        &#x2F;&#x2F; 2、根据位置信息，删除节点
        return this.removeAt(position)
      &#125;
      &#x2F;&#x2F; 8、isEmpty 如果链表中不包含任何元素，返回true,如果链表长度大于0则返回false
      LinkedList.prototype.isEmpty &#x3D; function () &#123;
        return this.length &#x3D;&#x3D;&#x3D; 0
      &#125;
      &#x2F;&#x2F;9、size 如果链表包含的元素个数
      LinkedList.prototype.size &#x3D; function () &#123;
        return this.length
      &#125;
    &#125;
    &#x2F;&#x2F;實例化單鏈表
    let link &#x3D; new LinkedList()
    link.append(&#39;10&#39;)
    link.append(&#39;11&#39;)
    console.log(link);
    link.insert(1, &#39;fuck&#39;)
    link.insert(3, &#39;you&#39;)
    console.log(link.toString());
    console.log(link.get(1));
    console.log(link.indexOf(&#39;fuck&#39;));
    console.log(link.update(1, &#39;fuc&#39;));
    link.removeAt(3)
    link.remove(&#39;11&#39;)
    console.log(link.toString());
    console.log(link.isEmpty());
    console.log(link.size());
  &lt;&#x2F;script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>插入操作图示</p>
<img src="https://i.loli.net/2021/02/27/hf1Lld9nB2AFZY5.png" alt="image-20210120214609061" style="zoom:80%;" />

<h3 id="双向链表简介"><a href="#双向链表简介" class="headerlink" title="双向链表简介"></a>双向链表简介</h3><blockquote>
<p>双向链表也叫双链表，是链表的一种，它的每个数据<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%BB%93%E7%82%B9/9794643">结点</a>中都有两个引用或<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88/2878304">指针</a>，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。一般我们都构造双向<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/3228465">循环链表</a>。</p>
</blockquote>
<img src="https://images2015.cnblogs.com/blog/1146465/201704/1146465-20170429154748350-758050755.png" alt="img" />

<p><img src="https://i.loli.net/2021/02/27/PZybI8rs74BgjUD.png" alt="image-20210121115202505"></p>
<p>特点：</p>
<p>1、既可以从头遍历到尾，也可以从尾遍历到头</p>
<p>2、一个节点既有向前连接的引用，也有一个向后连接的引用</p>
<p>双向链表的缺点：</p>
<p>1、每次在插入或删除某个节点时，需要处理四个引用，而不是两个。也就是实现起来要困难一些</p>
<p>2、并且对比单向链表，占用内存空间更大一些</p>
<p>但是这些缺点和我们使用起来的方便程度相比是微不足道的</p>
<h3 id="js-双向链表的实现"><a href="#js-双向链表的实现" class="headerlink" title="js 双向链表的实现"></a>js 双向链表的实现</h3><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;封装双向链表
function DoublyLinkedList() &#123;
  &#x2F;&#x2F;内部类：节点类
  function Node(data) &#123;
    this.data &#x3D; data
    this.prev &#x3D; null
    this.next &#x3D; null
  &#125;
  &#x2F;&#x2F;属性
  this.head &#x3D; null
  this.tail &#x3D; null
  this.length &#x3D; 0
  &#x2F;&#x2F; 常见的操作：方法
  &#x2F;&#x2F; 1、append方法
  DoublyLinkedList.prototype.append &#x3D; function (data) &#123;
    &#x2F;&#x2F; 1、根据data创建节点
    let newNode &#x3D; new Node(data)
    &#x2F;&#x2F; 2、判断添加的是否是第一个节点
    if (this.length &#x3D;&#x3D; 0) &#123;
      this.head &#x3D; newNode
      this.tail &#x3D; newNode
    &#125; else &#123;
      newNode.prev &#x3D; this.tail
      this.tail.next &#x3D; newNode
      this.tail &#x3D; newNode
    &#125;
    this.length++
  &#125;
  &#x2F;&#x2F; 2、insert 插入
  DoublyLinkedList.prototype.insert &#x3D; function (position, data) &#123;
    &#x2F;&#x2F; 1、越界判断
    if (position &lt; 0 || position &gt; this.length) &#123;
      return false
    &#125;
    &#x2F;&#x2F; 2、根据data创建新的节点
    let newNode &#x3D; new Node(data)
    &#x2F;&#x2F; 3、判断原来的列表是否为空
    if (this.length &#x3D;&#x3D;&#x3D; 0) &#123;
      this.head &#x3D; newNode
      this.tail &#x3D; newNode
    &#125; else &#123;
      if (position &#x3D;&#x3D;&#x3D; 0) &#123;   &#x2F;&#x2F;2.1、判断position是否为0
        this.head.prev &#x3D; newNode
        newNode.next &#x3D; this.head
        this.head &#x3D; newNode
      &#125; else if (position &#x3D;&#x3D;&#x3D; this.length) &#123;
        this.tail.next &#x3D; newNode
        newNode.prev &#x3D; this.tail
        this.tail &#x3D; newNode
        newNode.next &#x3D; null
      &#125; else &#123;
        let current &#x3D; this.head
        let index &#x3D; 0
        while (index &lt; position) &#123;
          index++
          current &#x3D; current.next
        &#125;
        &#x2F;&#x2F;修改指针
        current.prev.next &#x3D; newNode
        newNode.prev &#x3D; current.prev
        newNode.next &#x3D; current
        current.prev &#x3D; newNode
      &#125;
    &#125;
    this.length++
    return true
  &#125;
  &#x2F;&#x2F; 3、get方法
  DoublyLinkedList.prototype.get &#x3D; function (position) &#123;
    &#x2F;&#x2F; 1、越界判断
    if (position &lt; 0 || position &gt;&#x3D; this.length) &#123;
      return false
    &#125;
    &#x2F;&#x2F; 2、获取元素
    let current &#x3D; this.head
    let index &#x3D; 0
    while (index &lt; position) &#123;
      index++
      current &#x3D; current.next
    &#125;
    return current.data
  &#125;
  &#x2F;&#x2F; 4、indexOf方法
  DoublyLinkedList.prototype.indexOf &#x3D; function (data) &#123;
    let current &#x3D; this.head
    let index &#x3D; 0
    while (current) &#123;
      if (current.data &#x3D;&#x3D;&#x3D; data) &#123;
        return index
      &#125; else &#123;
        current &#x3D; current.next
        index++
      &#125;
    &#125;
    return -1
  &#125;
  &#x2F;&#x2F; 5、update方法
  DoublyLinkedList.prototype.update &#x3D; function (position, data) &#123;
    &#x2F;&#x2F; 1、越界判断
    if (position &lt; 0 || position &gt;&#x3D; this.length) &#123;
      return false
    &#125;
    &#x2F;&#x2F; 2、获取元素
    let current &#x3D; this.head
    let index &#x3D; 0
    while (index &lt; position) &#123;
      index++
      current &#x3D; current.next
    &#125;
    current.data &#x3D; data
    return true
  &#125;
  &#x2F;&#x2F; 6、removeAt 从列表的特定位置移除一项
  DoublyLinkedList.prototype.removeAt &#x3D; function (position) &#123;
    &#x2F;&#x2F; 1、越界判断
    if (position &lt; 0 || position &gt;&#x3D; this.length) &#123;
      return false
    &#125;
    &#x2F;&#x2F; 2,判断是否只有一个节点
    let current &#x3D; this.head
    if (this.length &#x3D;&#x3D;&#x3D; 0) &#123;
      this.head &#x3D; null
      this.tail &#x3D; null
    &#125; else &#123;
      if (position &#x3D;&#x3D; 0) &#123;   &#x2F;&#x2F;判断是否删除的是第一个节点
        this.head.next.prev &#x3D; null
        this.head &#x3D; this.head.next
      &#125; else if (position &#x3D;&#x3D; this.length - 1) &#123;  &#x2F;&#x2F;最后节点
        current &#x3D; this.tail
        this.tail.prev.next &#x3D; null
        this.tail &#x3D; this.tail.prev
      &#125; else &#123;
        let index &#x3D; 0

        while (index &lt; position) &#123;
          current &#x3D; current.next
          index++
        &#125;
        current.prev.next &#x3D; current.next
        current.next.prev &#x3D; current.prev
      &#125;
    &#125;
    this.length--
    return current.data
  &#125;
  &#x2F;&#x2F; 7,remove方法
  DoublyLinkedList.prototype.remove &#x3D; function (data) &#123;
    &#x2F;&#x2F; 1,根据data获取下标值
    let index &#x3D; this.indexOf(data)
    &#x2F;&#x2F; 2,根据index删除对应位置的节点
    return this.removeAt(index)
  &#125;
  &#x2F;&#x2F; 8,isEmpty方法
  DoublyLinkedList.prototype.isEmpty &#x3D; function () &#123;
    return this.length
  &#125;
  &#x2F;&#x2F; 9,size方法
  DoublyLinkedList.prototype.size &#x3D; function () &#123;
    return this.length
  &#125;
  &#x2F;&#x2F; 10,获取链表的第一个元素
  DoublyLinkedList.prototype.getHead &#x3D; function () &#123;
    return this.head.data
  &#125;
  &#x2F;&#x2F; 11,获取链表的最后一个元素
  DoublyLinkedList.prototype.getTail &#x3D; function () &#123;
    return this.tail.data
  &#125;
  &#x2F;&#x2F; toString方法
  DoublyLinkedList.prototype.toString &#x3D; function () &#123;
    return this.forwardString()
  &#125;
  &#x2F;&#x2F;  forwardString 返回正向遍历的节点字符串形式
  DoublyLinkedList.prototype.forwardString &#x3D; function () &#123;
    let str &#x3D; &#39;&#39;
    let current &#x3D; this.head
    while (current !&#x3D;&#x3D; null) &#123;
      str +&#x3D; current.data + &quot; &quot;
      current &#x3D; current.next
    &#125;
    return str
  &#125;
  &#x2F;&#x2F; backwardString 返回反向遍历的节点字符串形式
  DoublyLinkedList.prototype.backwardString &#x3D; function () &#123;
    let str &#x3D; &#39;&#39;
    let current &#x3D; this.tail
    while (current !&#x3D;&#x3D; null) &#123;
      str +&#x3D; current.data + &quot; &quot;
      current &#x3D; current.prev
    &#125;
    return str
  &#125;
&#125;
let link &#x3D; new DoublyLinkedList()
link.append(1)
link.append(2)
link.append(3)
link.insert(2, 4)
link.insert(3, 5)

console.log(link.update(1, &#39;update&#39;))
console.log(link.removeAt(0));
console.log(link.toString());
console.log(link.backwardString());
console.log(link.get(4));
console.log(link.indexOf(4));
console.log(link.size());
console.log(link.getHead());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="集合结构"><a href="#集合结构" class="headerlink" title="集合结构"></a>集合结构</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>同数学中所学的一样，集合(Set)是由一组无序但彼此之间又有一定关系性的成员构成，每个成员在集合中只能出现一次，不同于我们之前说的<a target="_blank" rel="noopener" href="https://www.jb51.net/article/167971.htm">字典</a>，<a target="_blank" rel="noopener" href="https://www.jb51.net/article/167962.htm">链表</a>之类的，它是一种包含了不同元素的数据结构(集合中的元素称为成员)，从其定义中我们可以看出它具有两个很重要的特征：首先，集合中的成员是无序的，其次，集合中的成员是不相同的，即集合中不存在相同的成员。</p>
<p><strong>集合的定义</strong></p>
<p>我们要实现一个集合，首先要对其一些定义做了解</p>
<ul>
<li>不包含任何成员的集合称为<strong>空集</strong>，包含一切可能成员的集合称为<strong>全集</strong>。</li>
<li>如果两个集合里的成员都完全相同，则称两个集合相等。</li>
<li>如果一个集合所有成员都包含于另一个集合，则前一集合称为后一集合的一个<strong>子集</strong>。</li>
</ul>
<p><strong>集合的操作</strong></p>
<p>通常来说，集合的基本操作有以下三种：</p>
<ul>
<li>并集：将两个集合中的成员进行合并，得到一个新的集合</li>
<li>交集：将两个集合中共同存在的成员组成的一个新的集合</li>
<li>补集：属于一个集合而不属于另一个集合的成员组成的新的集合</li>
</ul>
<p>注：集合通常是由一组无序的，不能重复的元素构成。</p>
<p>​ 1、和数学中的集合名词比较相似，但是数组中的集合范围更大一些，也允许集合中的元素重复</p>
<p>​ 2、在计算机中，集合通常表示的结构中元素是不允许重复的</p>
<p>集合是特殊的数组：</p>
<p>​ 1、特殊之处在于里面的元素没有顺序，也不能重复</p>
<p>​ 2、没有顺序意味着不能通过下标值进行访问，不能重复意味着相同的对象在集合中只会存在一份</p>
<img src="https://i.loli.net/2021/02/27/5lgpkNYFSyzKrXh.png" alt="image-20210121175253633" style="zoom: 67%;" />

<h3 id="js-集合实现"><a href="#js-集合实现" class="headerlink" title="js 集合实现"></a>js 集合实现</h3><pre class="line-numbers language-none"><code class="language-none">function Set(value) &#123;
  &#x2F;&#x2F;属性
  this.items &#x3D; &#123;&#125;
  &#x2F;&#x2F;方法
  &#x2F;&#x2F;add方法
  Set.prototype.add &#x3D; function (value) &#123;
      &#x2F;&#x2F;判断当前集合中是否已经包含了该元素
      if (this.has(value)) &#123;
        return false
      &#125;
      &#x2F;&#x2F;将元素添加到集合中
      this.items[value] &#x3D; value
    return true
  &#125;
  &#x2F;&#x2F;has方法
  Set.prototype.has &#x3D; function (value) &#123;
    &#x2F;&#x2F;hasOwnProperty() 方法会返回一个布尔值，指示对象自身属性中是否具有指定的属性（也就是，是否有指定的键）。
    return this.items.hasOwnProperty(value)
  &#125;
  &#x2F;&#x2F;remove方法
  Set.prototype.remove &#x3D; function (value) &#123;
    &#x2F;&#x2F; 1,判断该集合中是否包含该元素
    if (!this.has(value)) &#123;
      return false
    &#125;
    &#x2F;&#x2F; 2,将元素从属性中删除
    delete this.items[value]
    return true
  &#125;
  &#x2F;&#x2F;clear方法
  Set.prototype.clear &#x3D; function () &#123;
    this.items &#x3D; &#123;&#125;
    return true
  &#125;
  &#x2F;&#x2F;size方法
  Set.prototype.size &#x3D; function () &#123;
    return Object.keys(this.items).length
  &#125;
  &#x2F;&#x2F;获取集合中所有的值
  Set.prototype.values &#x3D; function () &#123;

    return Object.keys(this.items)
  &#125;
  &#x2F;&#x2F;集合间的操作
  &#x2F;&#x2F;并集:对于给定的两个集合,返回一个包含两个集合中所有元素的新集合
  Set.prototype.union &#x3D; function (otherSet)&#123;
    &#x2F;&#x2F;this:集合对象A
    &#x2F;&#x2F;otherSet:集合对象B
    &#x2F;&#x2F; 1,创建新的集合
    let unionSet &#x3D; new Set()
    &#x2F;&#x2F; 2,将A集合中所有的元素添加到新集合中
    let values &#x3D; this.values()
    for(var i &#x3D; 0; i &lt; values.length; i++)&#123;
      unionSet.add(values[i])
    &#125;
    &#x2F;&#x2F; 3,将B集合中所有的元素添加到新集合中
    values &#x3D; otherSet.values()
    for (var i &#x3D; 0; i &lt; values.length; i++) &#123;
      unionSet.add(values[i])
    &#125;
    return unionSet
  &#125;
  &#x2F;&#x2F;交集:对于给定的两个集合,返回一个包含两个集合中共有元素的新集合
  Set.prototype.intersection &#x3D; function (otherSet) &#123;
    &#x2F;&#x2F;this:集合对象A
    &#x2F;&#x2F;otherSet:集合对象B
    &#x2F;&#x2F; 1,创建新的集合
    let intersection &#x3D; new Set()
    &#x2F;&#x2F; 2,将A集合中所有的元素添加到新集合中
    let values &#x3D; this.values()
    for (var i &#x3D; 0; i &lt; values.length; i++) &#123;
      let item &#x3D; values[i]
      if(otherSet.has(item))&#123;
        intersection.add(item)
      &#125;
    &#125;
    return intersection
  &#125;
  &#x2F;&#x2F;差集:对于给定的两个集合,返回一个包含所有存在于第一个集合且不存在于第二个集合的元素的新集合
  Set.prototype.difference &#x3D; function (otherSet) &#123;
     &#x2F;&#x2F;this:集合对象A
    &#x2F;&#x2F;otherSet:集合对象B
    &#x2F;&#x2F; 1,创建新的集合
    let differenceSet &#x3D; new Set()
    &#x2F;&#x2F; 2,将A集合中所有的元素添加到新集合中
    let values &#x3D; this.values()
    for (var i &#x3D; 0; i &lt; values.length; i++) &#123;
      let item &#x3D; values[i]
      if (!otherSet.has(item)) &#123;
        differenceSet.add(item)
      &#125;
    &#125;
    return differenceSet
  &#125;
  &#x2F;&#x2F;子集:验证一个给定集合是否是另一个集合的子集
  Set.prototype.subset &#x3D; function (otherSet) &#123;
    &#x2F;&#x2F;this:集合对象A
    &#x2F;&#x2F;otherSet:集合对象B
    let values &#x3D; this.values()
    for (var i &#x3D; 0; i &lt; values.length; i++) &#123;
      let item &#x3D; values[i]
      if (!otherSet.has(item)) &#123;
        return false
      &#125;
    &#125;
    return true
  &#125;
  if (Array.isArray(value)) &#123;
    let index &#x3D; 0
    while (index &lt; value.length) &#123;
      this.add(value[index])
      index++
    &#125;
  &#125;
&#125;

&#x2F;&#x2F;测试Set类
&#x2F;&#x2F; 1,常见Set类对象
let set &#x3D; new Set([&#39;a&#39;,&#39;b&#39;])
let setB &#x3D; new Set([&#39;a&#39;,&#39;c&#39;,&#39;d&#39;])
console.log(set.add(111));
console.log(set.add(111));
console.log(set.add(222));
console.log(set.remove(111));
console.log(set.size());
console.log(set);
console.log(set.union(setB));
console.log(set.intersection(setB));
console.log(set.difference(setB));
console.log(setB.subset(new Set([&#39;a&#39;,&#39;c&#39;,&#39;d&#39;])));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="字典结构"><a href="#字典结构" class="headerlink" title="字典结构"></a>字典结构</h2><blockquote>
<p>字典是以[键，值]的形式来存储元素。字典也称作映射、符号表或关联数组。</p>
<p>集合、字典、散列表都可以存储不重复的数据。字典和我们上面实现的集合很像。</p>
<p>ES5 包含了一个 Map 类的实现，即我们所说的字典。</p>
</blockquote>
<p>代码实现：</p>
<pre class="line-numbers language-none"><code class="language-none">class Dictionary &#123;
  constructor() &#123;
    this.items &#x3D; &#123;&#125;
  &#125;
  &#x2F;&#x2F; 向字典中添加新元素。如果key已经存在，那么已存在的value会被indeed值覆盖
  set(key, value) &#123;
    this.items[key] &#x3D; value;
  &#125;
  &#x2F;&#x2F;通过键值作为参数查找特定的数值并返回。
  get(key) &#123;
    return this.items[key];
  &#125;
  &#x2F;&#x2F;通过使用键值作为参数来从字典中移除键值对应的数据值
  remove(key) &#123;
    delete this.items[key];
  &#125;
  &#x2F;&#x2F;将字典所包含的所有键名以数组形式返回
  keys() &#123;
    return Object.keys(this.items);
  &#125;
  &#x2F;&#x2F;将字典所包含的所有数值以数组形式返回
  values() &#123;
    &#x2F;&#x2F; es7 提供的 Object.values 方法
    &#x2F;&#x2F; return Object.values(this.items);

    &#x2F;&#x2F; 或者循环输出
    return Object.keys(this.items).reduce((previousValue, currentValue, currentIndex) &#x3D;&gt; &#123;
      previousValue.push(this.items[currentValue]);
      return previousValue;
    &#125;, [])
  &#125;
&#125;
&#x2F;&#x2F; 使用
let dictionary &#x3D; new Dictionary();
dictionary.set(&#39;Gandalf&#39;, &#39;gandalf@email.com&#39;)
dictionary.set(&#39;John&#39;, &#39;johnsnow@email.com&#39;)
dictionary.set(&#39;Tyrion&#39;, &#39;tyrion@email.com&#39;)
dictionary.remove(&#39;John&#39;)
console.log(dictionary.get(&#39;John&#39;));
console.log(dictionary.get(&#39;Gandalf&#39;));
console.log(dictionary)
console.log(dictionary.keys())
console.log(dictionary.values())
console.log(dictionary.items)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><blockquote>
<p><code>哈希表</code>（Hash T able/Hash Map，也叫散列表），是根据键（Key）而直接访问在<code>内存存储位置</code>的<code>数据结构</code>。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做<code>哈希函数</code>，<code>存放记录</code>的<code>数组</code>称做<code>哈希表</code>。</p>
</blockquote>
<p><strong>一.数组的缺点</strong></p>
<pre class="line-numbers language-none"><code class="language-none">1.数组进行插入操作时，效率比较低。
2.数组基于索引去查找的操作效率非常高，基于内容去查找效率很低。
3.数组进行删除操作，效率也不高。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><strong>二.哈希表</strong></p>
<p>1.几乎所有的编程语言都有直接或间接的应用这种数据结构</p>
<p>2.哈希表是基于 数组 实现的，但相对于数组有很多优势。</p>
<pre class="line-numbers language-none"><code class="language-none">1.它可以提供非常快速的 插入-删除-查找 操作
2.无论多少数据，插入和删除需要接近常量的时间。即O（1）的时间级
3.哈希表的速度比树还要快，基本可以瞬间找到想要的元素。
4.哈希表相对于树来说编码要容易<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.哈希表对于数组的一些不足</p>
<pre class="line-numbers language-none"><code class="language-none">1.哈希表中的数据是没有顺序的，所以不能以一种固定的方式来遍历其中的元素。
2.通常情况下，哈希表中的key是不允许重复的，不能放置相同的key，用于保存不同的元素。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>4.哈希表的实质</p>
<pre class="line-numbers language-none"><code class="language-none">1.哈希表不同于（数组和链表，甚至于树可以画出他的结构）。
2.他的结构就是数组，但他神奇的地方在于它对下标值的一种变换，这种变换称为 哈希函数 ， 通过哈希函数可以获取到 HashCode。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>5.哈希表的一些概念</p>
<pre class="line-numbers language-none"><code class="language-none">1.哈希化：将大数字转化为数组范围内下表的过程，我们称之为哈希化。（对大数字取余）
2.哈希函数：通常我们会将单词转化成大数字，大数字在进行哈希化的代码实现放在一个函数中，这个韩式称为哈希函数。
3.哈希表：最终的数据插入到的这个数组，对整个结构的封装，我们称之为是一个哈希表。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>6.解决 哈希化后的下标值冲突 方案</p>
<p>————————1. 链地址法—————————</p>
<p><img src="https://img-blog.csdnimg.cn/20200404122342926.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5ODEwMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>1）每个存储单元存放的不再是单个数据，而是一个链条。<br>2）链条的结构可以是，数组或者链表。<br>3）比如是链表，一旦哈希化的下标值发生重复。将重复的元素插入到链表的首端或者尾端即可。<br>4）查询的时候，先根据哈希化后的下标值找到相应的位置，再取出链表，依次查询寻找需要的数据<br>5）根据业务需要选择数组还是链表，需要插在链条的最前面，选择链表。<br>插在后端选择数组或者链表都可以。</p>
<p>————————2. 开放地址法—————————</p>
<p><img src="https://img-blog.csdnimg.cn/20200404123845995.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5ODEwMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>1）开放地址法的主要工作方式是 寻找空白的的单元格来添加重复的数据<br>2）寻找位置的方法有三种 线性探测 ， 二次探测， 再哈希化。</p>
<p>————-线性探测—————</p>
<pre class="line-numbers language-none"><code class="language-none">1. 下标值重复时，采取index+1向后寻找空白位置插入数据。
2. 查找数据时，先去用哈希化后的索引去取值比对，如果不符合，向下继续线性查找。
3. 查找数据时，当哈希化后的索引值上的数据不符合，如果在线性查找时遇到数组项空白时，则停止查找，此数组中不存在目标数据。
4. 删除某数组中存的数据时，不能把值设置为null，可以进行特殊处理（比如设置为-1) 。来防止下次线性查找失败。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>！！！！线性探索的问题：线性探测会产生聚集，即数据聚在在一连串的存储单元当中。影响之后的插入查询 删除 操作的效率，影响哈希表的性能。</p>
<p>————-二次探测—————</p>
<pre class="line-numbers language-none"><code class="language-none">1. 二次探测， 对步长进行了优化，index + 1 平方 ， + 2 平方， +3 平方，这样就可以一次探测比较长的距离，避免聚集带来的影响。
2. 可是还是会造成步长不一 的 一种聚集，还是会影响效率。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>————-再哈希化—————</p>
<pre class="line-numbers language-none"><code class="language-none">1.把关键字用另一个哈希函数再做一次哈希化，用这个哈希化 的 结果 作为步长，对于指定的关键字，步长在探索中是不变的，不同的关键字使用不同的步长。
2.需要和第一个哈希函数不同，不能输出为0.
3. stepszies（步长） &#x3D; constant（常数，小于数组容量） - （key % constant）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>结论： ——-链地址法，使哈希表性能下降较为稳定。——开发地址法，由于填充因子，步长等因素会使性能下降的急剧。</p>
<p><strong>哈希函数</strong></p>
<p><img src="https://i.loli.net/2021/02/27/xiCFyMAd89n4qzN.png" alt="image-20210208150444904" style="zoom:67%;" /><img src="https://i.loli.net/2021/02/27/kA7awjPhRQYx3tX.png" alt="image-20210208150738643" style="zoom: 80%;" /></p>
<img src="https://i.loli.net/2021/02/27/3NHWPUmhrfbKXly.png" alt="image-20210208150754449" style="zoom: 80%;" />

<img src="https://i.loli.net/2021/02/27/ReksFliDnWt5TPj.png" alt="image-20210208150944918" style="zoom:67%;" />

<p><strong>散列函数的构造方法</strong></p>
<p>好的散列函数要求：（1）计算简单，至少散列函数的计算时间不应该超过其他查找技术与关键字比较的时间；（2）计算出的散列地址分布均匀，这样可以保证存储空间的有效利用，并减少为处理冲突而耗费的时间。</p>
<p><strong>1.</strong> <strong>直接定址法</strong></p>
<p>取关键字或关键字的某个线性函数值为散列地址。即 H(key)=key 或 H(key) = a·key + b，其中 a 和 b 为常数（这种散列函数叫做自身函数）。</p>
<p><strong>2.</strong> <strong>数字分析法</strong></p>
<p>假设某公司的员工登记表以员工的手机号作为关键字。手机号一共 11 位。前 3 位是接入号，对应不同运营商的子品牌；中间 4 位表示归属地；最后 4 位是用户号。不同手机号前 7 位相同的可能性很大，所以可以选择后 4 位作为散列地址，或者对后 4 位反转（1234 -&gt; 4321）、循环右移（1234 -&gt; 4123）、循环左移等等之后作为散列地址。</p>
<p>数字分析法通常适合处理关键字位数比较大的情况，如果事先知道关键字的分布且关键字的若干位分布比较均匀，就可以考虑这个方法。</p>
<p><strong>3.</strong> <strong>平方取中法</strong></p>
<p>假设关键字是 1234、平方之后是 1522756、再抽取中间 3 位 227，用作散列地址。平方取中法比较适合于不知道关键字的分布，而位数又不是很大的情况。</p>
<p><strong>4.</strong> <strong>折叠法</strong></p>
<p>将关键字从左到右分割成位数相等的几部分，最后一部分位数不够时可以短些，然后将这几部分叠加求和，并按散列表表长，取后几位作为散列地址。</p>
<p>比如关键字是 9876543210，散列表表长是 3 位，将其分为四组，然后叠加求和：987 + 654 + 321 + 0 = 1962，取后 3 位 962 作为散列地址。</p>
<p>折叠法事先不需要知道关键字的分布，适合关键字位数较多的情况。</p>
<p><strong>5.</strong> <strong>除留余数法</strong></p>
<p>f(key) = key mod p (p≤m)，m 为散列表长。这种方法不仅可以对关键字直接取模，也可在折叠、平方取中后再取模。根据经验，若散列表表长为 m，通常 p 为小于或等于表长（最好接近 m）的最小质数，可以更好的减小冲突。</p>
<p>此方法为最常用的构造散列函数方法。</p>
<p><strong>6.</strong> <strong>随机数法</strong></p>
<p>f(key) = random(key)，这里 random 是随机函数。当关键字的长度不等时，采用这个方法构造散列函数是比较合适的。</p>
<p>实际应用中，应该视不同的情况采用不同的散列函数。如果关键字是英文字符、中文字符、各种各样的符号，都可以转换为某种数字来处理，比如其 unicode 编码。下面这些因素可以作为选取散列函数的参考：（1）计算散列地址所需的时间；（2）关键字长度；（3）散列表大小；（4）关键字的分布情况；（5）查找记录的频率。</p>
<p><strong>哈希表的基本实现：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">class HashTable &#123;
  constructor() &#123;
    this.storage &#x3D; []
    this.count &#x3D; 0
    this.limit &#x3D; 7
  &#125;
  &#x2F;&#x2F; 1、将字符串转成比较大的数字：hasCode
  &#x2F;&#x2F; 2、将大的数字hashCode压缩到数组范围（大小）之内
  &#x2F;&#x2F;! 哈希算法
  hashFunc (str, size) &#123;
    &#x2F;&#x2F;   &#x2F;&#x2F;1、定义hashCode变量
    var hashCode &#x3D; 0
    &#x2F;&#x2F; cats -&gt; Unicode编码
    &#x2F;&#x2F;! 普通模式
    &#x2F;&#x2F;   for(var i &#x3D; 0; i &lt; str.length; i++)&#123;
    &#x2F;&#x2F;     let j &#x3D; 1
    &#x2F;&#x2F;     let flag &#x3D; str.length -1 - i
    &#x2F;&#x2F;     while(flag)&#123;
    &#x2F;&#x2F;       console.log(&#39;flag:&#39;+flag);
    &#x2F;&#x2F;       j *&#x3D; 37
    &#x2F;&#x2F;       console.log(j);
    &#x2F;&#x2F;       flag--
    &#x2F;&#x2F;     &#125;
    &#x2F;&#x2F;     hashCode +&#x3D; str.charCodeAt(i) * j
    &#x2F;&#x2F;   &#125;
    &#x2F;&#x2F;   console.log(hashCode);
    &#x2F;&#x2F;! 2、使用霍纳算法，来计算hashCode的值
    &#x2F;&#x2F; for (var i &#x3D; 0; i &lt; str.length; i++) &#123;
    &#x2F;&#x2F;   hashCode &#x3D; 37 * hashCode + str.charCodeAt(i)
    &#x2F;&#x2F; &#125;
    &#x2F;&#x2F;! 3、自创的随机算法
    &#x2F;&#x2F; 通过split把字符串分割成单字符数组
    let numArray &#x3D; str.split(&#39;&#39;).map(char &#x3D;&gt; char.charCodeAt(0));
    &#x2F;&#x2F;将所有数组元素连成字符串，不能直接相加
    numArray &#x3D; numArray.join(&#39;&#39;)
    &#x2F;&#x2F; 变成随机数值
    hashCode &#x3D; Math.sin(numArray).toString().split(&#39;.&#39;)[1].slice(0, 10);
    &#x2F;&#x2F; 3、取余操作
    var index &#x3D; hashCode % size
    return index
  &#125;
  &#x2F;&#x2F;!添加元素
  put (key, value) &#123;
    &#x2F;&#x2F;1.根据key获取对应的index
    var index &#x3D; this.hashFunc(key, this.limit)
    &#x2F;&#x2F;2.根据index取得对应的bucket(bucket是key的hashCode对应下表位置，)
    var bucket &#x3D; this.storage[index]
    &#x2F;&#x2F;3.判断当前bucket是否为空
    if (bucket &#x3D;&#x3D; null) &#123;
      bucket &#x3D; []
      this.storage[index] &#x3D; bucket
    &#125;
    &#x2F;&#x2F;4.判断是否修改数据
    for (var i &#x3D; 0; i &lt; bucket.length; i++) &#123;
      var tuple &#x3D; bucket[i]
      if (tuple[0] &#x3D;&#x3D; key) &#123;
        tuple[1] &#x3D; value
        return
      &#125;
    &#125;
    &#x2F;&#x2F;5.当前bucket(链表)中没有该数据,就直接添加该数据
    bucket.push([key, value])
    this.count +&#x3D; 1
    &#x2F;&#x2F;数组扩容
    if (this.count &gt; this.limit * 0.75) &#123;
      this.resize(&#39;expand&#39;)
    &#125;
  &#125;
  &#x2F;&#x2F;!get获取元素
  get (key) &#123;
    &#x2F;**
    *1.根据key,获得index;
    * 2.根据index,获得bucket;
    * 3.判断bucket是否为null,为null就直接返回null
    * 4.bucket不为null，则遍历找到对应的key
    * 5.遍历完后，没有找到对应的key，就返回null
    **&#x2F;
    var index &#x3D; this.hashFunc(key, this.limit)
    var bucket &#x3D; this.storage[index]
    if (bucket &#x3D;&#x3D; null) &#123;
      return null
    &#125;
    for (var i &#x3D; 0; i &lt; bucket.length; i++) &#123;
      var tuple &#x3D; bucket[i]
      if (tuple[0] &#x3D;&#x3D; key) &#123;
        return tuple[1]
      &#125;
    &#125;
    &#x2F;&#x2F;在index对应的bucket（不为null）中没有找到对应的key
    return null

  &#125;
  &#x2F;&#x2F;!remove方法
  remove (key) &#123;
    var index &#x3D; this.hashFunc(key, this.limit)
    var bucket &#x3D; this.storage[index]
    if (bucket &#x3D;&#x3D; null) &#123;
      return null
    &#125;
    for (var i &#x3D; 0; i &lt; bucket.length; i++) &#123;
      var tuple &#x3D; bucket[i]
      if (tuple[0] &#x3D;&#x3D; key) &#123;
        bucket.splice(i, 1)&#x2F;&#x2F;删除当前位置的元素https:&#x2F;&#x2F;wangdoc.com&#x2F;javascript&#x2F;stdlib&#x2F;array.html#splice
        this.count--
        return tuple[1]
        &#x2F;&#x2F;缩小容量
        if (this.limit &gt; 7 &amp;&amp; this.count &lt; this.limit * 0.25) &#123;
          this.resize(&#39;narrow&#39;)
        &#125;
      &#125;
    &#125;
    return null
  &#125;
  &#x2F;&#x2F;!判断哈希表是否为空
  isEmpty () &#123;
    return this.count &#x3D;&#x3D; 0
  &#125;
  &#x2F;&#x2F;!获取哈希表的长度
  size () &#123;
    return this.count
  &#125;
  &#x2F;&#x2F;!哈希表的扩容
  resize (newLimit) &#123;
      console.log(this);
      &#x2F;&#x2F;! 1、获取哈希表新的数组大小限制
      getNewLimit.call(this)
      &#x2F;&#x2F;! 2、重新初始化哈希表
      var oldStorage &#x3D; init.call(this)
      &#x2F;&#x2F;! 3、把值转移到新的哈希表上
      moveHash.call(this, oldStorage)
    &#x2F;&#x2F; 获取哈希表新的limit
    function getNewLimit () &#123;
      if (newLimit &#x3D;&#x3D;&#x3D; &#39;expand&#39;) &#123;
        var newSize &#x3D; this.limit * 2
        var newPrime &#x3D; getPrime(newSize)
      &#125; else if (newLimit &#x3D;&#x3D;&#x3D; &#39;narrow&#39;) &#123;
        var newSize &#x3D; Math.floor(this.limit &#x2F; 2)
        var newPrime &#x3D; getPrime(newSize)
      &#125;
      this.limit &#x3D; newPrime
      &#x2F;&#x2F;*判断数字是否是质数
      function isPrime (num) &#123;
        &#x2F;&#x2F;1.获得num的平方根
        &#x2F;&#x2F;特点：智能被1和自己整除，不能被2到num-1数字整除
        &#x2F;&#x2F;*普通算法
        &#x2F;&#x2F; for(var i &#x3D; 2;i &lt; num;i++)&#123;
        &#x2F;&#x2F;   if (num % i &#x3D;&#x3D; 0) &#123;
        &#x2F;&#x2F;     return false
        &#x2F;&#x2F;   &#125;
        &#x2F;&#x2F; &#125;
        &#x2F;&#x2F;*优化算法
        var temp &#x3D; Math.ceil(Math.sqrt(num))
        for (var i &#x3D; 2; i &lt;&#x3D; temp; i++) &#123;
          if (num % i &#x3D;&#x3D;&#x3D; 0) &#123;
            return false
          &#125;
        &#125;
        return true
      &#125;
      &#x2F;&#x2F;*获取质数的方法
      function getPrime (num) &#123;
        while (!isPrime(num)) &#123;
          num++
        &#125;
        console.log(num);
        return num
      &#125;
    &#125;
    &#x2F;&#x2F;*初始化哈希表
    function init () &#123;
      console.log(this);
      var oldStorage &#x3D; this.storage
      this.storage &#x3D; []
      this.count &#x3D; 0
      var bucket &#x3D; []
      this.storage &#x3D; []
      this.count &#x3D; 0

      console.log(oldStorage);
      return oldStorage
    &#125;
    &#x2F;&#x2F;*转移哈希表
    function moveHash (oldStorage) &#123;
      var bucket &#x3D; []
      for (var i &#x3D; 0; i &lt; oldStorage.length; i++) &#123;
        bucket &#x3D; oldStorage[i]
        if (!bucket) &#123;
          continue
        &#125;
        for (var j &#x3D; 0; j &lt; bucket.length; j++) &#123;
          var tuple &#x3D; bucket[j]
          this.put(tuple[0], tuple[1])
        &#125;
      &#125;
    &#125;
  &#125;

&#125;
var hash &#x3D; new HashTable()

hash.put(&#39;abc&#39;, &#39;123&#39;)
hash.put(&#39;abd&#39;, &#39;456&#39;)
hash.put(&#39;cbd&#39;, &#39;789&#39;)
hash.put(&#39;a34c&#39;, &#39;123&#39;)
hash.put(&#39;a43bd&#39;, &#39;456&#39;)
hash.put(&#39;c434bd&#39;, &#39;789&#39;)
hash.put(&#39;ab434c&#39;, &#39;123&#39;)
hash.put(&#39;a434bd&#39;, &#39;456&#39;)
hash.put(&#39;c434bd&#39;, &#39;789&#39;)
hash.put(&#39;ab2434c&#39;, &#39;123&#39;)
hash.put(&#39;a434b3d&#39;, &#39;456&#39;)
hash.put(&#39;c21314bd&#39;, &#39;789&#39;)
hash.put(&#39;c212334bd&#39;, &#39;789&#39;)
hash.put(&#39;c2123314bd&#39;, &#39;789&#39;)
console.log(hash);
console.log(hash.get(&#39;ab2434c&#39;));

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>哈希表的扩容：</strong></p>
<img src="https://i.loli.net/2021/02/27/eagT1pLnc4iJIMX.png" alt="image-20210213160949118" style="zoom:67%;" />

<h2 id="树（tree"><a href="#树（tree" class="headerlink" title="树（tree)"></a>树（tree)</h2><blockquote>
<p>树结构是一种非线性存储结构，存储的是具有“一对多”关系的数据元素的集合 。</p>
<p>树是由结点或顶点和边组成的(可能是非线性的)且不存在着任何环的一种数据结构。没有结点的树称为空(null 或 empty)树。一棵非空的树包括一个根结点，还(很可能)有多个附加结点，所有结点构成一个多级分层结构。</p>
</blockquote>
<h3 id="一、树结构简介"><a href="#一、树结构简介" class="headerlink" title="一、树结构简介"></a>一、树结构简介</h3><h4 id="1-1-简单了解树结构"><a href="#1-1-简单了解树结构" class="headerlink" title="1.1.简单了解树结构"></a>1.1.简单了解树结构</h4><p><strong>什么是树？</strong></p>
<p>真实的树：</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/1.png" alt="image-20200229205530929"></p>
<p><strong>树的特点：</strong></p>
<ul>
<li>树一般都有一个<strong>根</strong>，连接着根的是<strong>树干</strong>；</li>
<li>树干会发生分叉，形成许多<strong>树枝</strong>，树枝会继续分化成更小的<strong>树枝</strong>；</li>
<li>树枝的最后是<strong>叶子</strong>；</li>
</ul>
<p>现实生活中很多结构都是树的抽象，模拟的树结构相当于旋转<code>180°</code>的树。</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/2.png" alt="image-20200229205630945"></p>
<p><strong>树结构对比于数组/链表/哈希表有哪些优势呢：</strong></p>
<p><strong>数组：</strong></p>
<ul>
<li>优点：可以通过<strong>下标值访问</strong>，效率高；</li>
<li>缺点：查找数据时需要先对数据进行<strong>排序</strong>，生成<strong>有序数组</strong>，才能提高查找效率；并且在插入和删除元素时，需要大量的<strong>位移操作</strong>；</li>
</ul>
<p><strong>链表：</strong></p>
<ul>
<li>优点：数据的插入和删除操作效率都很高；</li>
<li>缺点：<strong>查找</strong>效率低，需要从头开始依次查找，直到找到目标数据为止；当需要在链表中间位置插入或删除数据时，插入或删除的效率都不高。</li>
</ul>
<p><strong>哈希表：</strong></p>
<ul>
<li>优点：哈希表的插入/查询/删除效率都非常高；</li>
<li>缺点：<strong>空间利用率不高</strong>，底层使用的数组中很多单元没有被利用；并且哈希表中的元素是<strong>无序</strong>的，不能按照固定顺序遍历哈希表中的元素；而且不能快速找出哈希表中<strong>最大值或最小值</strong>这些特殊值。</li>
</ul>
<p><strong>树结构：</strong></p>
<p>优点：树结构综合了上述三种结构的优点，同时也弥补了它们存在的缺点（虽然效率不一定都比它们高），比如树结构中数据都是有序的，查找效率高；空间利用率高；并且可以快速获取最大值和最小值等。</p>
<p>总的来说：<strong>每种数据结构都有自己特定的应用场景</strong></p>
<p><strong>树结构：</strong></p>
<ul>
<li><strong>树（Tree）</strong>:由 n（n ≥ 0）个节点构成的<strong>有限集合</strong>。当 n = 0 时，称为<strong>空树</strong>。</li>
</ul>
<p>对于任一棵非空树（n &gt; 0），它具备以下性质：</p>
<ul>
<li>数中有一个称为<strong>根（Root）</strong>的特殊节点，用 **r **表示；</li>
<li>其余节点可分为 m（m &gt; 0）个互不相交的有限集合 T1，T2，…，Tm，其中每个集合本身又是一棵树，称为原来树的<strong>子树（SubTree）</strong>。</li>
</ul>
<p><strong>树的常用术语：</strong></p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/3.png" alt="image-20200229221126468"></p>
<ul>
<li><strong>节点的度（Degree）</strong>：节点的<strong>子树个数</strong>，比如节点 B 的度为 2；</li>
<li><strong>树的度</strong>：树的所有节点中<strong>最大的度数</strong>，如上图树的度为 2；</li>
<li><strong>叶节点（Leaf）</strong>：<strong>度为 0 的节点</strong>（也称为叶子节点），如上图的 H，I 等；</li>
<li><strong>父节点（Parent）</strong>：度不为 0 的节点称为父节点，如上图节点 B 是节点 D 和 E 的父节点；</li>
<li><strong>子节点（Child）</strong>：若 B 是 D 的父节点，那么 D 就是 B 的子节点；</li>
<li><strong>兄弟节点（Sibling）</strong>：具有同一父节点的各节点彼此是兄弟节点，比如上图的 B 和 C，D 和 E 互为兄弟节点；</li>
<li><strong>路径和路径长度</strong>：路径指的是一个节点到另一节点的通道，路径所包含边的个数称为路径长度，比如 A-&gt;H 的路径长度为 3；</li>
<li><strong>节点的层次（Level）</strong>：规定<strong>根节点在 1 层</strong>，其他任一节点的层数是其父节点的<strong>层数加 1</strong>。如 B 和 C 节点的层次为 2；</li>
<li><strong>树的深度（Depth）</strong>：树种所有节点中的<strong>最大层次</strong>是这棵树的深度，如上图树的深度为 4；</li>
</ul>
<h4 id="1-2-树结构的表示方式"><a href="#1-2-树结构的表示方式" class="headerlink" title="1.2.树结构的表示方式"></a>1.2.树结构的表示方式</h4><ul>
<li><strong>最普通的表示方法</strong>：</li>
</ul>
<img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/4.png" alt="image-20200229230417613" style="zoom:80%;" />

<p>如图，树结构的组成方式类似于链表，都是由一个个节点连接构成。不过，根据每个父节点子节点数量的不同，每一个父节点需要的引用数量也不同。比如节点 A 需要 3 个引用，分别指向子节点 B，C，D；B 节点需要 2 个引用，分别指向子节点 E 和 F；K 节点由于没有子节点，所以不需要引用。</p>
<p>这种方法缺点在于我们无法确定某一结点的引用数。</p>
<ul>
<li><strong>儿子-兄弟表示法</strong>：</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/5.png" alt="image-20200229232805477"></p>
<p>这种表示方法可以完整地记录每个节点的数据，比如：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;节点A
Node&#123;
  &#x2F;&#x2F;存储数据
  this.data &#x3D; data
  &#x2F;&#x2F;统一只记录左边的子节点
  this.leftChild &#x3D; B
  &#x2F;&#x2F;统一只记录右边的第一个兄弟节点
  this.rightSibling &#x3D; null
&#125;

&#x2F;&#x2F;节点B
Node&#123;
  this.data &#x3D; data
  this.leftChild &#x3D; E
  this.rightSibling &#x3D; C
&#125;

&#x2F;&#x2F;节点F
Node&#123;
  this.data &#x3D; data
  this.leftChild &#x3D; null
  this.rightSibling &#x3D; null
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这种表示法的优点在于每一个节点中引用的数量都是确定的。</p>
<ul>
<li><strong>儿子-兄弟表示法旋转</strong></li>
</ul>
<p>以下为儿子-兄弟表示法组成的树结构：</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/6.png" alt="image-20200229234549049"></p>
<p>将其顺时针旋转 45° 之后：</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/7.png" alt="image-20200229235549522"></p>
<p>这样就成为了一棵<strong>二叉树</strong>，由此我们可以得出结论：<strong>任何树都可以通过二叉树进行模拟</strong>。但是这样父节点不是变了吗？其实，父节点的设置只是为了方便指向子节点，在代码实现中谁是父节点并没有关系，只要能正确找到对应节点即可。</p>
<h3 id="二、二叉树"><a href="#二、二叉树" class="headerlink" title="二、二叉树"></a>二、二叉树</h3><h4 id="2-1-二叉树简介"><a href="#2-1-二叉树简介" class="headerlink" title="2.1.二叉树简介"></a>2.1.二叉树简介</h4><p><strong>二叉树的概念</strong>：如果树中的每一个节点最多只能由<strong>两个子节点</strong>，这样的树就称为<strong>二叉树</strong>；</p>
<p>二叉树十分重要，不仅仅是因为简单，更是因为几乎所有的树都可以表示成二叉树形式。</p>
<p><strong>二叉树的组成</strong>：</p>
<ul>
<li>二叉树可以为空，也就是没有节点；</li>
<li>若二叉树不为空，则它由根节点和称为其左子树 TL 和右子树 TR 的两个不相交的二叉树组成；</li>
</ul>
<p><strong>二叉树的五种形态</strong>：</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/8.png" alt="image-20200301001718079"></p>
<p>上图分别表示：空的二叉树、只有一个节点的二叉树、只有左子树 TL 的二叉树、只有右子树 TR 的二叉树和有左右两个子树的二叉树。</p>
<p><strong>二叉树的特性</strong>：</p>
<ul>
<li>一个二叉树的第 i 层的最大节点数为：2^(i-1)，i &gt;= 1；</li>
<li>深度为 k 的二叉树的最大节点总数为：2^k - 1 ，k &gt;= 1；</li>
<li>对任何非空二叉树，若 n0 表示叶子节点的个数，n2 表示度为 2 的非叶子节点个数，那么两者满足关系：n0 = n2 + 1；如下图所示：H，E，I，J，G 为叶子节点，总数为 5；A，B，C，F 为度为 2 的非叶子节点，总数为 4；满足 n0 = n2 + 1 的规律。</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/9.png" alt="image-20200301092140211"></p>
<p><strong>完美二叉树</strong></p>
<p>完美二叉树（Perfect Binary Tree）也称为满二叉树（Full Binary Tree），在二叉树中，除了最下一层的叶子节点外，每层节点都有 2 个子节点，这就构成了完美二叉树。</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/10.png" alt="image-20200301093237681"></p>
<p><strong>完全二叉树</strong></p>
<p>完全二叉树（Complete Binary Tree）:</p>
<ul>
<li>除了二叉树最后一层外，其他各层的节点数都达到了最大值；</li>
<li>并且，最后一层的叶子节点从左向右是连续存在，只缺失右侧若干叶子节点；</li>
<li>完美二叉树是特殊的完全二叉树；</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/11.png" alt="image-20200301093659373"></p>
<p>在上图中，由于 H 缺失了右子节点，所以它不是完全二叉树。</p>
<h4 id="2-3-二叉树的数据存储"><a href="#2-3-二叉树的数据存储" class="headerlink" title="2.3.二叉树的数据存储"></a>2.3.二叉树的数据存储</h4><p>常见的二叉树存储方式为<strong>数组</strong>和<strong>链表</strong>：</p>
<p><strong>使用数组：</strong></p>
<ul>
<li><strong>完全二叉树</strong>：按从上到下，从左到右的方式存储数据。</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/12.png" alt="image-20200301094919588"></p>
<table>
<thead>
<tr>
<th>节点</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>G</th>
<th>H</th>
</tr>
</thead>
<tbody><tr>
<td><strong>序号</strong></td>
<td><strong>1</strong></td>
<td><strong>2</strong></td>
<td><strong>3</strong></td>
<td><strong>4</strong></td>
<td><strong>5</strong></td>
<td><strong>6</strong></td>
<td><strong>7</strong></td>
<td><strong>8</strong></td>
</tr>
</tbody></table>
<p>使用数组存储时，取数据的时候也十分方便：左子节点的序号等于父节点序号 _ 2，右子节点的序号等于父节点序号 _ 2 + 1 。</p>
<ul>
<li><strong>非完全二叉树</strong>：非完全二叉树需要转换成完全二叉树才能按照上面的方案存储，这样会浪费很大的存储空间。</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/13.png" alt="image-20200301100043636"></p>
<table>
<thead>
<tr>
<th>节点</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>^</th>
<th>^</th>
<th>F</th>
<th>^</th>
<th>^</th>
<th>^</th>
<th>^</th>
<th>^</th>
<th>^</th>
<th>M</th>
</tr>
</thead>
<tbody><tr>
<td><strong>序号</strong></td>
<td><strong>1</strong></td>
<td><strong>2</strong></td>
<td><strong>3</strong></td>
<td><strong>4</strong></td>
<td><strong>5</strong></td>
<td><strong>6</strong></td>
<td><strong>7</strong></td>
<td><strong>8</strong></td>
<td><strong>9</strong></td>
<td><strong>10</strong></td>
<td><strong>11</strong></td>
<td><strong>12</strong></td>
<td><strong>13</strong></td>
</tr>
</tbody></table>
<p><strong>使用链表</strong></p>
<p>二叉树最常见的存储方式为<strong>链表</strong>：每一个节点封装成一个 Node，Node 中包含存储的数据、左节点的引用和右节点的引用。</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/14.png" alt="image-20200301100616105"></p>
<h3 id="三、二叉搜索树"><a href="#三、二叉搜索树" class="headerlink" title="三、二叉搜索树"></a>三、二叉搜索树</h3><h4 id="认识二叉搜索树"><a href="#认识二叉搜索树" class="headerlink" title="认识二叉搜索树"></a>认识二叉搜索树</h4><p><strong>二叉搜索树</strong>（<strong>BST</strong>，Binary Search Tree），也称为<strong>二叉排序树</strong>和<strong>二叉查找树</strong>。</p>
<p>二叉搜索树是一棵二叉树，可以为空；</p>
<p>如果不为空，则满足以下<strong>性质</strong>：</p>
<ul>
<li>条件 1：非空左子树的<strong>所有</strong>键值<strong>小于</strong>其根节点的键值。比如三中节点 6 的所有非空左子树的键值都小于 6；</li>
<li>条件 2：非空右子树的<strong>所有</strong>键值<strong>大于</strong>其根节点的键值；比如三中节点 6 的所有非空右子树的键值都大于 6；</li>
<li>条件 3：左、右子树本身也都是二叉搜索树；</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/15.png" alt="image-20200301103139916"></p>
<p>如上图所示，树二和树三符合 3 个条件属于二叉树，树一不满足条件 3 所以不是二叉树。</p>
<p><strong>总结：</strong>二叉搜索树的特点主要是<strong>较小的值</strong>总是保存在<strong>左节点</strong>上，相对<strong>较大的值</strong>总是保存在<strong>右节点</strong>上。这种特点使得二叉搜索树的查询效率非常高，这也就是二叉搜索树中”搜索”的来源。</p>
<h4 id="二叉搜索树应用举例"><a href="#二叉搜索树应用举例" class="headerlink" title="二叉搜索树应用举例"></a>二叉搜索树应用举例</h4><p>下面是一个二叉搜索树：</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/16.png" alt="image-20200301111718686"></p>
<p>若想在其中查找数据 10，只需要查找 4 次，查找效率非常高。</p>
<ul>
<li>第 1 次：将 10 与根节点 9 进行比较，由于 10 &gt; 9，所以 10 下一步与根节点 9 的右子节点 13 比较；</li>
<li>第 2 次：由于 10 &lt; 13，所以 10 下一步与父节点 13 的左子节点 11 比较；</li>
<li>第 3 次：由于 10 &lt; 11，所以 10 下一步与父节点 11 的左子节点 10 比较；</li>
<li>第 4 次：由于 10 = 10，最终查找到数据 10 。</li>
</ul>
<img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/17.png" alt="image-20200301111751041" style="zoom:80%;" />

<p>同样是 15 个数据，在排序好的数组中查询数据 10，需要查询 10 次：</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/18.png" alt="image-20200301115348138"></p>
<p>其实：如果是排序好的数组，可以通过二分查找：第一次找 9，第二次找 13，第三次找 15…。我们发现如果把每次二分的数据拿出来以树的形式表示的话就是<strong>二叉搜索树</strong>。这就是数组二分法查找效率之所以高的原因。</p>
<h4 id="二叉搜索树的实现"><a href="#二叉搜索树的实现" class="headerlink" title="二叉搜索树的实现"></a>二叉搜索树的实现</h4><p><img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227182900.png" alt="image-20210214212225358"></p>
<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227182903.png" alt="image-20210214222239631" style="zoom:67%;" />

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227182909.png" alt="image-20210214222327176" style="zoom:67%;" />

<p><img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227182911.png" alt="image-20210214231854466" style="zoom: 80%;" />!(C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20210215002229224.png)</p>
<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227182913.png" alt="image-20210215032041388" style="zoom:67%;" />

<p>//前中后序遍历属于深度优先遍历</p>
<p>//而层序遍历则属于广度优先遍历</p>
<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227182918.png" alt="image-20210215002601824" style="zoom:67%;" />

<p><img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227182920.png" alt="image-20210215002223399" style="zoom:67%;" /><img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227182922.png" alt="image-20210215030506361" style="zoom:67%;" /></p>
<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227182924.png" alt="image-20210215120744477" style="zoom:67%;" />

<p>删除总结：</p>
<p>1、<strong>删除的节点是叶子节点的话，就直接让其父节点的指向它的引用为 null 就行</strong></p>
<p>2、<strong>删除的节点含有左子树或者右子树，用其子树来代替成为被删除节点的父节点的子树</strong></p>
<p>3、<strong>删除左右都有孩子的节点，找到右边子树最小的节点作为父节点</strong></p>
<p>代码实现：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;封装二叉搜索树
function BinarySearchTree () &#123;
     function Node (key) &#123;
     this.key &#x3D; key
     this.left &#x3D; null
     this.right &#x3D; null
     &#125;

     &#x2F;&#x2F; 属性
     this.root &#x3D; null

     &#x2F;&#x2F;方法
     &#x2F;&#x2F; 插入数据： 对外给用户调用的方法
     BinarySearchTree.prototype.insert &#x3D; function (key) &#123;
     &#x2F;&#x2F;1、根据key值创建节点
     var newNode &#x3D; new Node(key)

     &#x2F;&#x2F; 2、判断根节点是否有值
     if (this.root &#x3D;&#x3D;&#x3D; null) &#123;
     this.root &#x3D; newNode
     &#125; else &#123;
     this.insertNode(this.root, newNode)
     &#125;
     &#125;

     BinarySearchTree.prototype.insertNode &#x3D; function (node, newNode) &#123;
     if (newNode.key &lt; node.key) &#123;
     &#x2F;&#x2F;向左查找
     if (node.left &#x3D;&#x3D;&#x3D; null) &#123;
     node.left &#x3D; newNode
     &#125; else &#123;
     this.insertNode(node.left, newNode)
     &#125;
     &#125; else &#123;
     &#x2F;&#x2F;向右查找
     if (node.right &#x3D;&#x3D;&#x3D; null) &#123;
     node.right &#x3D; newNode
     &#125; else &#123;
     this.insertNode(node.right, newNode)
     &#125;
     &#125;
     &#125;

     &#x2F;&#x2F;树的遍历
     &#x2F;&#x2F;! 1、先序遍历 --- 根-&gt;左-&gt;右
     BinarySearchTree.prototype.preOrderTraversal &#x3D; function () &#123;
     var str &#x3D; &#39;&#39;
     function handler (key) &#123;
     str +&#x3D; key + &#39; &#39;
     &#125;
     this.preOrderTraversalNode(this.root, handler)
     console.log(str);
     &#125;
     BinarySearchTree.prototype.preOrderTraversalNode &#x3D; function (node, handler) &#123;
     if (node !&#x3D;&#x3D; null) &#123;
     &#x2F;&#x2F; 1、处理经过的节点
     handler(node.key)
     &#x2F;&#x2F; 2、处理经过节点的左子节点
     this.preOrderTraversalNode(node.left, handler)
     &#x2F;&#x2F; 3、处理经过节点的右子节点
     this.preOrderTraversalNode(node.right, handler)
     &#125;
     &#125;
     &#x2F;&#x2F;! 2、中序遍历 --- 左-&gt;根-&gt;右
     BinarySearchTree.prototype.midOrderTraversal &#x3D; function () &#123;
     var str &#x3D; &#39;&#39;
     function handler (key) &#123;
     str +&#x3D; key + &#39; &#39;
     &#125;
     this.midOrderTraversalNode(this.root, handler)
     console.log(str);
     &#125;
     BinarySearchTree.prototype.midOrderTraversalNode &#x3D; function (node, handler) &#123;
     if (node !&#x3D;&#x3D; null) &#123;
     &#x2F;&#x2F; 1、处理经过节点的左子节点
     this.midOrderTraversalNode(node.left, handler)
     &#x2F;&#x2F; 2、处理经过的节点
     handler(node.key)
     &#x2F;&#x2F; 3、处理经过节点的右子节点
     this.midOrderTraversalNode(node.right, handler)
     &#125;
     &#125;
     &#x2F;&#x2F;! 3、后序遍历 --- 左-&gt;右-&gt;根
     BinarySearchTree.prototype.postOrderTraversal &#x3D; function () &#123;
     var str &#x3D; &#39;&#39;
     function handler (key) &#123;
     str +&#x3D; key + &#39; &#39;
     &#125;
     this.postOrderTraversalNode(this.root, handler)
     console.log(str);
     &#125;
     BinarySearchTree.prototype.postOrderTraversalNode &#x3D; function (node, handler) &#123;
     if (node !&#x3D;&#x3D; null) &#123;
     &#x2F;&#x2F; 1、处理经过节点的左子节点
     this.postOrderTraversalNode(node.left, handler)
     &#x2F;&#x2F; 2、处理经过节点的右子节点
     this.postOrderTraversalNode(node.right, handler)
     &#x2F;&#x2F; 3、处理经过的节点
     handler(node.key)
     &#125;
     &#125;
     &#x2F;&#x2F;!获取最小值
     BinarySearchTree.prototype.min &#x3D; function () &#123;
     var node &#x3D; this.root
     while (node.left !&#x3D;&#x3D; null) &#123;
     node &#x3D; node.left
     &#125;
     return node.key
     &#125;
     &#x2F;&#x2F;!获取最大值
     BinarySearchTree.prototype.max &#x3D; function () &#123;
     var node &#x3D; this.root
     while (node.right !&#x3D;&#x3D; null) &#123;
     node &#x3D; node.right
     &#125;
     return node.key
     &#125;
     &#x2F;&#x2F;!搜索特定的值
     BinarySearchTree.prototype.search &#x3D; function (key) &#123;
     return this.searchNode(this.root, key)
     &#125;
     BinarySearchTree.prototype.searchNode &#x3D; function (node, key) &#123;
     &#x2F;&#x2F; 1、如果传入的node为null，那么就退出递归
     if (node &#x3D;&#x3D;&#x3D; null) &#123;
     return false
     &#125;

     &#x2F;&#x2F;2、判断node节点值和传入的key大小
     if (node.key &gt; key) &#123;
     return this.searchNode(node.left, key)
     &#125; else if (node.key &lt; key) &#123;
     return this.searchNode(node.right, key)
     &#125; else &#123;
     return true
     &#125;
     &#125;
     &#x2F;&#x2F;!删除节点
     BinarySearchTree.prototype.remove &#x3D; function (key) &#123;
     &#x2F;&#x2F; 1、寻找要删除的节点
     &#x2F;&#x2F; 1、1定义变量，保存一些信息
     var current &#x3D; this.root
     var parent &#x3D; this.root
     var isLeftChild &#x3D; true
     &#x2F;&#x2F;1、2 开始寻找删除的节点
     while (current.key !&#x3D;&#x3D; key) &#123;
     if (key &lt; current.key) &#123;
     isLeftChild &#x3D; true
     parent &#x3D; current
     current &#x3D; current.left
     &#125; else &#123;
     isLeftChild &#x3D; false
     parent &#x3D; current
     current &#x3D; current.right
     &#125;

     &#x2F;&#x2F;某种情况：已经找到了最后的节点，依然没有找到 &#x3D;&#x3D; key
     if (current &#x3D;&#x3D;&#x3D; null) &#123;
     return false
     &#125;
     &#125;
     console.log(current);
     &#x2F;&#x2F;2、根据对应的情况删除节点
     &#x2F;&#x2F;2、1删除的节点是叶子节点（没有子节点）
     if (current.left &#x3D;&#x3D;&#x3D; null &amp;&amp; current.right &#x3D;&#x3D; null) &#123;
     if (current &#x3D;&#x3D;&#x3D; this.root) &#123;
     this.root &#x3D; null
     &#125; else if (isLeftChild) &#123;
     parent.left &#x3D; null
     &#125; else &#123;
     console.log(&#39;ok&#39;);

     parent.right &#x3D; null
     &#125;
     &#125;
     &#x2F;&#x2F; 2、2.删除的节点有一个子节点
     else if (current.right &#x3D;&#x3D;&#x3D; null) &#123;
     if (current &#x3D;&#x3D;&#x3D; this.root) &#123;
     this.root &#x3D; current.left
     &#125;
     else if (isLeftChild) &#123;
     parent.left &#x3D; current.left
     &#125; else &#123;
     parent.right &#x3D; current.left
     &#125;
     &#125;
     else if (current.left &#x3D;&#x3D;&#x3D; null) &#123;
     if (current &#x3D;&#x3D;&#x3D; this.root) &#123;
     this.root &#x3D; current.right
     &#125;
     else if (isLeftChild) &#123;
     parent.left &#x3D; current.right
     &#125; else &#123;
     parent.right &#x3D; current.right
     &#125;
     &#125;
     &#x2F;&#x2F;2.3.删除的节点有两边子节点
     else &#123;
     &#x2F;&#x2F;1、获取后继节点
     var successor &#x3D; this.getSuccssor(current)

     &#x2F;&#x2F;2、判断是否根节点
     if (current &#x3D;&#x3D;&#x3D; this.root) &#123;
     this.root &#x3D; successor
     &#125; else if (isLeftChild) &#123;
     parent.left &#x3D; successor
     &#125; else &#123;
     parent.right &#x3D; successor
     &#125;

     &#x2F;&#x2F;3、将删除节点的左子树  &#x3D; current.left
     successor.left &#x3D; current.left
     &#125;
     &#125;
     &#x2F;&#x2F;找后继的方法
     BinarySearchTree.prototype.getSuccssor &#x3D; function (delNode) &#123;
     &#x2F;&#x2F; 1、定义变量，保存找到的后推
     var successor &#x3D; delNode
     var current &#x3D; delNode.right
     var successorParent &#x3D; delNode

     &#x2F;&#x2F; 2、循环查找
     while (current !&#x3D;&#x3D; null) &#123;
     successorParent &#x3D; successor
     successor &#x3D; current
     current &#x3D; current.left
     &#125;

     &#x2F;&#x2F; 3、判断寻找的后继节点是否直接就是delNode的right节点
     if (successor !&#x3D;&#x3D; delNode.right) &#123;
     successorParent.left &#x3D; successor.right
     successor.right &#x3D; delNode.right
     &#125;
     return successor
     &#125;
&#125;

&#x2F;&#x2F;测试代码
var bst &#x3D; new BinarySearchTree()
bst.insert(11)
bst.insert(1)
bst.insert(14)
bst.insert(6)
bst.insert(131)
bst.insert(171)
bst.insert(8)
bst.insert(9)
bst.insert(2)
console.log(bst);

bst.preOrderTraversal()
bst.midOrderTraversal()
bst.postOrderTraversal()
console.log(bst.min());
console.log(bst.max());
console.log(bst.search(111));

&#x2F;&#x2F;测试删除代码
bst.remove(6)
console.log(bst);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="二叉搜索树的缺陷"><a href="#二叉搜索树的缺陷" class="headerlink" title="二叉搜索树的缺陷"></a>二叉搜索树的缺陷</h4><img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227182930.png" alt="image-20210217003627441" style="zoom: 50%;" />

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227182932.png" alt="image-20210217004018720" style="zoom: 67%;" />

<h2 id="图结构"><a href="#图结构" class="headerlink" title="图结构"></a>图结构</h2><h3 id="图简介"><a href="#图简介" class="headerlink" title="图简介"></a>图简介</h3><p>图看起来就像下图这样：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4064751-9ef7887aca675269.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/526/format/webp" alt="img"></p>
<p>在计算机科学中，一个图就是一些<em>顶点</em>的集合，这些顶点通过一系列<em>边</em>结对（连接）。顶点用圆圈表示，边就是这些圆圈之间的连线。顶点之间通过边连接。</p>
<p><strong>注意：</strong>顶点有时也称为节点或者交点，边有时也称为链接。</p>
<p>一个图可以表示一个社交网络，每一个人就是一个顶点，互相认识的人之间通过边联系。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4064751-98d670ae394f3695.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/651/format/webp" alt="img"></p>
<p>图有各种形状和大小。边可以有<em>权重（weight）</em>，即每一条边会被分配一个正数或者负数值。考虑一个代表航线的图。各个城市就是顶点，航线就是边。那么边的权重可以是飞行时间，或者机票价格。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4064751-7d75da02d729e64c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/824/format/webp" alt="img"></p>
<p>有了这样一张假设的航线图。从旧金山到莫斯科最便宜的路线是到纽约转机。</p>
<p>边可以是<em>有方向的</em>。在上面提到的例子中，边是没有方向的。例如，如果 Ada 认识 Charles，那么 Charles 也就认识 Ada。相反，有方向的边意味着是单方面的关系。一条从顶点 X 到 顶点 Y 的边是将 X 联向 Y，不是将 Y 联向 X。</p>
<p>继续前面航班的例子，从旧金山到阿拉斯加的朱诺有向边意味着从旧金山到朱诺有航班，但是从朱诺到旧金山没有（我假设那样意味着你需要走回去）。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4064751-c9ece5586fa955f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/824/format/webp" alt="img"></p>
<p>下面的两种情况也是属于图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4064751-0f7469ff0be704de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/485/format/webp" alt="img"></p>
<p>左边的是树，右边的是链表。他们都可以被当成是树，只不过是一种更简单的形式。他们都有顶点（节点）和边（连接）。</p>
<p>第一种图包含<em>圈（cycles）</em>，即你可以从一个顶点出发，沿着一条路劲最终会回到最初的顶点。树是不包含圈的图。</p>
<p>另一种常见的图类型是单向图或者 DAG：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4064751-af16c3d5a506e610.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/634/format/webp" alt="img"></p>
<p>就像树一样，这个图没有任何圈（无论你从哪一个节点出发，你都无法回到最初的节点），但是这个图有有向边（通过一个箭头表示，这里的箭头不表示继承关系）。</p>
<h3 id="为什么要使用图？"><a href="#为什么要使用图？" class="headerlink" title="为什么要使用图？"></a>为什么要使用图？</h3><p>也许你耸耸肩然后心里想着，有什么大不了的。好吧，事实证明图是一种有用的数据结构。</p>
<p>如果你有一个编程问题可以通过顶点和边表示出来，那么你就可以将你的问题用图画出来，然后使用著名的图算法（比如广度优先搜索 或者 深度优先搜索）来找到解决方案。</p>
<p>例如，假设你有一系列任务需要完成，但是有的任务必须等待其他任务完成后才可以开始。你可以通过非循环有向图来建立模型：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4064751-afa3948a9e805a67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/457/format/webp" alt="img"></p>
<p>每一个顶点代表一个任务。两个任务之间的边表示目的任务必须等到源任务完成后才可以开始。比如，在任务 B 和任务 D 都完成之前，任务 C 不可以开始。在任务 A 完成之前，任务 A 和 D 都不能开始。</p>
<p>现在这个问题就通过图描述清楚了，你可以使用深度优先搜索算法来执行执行拓扑排序。这样就可以将所有的任务排入最优的执行顺序，保证等待任务完成的时间最小化。（这里可能的顺序之一是：A, B, D, E, C, F, G, H, I, J, K）</p>
<p>不管是什么时候遇到困难的编程问题，问一问自己：“如何用图来表述这个问题？”。图都是用于表示数据之间的关系。 诀窍在于如何定义“关系”。</p>
<p>程序员常用的另一个图就是状态机，这里的边描述了状态之间切换的条件。下面这个状态机描述了一个猫的状态：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4064751-8f5334960c871d0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500/format/webp" alt="img"></p>
<p>图真的很棒。Facebook 就从他们的社交图中赚取了巨额财富。如果计划学习任何数据结构，则应该选择图，以及大量的标准图算法。</p>
<h3 id="顶点的表示"><a href="#顶点的表示" class="headerlink" title="顶点的表示"></a>顶点的表示</h3><p><strong>图的一些概念</strong></p>
<ul>
<li><strong>顶点的度</strong> - 指与该顶点相关联的边的条数。</li>
<li><strong>路径</strong> - 从一个顶点到另一个顶点的路径，存在 0 个或多个。<ul>
<li>简单路径：简单路径要求不包含重复的顶点</li>
<li>回路：第一个顶点和最后一个顶点相同的路径称为回路</li>
</ul>
</li>
<li><strong>权</strong> - 路径上附属携带了数据信息。</li>
<li><strong>连通图</strong>指任意两个顶点之间存在关系边；</li>
<li><strong>无向图</strong>：图的边是没有方向的</li>
<li><strong>有向图</strong>：图的边是由方向的</li>
<li><strong>带权图</strong>：带权图的边有一定的权重</li>
</ul>
<p>理论上，图就是一堆顶点和边对象而已，但是怎么在代码中来描述呢？</p>
<p>有两种主要的方法：邻接矩阵和邻接列表。</p>
<p><strong>邻接矩阵：</strong>在邻接矩阵实现中，由行和列都表示顶点，由两个顶点所决定的矩阵对应元素表示这里两个顶点是否相连、如果相连这个值表示的是相连边的权重。例如，如果从顶点 A 到顶点 B 有一条权重为 5.6 的边，那么矩阵中第 A 行第 B 列的位置的元素值应该是 5.6：</p>
<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227182940.png" alt="image-20210217213702542" style="zoom: 50%;" />

<p>往这个图中添加顶点的成本非常昂贵，因为新的矩阵结果必须重新按照新的行/列创建，然后将已有的数据复制到新的矩阵中。</p>
<p>在 <em>稀疏</em>图的情况下，每一个顶点都只会和少数几个顶点相连，这种情况下相邻列表是最佳选择。如果这个图比较<em>密集</em>，每一个顶点都和大多数其他顶点相连，那么相邻矩阵更合适。</p>
<p><strong>邻接列表</strong>：在邻接列表实现中，每一个顶点会存储一个从它这里开始的边的列表。比如，如果顶点 A 有一条边到 B、C 和 D，那么 A 的列表中会有 3 条边</p>
<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227182947.png" alt="image-20210217214143571" style="zoom: 67%;" />

<p>所以使用哪一个呢？<code>大多数时候，选择邻接列表是正确的</code>。下面是两种实现方法更详细的比较。</p>
<p>假设 <em>V</em> 表示图中顶点的个数，<em>E</em> 表示边的个数。</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>邻接列表</th>
<th>邻接矩阵</th>
</tr>
</thead>
<tbody><tr>
<td>存储空间</td>
<td>O(V + E)</td>
<td>O(V^2)</td>
</tr>
<tr>
<td>添加顶点</td>
<td>O(1)</td>
<td>O(V^2)</td>
</tr>
<tr>
<td>添加边</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>检查相邻性</td>
<td>O(V)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<p>“检查相邻性” 是指对于给定的顶点，尝试确定它是否是另一个顶点的邻居。在邻接列表中检查相邻性的时间复杂度是*<em>O(V)**，因为最坏的情况是一个顶点与</em>每一个*顶点都相连。</p>
<p>在 <em>稀疏</em>图的情况下，每一个顶点都只会和少数几个顶点相连，这种情况下相邻列表是最佳选择。如果这个图比较<em>密集</em>，每一个顶点都和大多数其他顶点相连，那么相邻矩阵更合适。</p>
<h3 id="图的实现"><a href="#图的实现" class="headerlink" title="图的实现"></a>图的实现</h3><img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227182951.png" alt="image-20210217214656033" style="zoom:67%;" />

<p>我们希望从图中某一顶点出发访遍图中其余顶点，且是每一个顶点仅被访问一次，这个过程就叫做图的遍历</p>
<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227182955.png" alt="image-20210218001329867" style="zoom:50%;" />

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227183000.png" alt="image-20210218003559608" style="zoom: 67%;" />

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227183008.png" alt="image-20210218015619367" style="zoom:67%;" />

<h1 id="算法（algorithm）"><a href="#算法（algorithm）" class="headerlink" title="算法（algorithm）"></a>算法（algorithm）</h1><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>Algorithm 这个单词本意就是解决问题的办法/步骤逻辑</p>
<p>算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。</p>
</blockquote>
<p><img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227183014.png" alt="image-20210115122327003"></p>
<h3 id="算法的基本特性"><a href="#算法的基本特性" class="headerlink" title="算法的基本特性"></a>算法的基本特性</h3><blockquote>
<p>算法具有五个基本特性：输入、输出、有穷性、确定性和可行性</p>
</blockquote>
<h3 id="算法设计的要求"><a href="#算法设计的要求" class="headerlink" title="算法设计的要求"></a>算法设计的要求</h3><blockquote>
<p>算法设计的要求：正确性、可读性、健壮性、时间效率高和储存量低</p>
</blockquote>
<p>正确性：算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案。</p>
<p>可读性：算法设计的另一目的是为了便于阅读、理解和交流。</p>
<p>健壮性：当输入数据不合法是，算法也能够做出相关的处理，而不是产生异常或莫名其妙的结果。</p>
<p>时间效率：时间效率指的是算法的执行时间，对于同一个问题，如果有多个算法能够解决，执行效率短的算法效率高，执行时间长的效率低。</p>
<p>储存量低：储存量需求指的是算法在执行过程中需要的最大储存空间，主要指算法程序运行时所占的内存或外部硬盘储存空间。</p>
<h3 id="算法的度量"><a href="#算法的度量" class="headerlink" title="算法的度量"></a>算法的度量</h3><blockquote>
<p>算法的度量方法：事后统计方法（不科学、不准确）、事前分析估算方法</p>
<p>事前分析估算方法<code>主要利用算法的时间复杂度和算法的空间复杂度的对比</code></p>
</blockquote>
<h4 id="算法时间复杂度"><a href="#算法时间复杂度" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h4><blockquote>
<p>在进行算法分析时，语句总的执行次数 T(n)是关于问题规模 n 的函数，进而分析 T(n)随 n 的变化情况并确定 T(n)的数量级。</p>
<p>算法的时间复杂度，也就是算法的时间度量，记住：T(n) = O(f(n))。它表示随问题规模 n 的增大，算法执行时间的增长率和 f(n)的增长率相同，</p>
<p>称作算法的渐进时间复杂度，简称为时间复杂度。其中 f(n)是问题规模 n 的某个函数。</p>
</blockquote>
<p>这样用大写 O( )来体现算法时间复杂度的记法，我们称之为大 O 记法。</p>
<p>一般情况下，随着 n 的增大，T(n)增长最慢的算法为最优算法。</p>
<p><strong>推导大 O 阶方法</strong></p>
<p>​ 1、用常数 1 取代运行时间中的所有加法常数。</p>
<p>​ 2、在修改后的运行次数函数中，只保留最高阶项。</p>
<p>​ 3、如果最高阶项存在且不是 1，则去除与这个项目相乘的常数。得到的结果就是大 O 阶。</p>
<p><strong>推导示例</strong></p>
<p><strong>1、常数阶</strong></p>
<p>首先顺序结构的时间复杂度。下面这个算法，是利用高斯定理计算 1，2，……n 个数的和。</p>
<pre class="line-numbers language-none"><code class="language-none">int sum &#x3D; 0, n &#x3D; 100; &#x2F;*执行一次*&#x2F;

sum &#x3D; (1 + n) * n &#x2F; 2; &#x2F;*执行一次*&#x2F;

printf(&quot;%d&quot;,sum); &#x2F;*执行一次*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个算法的运行次数函数是 f (n) =3。 根据我们推导大 0 阶的方法，第一步就是把常数项 3 改为 1。在保留最高阶项时发现，它根本没有最高阶项，所以这个算法的时间复杂度为*<em>0(1)**。<br>另外，我们试想一下，如果这个算法当中的语句 sum = (1+n)\</em>n/2; 有 10 句，则与示例给出的代码就是 3 次和 12 次的差异。<code>这种与问题的大小无关（n的多少），执行时间恒定的算法，我们称之为具有O(1)的时间复杂度，又叫常数阶。</code>对于分支结构而言，无论是真，还是假，执行的次数都是恒定的，不会随着 n 的变大而发生变化，所以单纯的分支结构(不包含在循环结构中)，其时间复杂度也是 0(1)。</p>
<p><strong>2、线性阶</strong></p>
<p>线性阶的循环结构会复杂很多。要确定某个算法的阶次，我们常常需要确定某个特定语句或某个语句集运行的次数。因此，我们要分析算法的复杂度，关键就是要分析循环结构的运行情况。</p>
<p>下面这段代码，它的循环的时间复杂度为**O(n)**， 因为循环体中的代码须要执行 n 次。</p>
<pre class="line-numbers language-none"><code class="language-none">int i;

for(i &#x3D; 0; i &lt; n; i++)&#123;

&#x2F;*时间复杂度为O(1)的程序步骤序列*&#x2F;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>3、对数阶</strong></p>
<p>如下代码：</p>
<pre class="line-numbers language-none"><code class="language-none">int count &#x3D; 1;

while (count &lt; n)&#123;

count &#x3D; count * 2;

 &#x2F;*时间复杂度为O(1)的程序步骤序列*&#x2F;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于每次 count 乘以 2 之后，就距离 n 更近了一分。 也就是说，有多少个 2 相乘后大于 n，则会退出循环。 由 2^x=n 得到 x=logn。 所以这个循环的时间复杂度为**O(logn)**。</p>
<p><strong>4、平方阶</strong></p>
<p>下面例子是一个循环嵌套，它的内循环刚才我们已经分析过，时间复杂度为 O(n)。</p>
<pre class="line-numbers language-none"><code class="language-none"> int i, j;

 for(i &#x3D; 0; i &lt; n; i++)&#123;

 　　for(j &#x3D; 0; j &lt; n; j++)&#123;

 &#x2F;*时间复杂度为O(1)的程序步骤序列*&#x2F;

 　　&#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>而对于外层的循环，不过是内部这个时间复杂度为 O(n)的语句，再循环 n 次。 所以这段代码的时间复杂度为 O(n^2)。</p>
<p>如果外循环的循环次数改为了 m，时间复杂度就变为 O(mXn)。</p>
<p>所以我们可以总结得出，循环的时间复杂度等于循环体的复杂度乘以该循环运行的次数。<br>那么下面这个循环嵌套，它的时间复杂度是多少呢?</p>
<pre class="line-numbers language-none"><code class="language-none"> int i, j;

 for(i &#x3D; 0; i &lt; n; i++)&#123;

 　　for(j &#x3D; i; j &lt; n; j++)&#123; &#x2F;*注意j &#x3D; i而不是0*&#x2F;

 　　&#x2F;*时间复杂度为O(1)的程序步骤序列*&#x2F;

 　　&#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于当 i=0 时，内循环执行了 n 次，当 i = 1 时，执行了 n-1 次，……当 i=n-1 时，执行了 1 次。所以总的执行次数为:</p>
<p><img src="https://img-blog.csdn.net/20170327144317062" alt="img"></p>
<p>用我们推导大 O 阶的方法，第一条，没有加法常数不予考虑；第二条，只保留最高阶项，因此保留时(n^2)/2; 第三条，去除这个项相乘的常数，也就是去除 1/2，最终这段代码的时间复杂度为 O(n2)。</p>
<p>从这个例子，我们也可以得到一个经验，其实理解大 0 推导不算难，难的是<strong>对数列的一些相关运算，这更多的是考察你的数学知识和能力。</strong></p>
<p><code>注：判读一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项（最高阶项）的阶数</code></p>
<p><strong>常见的时间复杂度</strong></p>
<p>常见的时问复杂度如表所示。<br><img src="https://img-blog.csdn.net/20170327162904721" alt="img"><br>常用的时间复杂度所耗费的时间从小到大依次是：<br><img src="https://img-blog.csdn.net/20170327162956884" alt="img"><br>我们前面已经谈到了。O(1)常数阶、O(logn)对数阶、O(n)线性阶、 O(n^2)平方阶等，像 O(n^3)，过大的 n 都会使得结果变得不现实。同样指数阶 O(2^n)和阶乘阶 O(n!)等除非是很小的 n 值，否则哪怕 n 只是 100，都是噩梦般的运行时间。所以这种<a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=%E4%B8%8D%E5%88%87%E5%AE%9E%E9%99%85&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd">不切实际</a>的算法时间复杂度，一般我们都不去讨论。</p>
<p><strong>最坏情况与平均情况</strong></p>
<p>我们查找一个有 n 个随机数字数组中的某个数字，最好的情况是第一个数字就是，那么算法的时间复杂度为 O(1)，但也有可能这个数字就在最后一个位置上待着，那么算法的时间复杂度就是 O(n)，这是最坏的一种情况了。<br><code>最坏情况运行时间是一种保证，那就是运行时间将不会再坏了。 在应用中，这是一种最重要的需求， 通常， 除非特别指定， 我们提到的运行时间都是最坏情况的运行时间。</code><br>而平均运行时间也就是从概率的角度看， 这个数字在每一个位置的可能性是相同的，所以平均的查找时间为 n/2 次后发现这个目标元素。<code>平均运行时间是所有情况中最有意义的，因为它是期望的运行时间。</code>也就是说，我们运行一段程序代码时，是希望看到平均运行时间的。可现实中，平均运行时间很难通过分析得到，一般都是通过运行一定数量的实验数据后估算出来的。<code>一般在没有特殊说明的情况下，都是指最坏时间复杂度。</code></p>
<h4 id="算法空间复杂度"><a href="#算法空间复杂度" class="headerlink" title="算法空间复杂度"></a>算法空间复杂度</h4><p>我们在写代码时，完全可以用空间来换取时间，比如说，要判断某某年是不是<a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=%E9%97%B0%E5%B9%B4&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd">闰年</a>，你可能会花一点心思写了一个算法，而且由于是一个算法，也就意味着，每次给一个年份，都是要通过计算得到是否是闰年的结果。 还有另一个办法就是，事先建立一个有 2050 个元素的数组(年数略比现实多一点)，然后把所有的年份按下标的数字对应，如果是闰年，此数组项的值就是 1，如果不是值为 0。这样，所谓的判断某一年是否是闰年，就变成了查找这个数组的某一项的值是多少的问题。此时，我们的运算是最小化了，但是硬盘上或者内存中需要存储这 2050 个 0 和 1。这是通过一笔空间上的开销来换取计算时间的小技巧。到底哪一个好，其实要看你用在什么地方。<br><strong>算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作:S(n)= O(f(n))，其中，n 为问题的规模，f(n)为语句关于 n 所占存储空间的函数。</strong><br>一般情况下，一个程序在机器上执行时，除了需要存储程序本身的指令、常数、变量和输入数据外，还需要存储对数据操作的存储单元，若输入数据所占空间只取决于问题本身，和算法无关，这样只需要分析该算法在实现时所需的辅助单元即可。<code>若算法执行时所需的辅助空间相对于输入数据量而言是个常数，则称此算法为原地工作，空间复杂度为0(1)。</code><br>通常， 我们都使用”时间复杂度”来指运行时间的需求，使用”空间复杂度”指空间需求。当不用限定词地使用”复杂度’时，通常都是指时间复杂度。</p>
<p><strong>一些计算的规则</strong></p>
<p>1、加法规则</p>
<p>T(n,m) = T1(n) + T2(m) = O(max{f(n), g(m)})</p>
<p>2、乘法规则</p>
<p>T(n,m) = T1(n) * T2(m) = O(max{f(n)*g(m)})</p>
<p>3、一个经验</p>
<p>复杂度与时间效率的关系：<br>c(常数) &lt; logn &lt; n &lt; n*logn &lt; n^2 &lt; n^3 &lt; 2^n &lt; 3^n &lt; n!<br>l——————————l————————–l————–l<br>较好 一般 较差</p>
<p><strong>常用算法的时间复杂度和空间复杂度</strong></p>
<p><img src="https://img-blog.csdn.net/20170327164357916" alt="img"></p>
<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><p>0、排序算法说明</p>
<ul>
<li><p>0.1 排序的定义<br>对一序列对象根据某个关键字进行排序。</p>
</li>
<li><p>0.2 术语说明</p>
<ul>
<li><strong>稳定</strong> ：如果 a 原本在 b 前面，而 a=b，排序之后 a 仍然在 b 的前面；</li>
<li><strong>不稳定</strong> ：如果 a 原本在 b 的前面，而 a=b，排序之后 a 可能会出现在 b 的后面；不稳定排序记忆口诀：<strong>快</strong>（快排）<strong>些</strong>（希尔）<strong>选</strong>（选择）<strong>一堆</strong>（堆排）</li>
<li><strong>内排序</strong> ：所有排序操作都在内存中完成；</li>
<li><strong>外排序</strong> ：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</li>
<li><strong>时间复杂度</strong> ： 一个算法执行所耗费的时间。</li>
<li><strong>空间复杂度</strong> ：运行完一个程序所需内存的大小。</li>
</ul>
</li>
<li><p>0.3 算法总结</p>
</li>
<li><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMzMwNDMxNjgtMTg2NzgxNzg2OS5wbmc?x-oss-process=image/format,png" alt="image" style="zoom:67%;" />
</li>
<li><p>图片名词解释：</p>
<ul>
<li>n: 数据规模</li>
<li>k: “桶”的个数</li>
<li>In-place: 占用常数内存，不占用额外内存</li>
<li>Out-place: 占用额外内存</li>
</ul>
</li>
<li><p>0.5 算法分类</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMzMyMjA2MzctMTA1NTA4ODExOC5wbmc?x-oss-process=image/format,png" alt="image"></p>
</li>
<li><p>0.6 比较和非比较的区别</p>
<p>常见的<strong>快速排序、归并排序、堆排序、冒泡排序</strong> 等属于<strong>比较排序</strong> 。在排序的最终结果里，元素之间的次序依赖于它们之间的比较。每个数都必须和其他数进行比较，才能确定自己的位置 。</p>
<p>在冒泡排序之类的排序中，问题规模为 n，又因为需要比较 n 次，所以平均时间复杂度为 O(n²)。在归并排序、快速排序之类的排序中，问题规模通过分治法消减为 logN 次，所以时间复杂度平均 O(nlogn)。</p>
<p>比较排序的优势是，适用于各种规模的数据，也不在乎数据的分布，都能进行排序。可以说，比较排序适用于一切需要排序的情况。</p>
<p><strong>计数排序、基数排序、桶排序</strong>则属于<strong>非比较排序</strong> 。非比较排序是通过确定每个元素之前，应该有多少个元素来排序。针对数组 arr，计算 arr[i]之前有多少个元素，则唯一确定了 arr[i]在排序后数组中的位置 。</p>
<p>非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度 O(n)。</p>
<p>非比较排序时间复杂度底，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。</p>
</li>
</ul>
<h3 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h3><p><strong>冒泡排序</strong> 是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>
<p>1.3 代码实现</p>
<ul>
<li><p>1.1 算法描述</p>
<ul>
<li>步骤 1: 比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li>
<li>步骤 2: 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li>
<li>步骤 3: 针对所有的元素重复以上的步骤，除了最后一个；</li>
<li>步骤 4: 重复步骤 1~3，直到排序完成。</li>
</ul>
</li>
<li><p>1.2 动图演示</p>
</li>
<li><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMjMyMzg0NDktMjE0NjE2OTE5Ny5naWY" alt="image"></p>
</li>
<li><pre><code>function bubbleSort(array) &#123;
  for (let i = array.length - 1; i &gt;= 0 ; i--)&#123;
  //反向循环，因此次数越来越少
   //根据j的次数，比较到j位置,因为每次最后面的数都是最大的，所以不需要再交换了
    for (let j = 0; j &lt; i; j++) &#123;
      if(array[j] &gt; array[j+1])&#123;
        let temp = array[j]
        array[j] = array[j+1]
        array[j+1] = temp
      &#125;
    &#125;
  &#125;
&#125;
let arr = [2,5,1,10,0,100,12,1]
console.log(arr);
bubbleSort(arr)
console.log(arr);
<pre class="line-numbers language-none"><code class="language-none">
  &gt; 1.4 算法分析
  &gt;
  &gt; - 最佳情况：T(n) &#x3D; O(n)
  &gt; - 最差情况：T(n) &#x3D; O(n^2)
  &gt; - 平均情况：T(n) &#x3D; O(n^2)

### 选择排序（Selection Sort）

**选择排序** 是表现最稳定的排序算法之一 ，**因为无论什么数据进去都是 O(n^2)的时间复杂度** ，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。

**选择排序(Selection-sort)** 是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

2.3 代码实现

- 2.1 算法描述

  n 个记录的直接选择排序可经过 n-1 趟直接选择排序得到有序结果。具体算法描述如下：

  - 步骤 1：初始状态：无序区为 R[1…n]，有序区为空；
  - 步骤 2：第 i 趟排序(i&#x3D;1,2,3…n-1)开始时，当前有序区和无序区分别为 R[1…i-1]和 R(i…n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第 1 个记录 R 交换，使 R[1…i]和 R[i+1…n)分别变为记录个数增加 1 个的新有序区和记录个数减少 1 个的新无序区；
  - 步骤 3：n-1 趟结束，数组有序化了。
  - &lt;img src&#x3D;&quot;https:&#x2F;&#x2F;gitee.com&#x2F;gitopenchina&#x2F;typora-image&#x2F;raw&#x2F;master&#x2F;img&#x2F;20210227183028.png&quot; alt&#x3D;&quot;image-20210218131631217&quot; style&#x3D;&quot;zoom: 67%;&quot; &#x2F;&gt;

- 2.2 动图演示

- ![image](https:&#x2F;&#x2F;imgconvert.csdnimg.cn&#x2F;aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMjQ3MTk1OTAtMTQzMzIxOTgyNC5naWY)

- &#96;&#96;&#96;
  &#x2F;&#x2F;根本思想就是使用标记找到最小的数，放到数组前面
  function selectionSort (array) &#123;
    &#x2F;&#x2F;1、获取数组的长度
    var length &#x3D; array.length
    for (let j &#x3D; 0; j &lt; length; j++) &#123;
      var min &#x3D; j
      for (let i &#x3D; min + 1; i &lt; length; i++) &#123;
        if (array[min] &gt; array[i]) &#123;
          min &#x3D; i
        &#125;
      &#125;
      let temp &#x3D; array[min]
      array[min] &#x3D; array[j]
      array[j] &#x3D; temp

    &#125;
  &#125;
  let arr &#x3D; [2, 5, 1, 10, 0, 100, 12, 1]
  console.log(arr);
  selectionSort(arr)
  console.log(arr)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
&gt; - 2.4 算法分析
&gt; - 最佳情况：T(n) = O(n^2)
&gt; - 最差情况：T(n) = O(n^2)
&gt; - 平均情况：T(n) = O(n^2)
</code></pre>
</li>
</ul>
<h3 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h3><p><strong>插入排序（Insertion-Sort）</strong> 的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用 in-place 排序（即只需用到 O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>
<ul>
<li><p>3.1 算法描述</p>
<p>一般来说，插入排序都采用 in-place 在数组上实现。具体算法描述如下：</p>
<p>1.默认从 i = 1 开始判断，这样 preIndex 自然是内部循环的游标；</p>
<p>2.current 保存 arr[i]，通过循环来确定 current 的最终位置；</p>
<p>3.每个内循环开始的时候，arr[i] === current === arr[preIndex + 1]，所以在内循环首次时 arr[preIndex + 1] = arr[preIndex] 的时候不必担心 arr[i] 的值 丢失；</p>
<p>4.总体思路是，需要排位的元素先额外缓存起来，然后套用内循环，使得需要调整的元素赋值给它后面的一个位置上，形成依次挪位，最后因为内循环在判断条 件不生效的时候停止意味着找到了需要排位的元素的正确位置，然后赋值上去，完成排序。</p>
</li>
<li><p>3.2 动图演示</p>
</li>
<li><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMjU2NDUyNzctMTE1MTEwMDAwMC5naWY" alt="image"></p>
</li>
<li><p>3.3 代码实现</p>
</li>
<li><pre><code>function insertSort (array) &#123;
let len = arr.length;
  let preIndex, current;
  for (let i = 1; i &lt; len; i++) &#123;
    preIndex = i - 1;
    current = arr[i];
    while (preIndex &gt;= 0 &amp;&amp; current &lt; arr[preIndex]) &#123;
      arr[preIndex + 1] = arr[preIndex];
      preIndex--;
    &#125;
    arr[preIndex + 1] = current;
  &#125;
  return arr;
&#125;
let arr = [2, 5, 1, 10, 0, 100, 12, 1, 111, 6, 1, 76, 23, 18, 0]
console.log(arr);
insertSort(arr)
console.log(arr);
<pre class="line-numbers language-none"><code class="language-none">
- 3.4 算法分析

- 最佳情况：T(n) &#x3D; O(n)

- 最坏情况：T(n) &#x3D; O(n2)

- 平均情况：T(n) &#x3D; O(n2)

### 希尔排序（Shell Sort）

**希尔排序是希尔（Donald Shell）** 于 1959 年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破 O(n2）的第一批算法之一。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。

希尔排序是把记录按下表的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至 1 时，整个文件恰被分成一组，算法便终止。

- 4.1 算法描述

  我们来看下希尔排序的基本步骤，在此我们选择增量 gap&#x3D;length&#x2F;2，缩小增量继续以 gap &#x3D; gap&#x2F;2 的方式，这种增量选择我们可以用一个序列来表示，&#123;n&#x2F;2,(n&#x2F;2)&#x2F;2…1&#125;，称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。

  先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：

  - 步骤 1：选择一个增量序列 t1，t2，…，tk，其中 ti&gt;tj，tk&#x3D;1；
  - 步骤 2：按增量序列个数 k，对序列进行 k 趟排序；
  - 步骤 3：每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。

- 4.2 过程演示

  &lt;img src&#x3D;&quot;https:&#x2F;&#x2F;imgconvert.csdnimg.cn&#x2F;aHR0cHM6Ly9pbWFnZXMyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTE5MjY5OS8yMDE4MDMvMTE5MjY5OS0yMDE4MDMxOTA5NDExNjA0MC0xNjM4NzY2MjcxLnBuZw?x-oss-process&#x3D;image&#x2F;format,png&quot; alt&#x3D;&quot;image&quot; style&#x3D;&quot;zoom: 67%;&quot; &#x2F;&gt;

- 4.3 代码实现
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
function shellSort (arr) &#123;
  let len = arr.length;
  // gap 即为增量
  for (let gap = Math.floor(len / 2); gap &gt; 0; gap = Math.floor(gap / 2)) &#123;
    for (let i = gap; i &lt; len; i++) &#123;
      let j = i;
      let current = arr[i];
      while (j - gap &gt;= 0 &amp;&amp; current &lt; arr[j - gap]) &#123;
        arr[j] = arr[j - gap];
        j = j - gap;
      &#125;
      arr[j] = current;
    &#125;
  &#125;
&#125;

var arr = [3, 5, 7, 1, 4, 56, 12, 78, 25, 0, 9, 8, 42, 37];
shellSort(arr)
console.log(arr);
<pre class="line-numbers language-none"><code class="language-none">
  4.4 算法分析

- 最佳情况：T(n) &#x3D; O(nlog2 n)

- 最坏情况：T(n) &#x3D; O(nlog2 n)

- 平均情况：T(n) &#x3D;O(nlog2n)

### 快速排序（Quick Sort）

**快速排序** 的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。

- 6.1 算法描述

  快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：

  - 步骤 1：从数列中挑出一个元素，称为 “基准”（**pivot** ）；
  - 步骤 2：重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
  - 步骤 3：递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。

- 6.2 动图演示

- ![image](https:&#x2F;&#x2F;imgconvert.csdnimg.cn&#x2F;aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMzA5MzYzNzEtMTQxMzUyMzQxMi5naWY)

- 6.3 代码实现

- &#96;&#96;&#96;
  function quickSort (arr) &#123;
    &#x2F;&#x2F;当array中小于等于一项，则不用处理
    if (arr.length &lt;&#x3D; 1) &#123;
      return arr;
    &#125;
    let pivotIndex &#x3D; Math.floor(arr.length &#x2F; 2);
    let pivot &#x3D; arr.splice(pivotIndex, 1)[0];
    let left &#x3D; [];
    let right &#x3D; [];
    for (let i &#x3D; 0; i &lt; arr.length; i++) &#123;
      if (arr[i] &lt; pivot) &#123;
        left.push(arr[i]);
      &#125; else &#123;
        right.push(arr[i]);
      &#125;
    &#125;
    return quickSort(left).concat([pivot], quickSort(right));
  &#125;
  let arr &#x3D; [3, 9, 5, 4, 10, 19, 17, 22, 5];
  console.log(quickSort(arr));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
&gt; 6.4 算法分析
&gt;
&gt; 最佳情况：T(n) = O(nlogn)
&gt;
&gt; 最差情况：T(n) = O(n2)
&gt;
&gt; 平均情况：T(n) = O(nlogn)
</code></pre>
</li>
</ul>
<blockquote>
<h2 id="5、归并排序（Merge-Sort）"><a href="#5、归并排序（Merge-Sort）" class="headerlink" title="5、归并排序（Merge Sort）"></a>5、归并排序（Merge Sort）</h2><p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(n log n）的时间复杂度。代价是需要额外的内存空间。</p>
<p><strong>归并排序</strong> 是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为 2-路归并。</p>
<ul>
<li><p>5.1 算法描述</p>
<ul>
<li>步骤 1：把长度为 n 的输入序列分成两个长度为 n/2 的子序列；</li>
<li>步骤 2：对这两个子序列分别采用归并排序；</li>
<li>步骤 3：将两个排序好的子序列合并成一个最终的排序序列。</li>
</ul>
</li>
<li><p>5.2 动图演示</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMzA1NTcwNDMtMzczNzUwMTAuZ2lm" alt="image"></p>
</li>
<li><p>5.3 代码实现</p>
</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;**



     * 归并排序



     *



     * @param array



     * @return



     *&#x2F;



    public static int[] MergeSort(int[] array) &#123;



        if (array.length &lt; 2) return array;



        int mid &#x3D; array.length &#x2F; 2;



        int[] left &#x3D; Arrays.copyOfRange(array, 0, mid);



        int[] right &#x3D; Arrays.copyOfRange(array, mid, array.length);



        return merge(MergeSort(left), MergeSort(right));



    &#125;



    &#x2F;**



     * 归并排序——将两段排序好的数组结合成一个排序数组



     *



     * @param left



     * @param right



     * @return



     *&#x2F;



    public static int[] merge(int[] left, int[] right) &#123;



        int[] result &#x3D; new int[left.length + right.length];



        for (int index &#x3D; 0, i &#x3D; 0, j &#x3D; 0; index &lt; result.length; index++) &#123;



            if (i &gt;&#x3D; left.length)



                result[index] &#x3D; right[j++];



            else if (j &gt;&#x3D; right.length)



                result[index] &#x3D; left[i++];



            else if (left[i] &gt; right[j])



                result[index] &#x3D; right[j++];



            else



                result[index] &#x3D; left[i++];



        &#125;



        return result;



    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>5.4 算法分析</p>
<ul>
<li>最佳情况：T(n) = O(n)</li>
<li>最差情况：T(n) = O(nlogn)</li>
<li>平均情况：T(n) = O(nlogn)</li>
</ul>
</blockquote>
<blockquote>
<h2 id="7、堆排序（Heap-Sort）"><a href="#7、堆排序（Heap-Sort）" class="headerlink" title="7、堆排序（Heap Sort）"></a>7、堆排序（Heap Sort）</h2><p><strong>堆排序（Heapsort）</strong> 是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>
<ul>
<li><p>7.1 算法描述</p>
<ul>
<li>步骤 1：将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li>
<li>步骤 2：将堆顶元素 R[1]与最后一个元素 R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足 R[1,2…n-1]&lt;=R[n]；</li>
<li>步骤 3：由于交换后新的堆顶 R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将 R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为 n-1，则整个排序过程完成。</li>
</ul>
</li>
<li><p>7.2 动图演示</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMzEzMDg2OTktMzU2MTM0MjM3LmdpZg" alt="image"></p>
</li>
<li><p>7.3 代码实现</p>
<p>注意：这里用到了完全二叉树的部分性质：详情见数据结构二叉树知识点</p>
</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;声明全局变量，用于记录数组array的长度；



    static int len;



    &#x2F;**



     * 堆排序算法



     *



     * @param array



     * @return



     *&#x2F;



    public static int[] HeapSort(int[] array) &#123;



        len &#x3D; array.length;



        if (len &lt; 1) return array;



        &#x2F;&#x2F;1.构建一个最大堆



        buildMaxHeap(array);



        &#x2F;&#x2F;2.循环将堆首位（最大值）与末位交换，然后在重新调整最大堆



        while (len &gt; 0) &#123;



            swap(array, 0, len - 1);



            len--;



            adjustHeap(array, 0);



        &#125;



        return array;



    &#125;



    &#x2F;**



     * 建立最大堆



     *



     * @param array



     *&#x2F;



    public static void buildMaxHeap(int[] array) &#123;



        &#x2F;&#x2F;从最后一个非叶子节点开始向上构造最大堆



        &#x2F;&#x2F;for循环这样写会更好一点：i的左子树和右子树分别2i+1和2(i+1)



        for (int i &#x3D; (len&#x2F;2- 1); i &gt;&#x3D; 0; i--) &#123;



            adjustHeap(array, i);



        &#125;



    &#125;



    &#x2F;**



     * 调整使之成为最大堆



     *



     * @param array



     * @param i



     *&#x2F;



    public static void adjustHeap(int[] array, int i) &#123;



        int maxIndex &#x3D; i;



        &#x2F;&#x2F;如果有左子树，且左子树大于父节点，则将最大指针指向左子树



        if (i * 2 &lt; len &amp;&amp; array[i * 2] &gt; array[maxIndex])



            maxIndex &#x3D; i * 2 + 1;



        &#x2F;&#x2F;如果有右子树，且右子树大于父节点，则将最大指针指向右子树



        if (i * 2 + 1 &lt; len &amp;&amp; array[i * 2 + 1] &gt; array[maxIndex])



            maxIndex &#x3D; i * 2 + 2;



        &#x2F;&#x2F;如果父节点不是最大值，则将父节点与最大值交换，并且递归调整与父节点交换的位置。



        if (maxIndex !&#x3D; i) &#123;



            swap(array, maxIndex, i);



            adjustHeap(array, maxIndex);



        &#125;



    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>7.4 算法分析</p>
<ul>
<li>最佳情况：T(n) = O(nlogn)</li>
<li>最差情况：T(n) = O(nlogn)</li>
<li>平均情况：T(n) = O(nlogn)</li>
</ul>
</blockquote>
<blockquote>
<h2 id="8、计数排序（Counting-Sort）"><a href="#8、计数排序（Counting-Sort）" class="headerlink" title="8、计数排序（Counting Sort）"></a>8、计数排序（Counting Sort）</h2><p><strong>计数排序</strong> 的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
<p><strong>计数排序(Counting sort)</strong> 是一种稳定的排序算法。计数排序使用一个额外的数组 C，其中第 i 个元素是待排序数组 A 中值等于 i 的元素的个数。然后根据数组 C 来将 A 中的元素排到正确的位置。它只能对整数进行排序。</p>
<ul>
<li><p>8.1 算法描述</p>
<ul>
<li>步骤 1：找出待排序的数组中最大和最小的元素；</li>
<li>步骤 2：统计数组中每个值为 i 的元素出现的次数，存入数组 C 的第 i 项；</li>
<li>步骤 3：对所有的计数累加（从 C 中的第一个元素开始，每一项和前一项相加）；</li>
<li>步骤 4：反向填充目标数组：将每个元素 i 放在新数组的第 C(i)项，每放一个元素就将 C(i)减去 1。</li>
</ul>
</li>
<li><p>8.2 动图演示</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMzE3NDA4NDAtNjk2ODE4MS5naWY" alt="image"></p>
</li>
<li><p>8.3 代码实现</p>
</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;**



 * 计数排序



 *



 * @param array



 * @return



 *&#x2F;



public static int[] CountingSort(int[] array) &#123;



    if (array.length &#x3D;&#x3D; 0) return array;



    int bias, min &#x3D; array[0], max &#x3D; array[0];



    for (int i &#x3D; 1; i &lt; array.length; i++) &#123;



        if (array[i] &gt; max)



            max &#x3D; array[i];



        if (array[i] &lt; min)



            min &#x3D; array[i];



    &#125;



    bias &#x3D; 0 - min;



    int[] bucket &#x3D; new int[max - min + 1];



    Arrays.fill(bucket, 0);



    for (int i &#x3D; 0; i &lt; array.length; i++) &#123;



        bucket[array[i] + bias]++;



    &#125;



    int index &#x3D; 0, i &#x3D; 0;



    while (index &lt; array.length) &#123;



        if (bucket[i] !&#x3D; 0) &#123;



            array[index] &#x3D; i - bias;



            bucket[i]--;



            index++;



        &#125; else



            i++;



    &#125;



    return array;



&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>8.4 算法分析</p>
<p>当输入的元素是 n 个 0 到 k 之间的整数时，它的运行时间是 O(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组 C 的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上 1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。</p>
<ul>
<li>最佳情况：T(n) = O(n+k)</li>
<li>最差情况：T(n) = O(n+k)</li>
<li>平均情况：T(n) = O(n+k)</li>
</ul>
</blockquote>
<blockquote>
<h2 id="9、桶排序（Bucket-Sort）"><a href="#9、桶排序（Bucket-Sort）" class="headerlink" title="9、桶排序（Bucket Sort）"></a>9、桶排序（Bucket Sort）</h2><p><strong>桶排序</strong> 是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。</p>
<p><strong>桶排序 (Bucket sort)的工作的原理：</strong><br>假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排</p>
<ul>
<li><p>9.1 算法描述</p>
<ul>
<li><p>步骤 1：人为设置一个 BucketSize，作为每个桶所能放置多少个不同数值（例如当 BucketSize==5 时，该桶可以存放｛1,2,3,4,5｝这几种数字，但是容量不限，即可以存放 100 个 3）；</p>
</li>
<li><p>步骤 2：遍历输入数据，并且把数据一个一个放到对应的桶里去；</p>
</li>
<li><p>步骤 3：对每个不是空的桶进行排序，可以使用其它排序方法，也可以递归使用桶排序；</p>
</li>
<li><p>步骤 4：从不是空的桶里把排好序的数据拼接起来。</p>
<p>注意，如果递归使用桶排序为各个桶排序，则当桶数量为 1 时要手动减小 BucketSize 增加下一循环桶的数量，否则会陷入死循环，导致内存溢出。</p>
</li>
</ul>
</li>
<li><p>9.2 图片演示</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMzIxMDcwOTAtMTkyMDcwMjAxMS5wbmc?x-oss-process=image/format,png" alt="image"></p>
</li>
<li><p>9.3 代码实现</p>
</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;**



    * 桶排序



    *



    * @param array



    * @param bucketSize



    * @return



    *&#x2F;



   public static ArrayList&lt;Integer&gt; BucketSort(ArrayList&lt;Integer&gt; array, int bucketSize) &#123;



       if (array &#x3D;&#x3D; null || array.size() &lt; 2)



           return array;



       int max &#x3D; array.get(0), min &#x3D; array.get(0);



       &#x2F;&#x2F; 找到最大值最小值



       for (int i &#x3D; 0; i &lt; array.size(); i++) &#123;



           if (array.get(i) &gt; max)



               max &#x3D; array.get(i);



           if (array.get(i) &lt; min)



               min &#x3D; array.get(i);



       &#125;



       int bucketCount &#x3D; (max - min) &#x2F; bucketSize + 1;



       ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr &#x3D; new ArrayList&lt;&gt;(bucketCount);



       ArrayList&lt;Integer&gt; resultArr &#x3D; new ArrayList&lt;&gt;();



       for (int i &#x3D; 0; i &lt; bucketCount; i++) &#123;



           bucketArr.add(new ArrayList&lt;Integer&gt;());



       &#125;



       for (int i &#x3D; 0; i &lt; array.size(); i++) &#123;



           bucketArr.get((array.get(i) - min) &#x2F; bucketSize).add(array.get(i));



       &#125;



       for (int i &#x3D; 0; i &lt; bucketCount; i++) &#123;



           if (bucketSize &#x3D;&#x3D; 1) &#123; &#x2F;&#x2F; 如果带排序数组中有重复数字时



               for (int j &#x3D; 0; j &lt; bucketArr.get(i).size(); j++)



                   resultArr.add(bucketArr.get(i).get(j));



           &#125; else &#123;



               if (bucketCount &#x3D;&#x3D; 1)



                   bucketSize--;



               ArrayList&lt;Integer&gt; temp &#x3D; BucketSort(bucketArr.get(i), bucketSize);



               for (int j &#x3D; 0; j &lt; temp.size(); j++)



                   resultArr.add(temp.get(j));



           &#125;



       &#125;



       return resultArr;



   &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>9.4 算法分析</p>
<p>桶排序最好情况下使用线性时间 O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为 O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。</p>
<ul>
<li>最佳情况：T(n) = O(n+k)</li>
<li>最差情况：T(n) = O(n+k)</li>
<li>平均情况：T(n) = O(n2)</li>
</ul>
</blockquote>
<h3 id="基数排序（Radix-Sort）"><a href="#基数排序（Radix-Sort）" class="headerlink" title="基数排序（Radix Sort）"></a>基数排序（Radix Sort）</h3><p><strong>基数排序</strong>也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为 O(kn),为数组长度，k 为数组中的数的最大的位数；</p>
<p><strong>基数排序</strong>是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。</p>
<ul>
<li><p>10.1 算法描述</p>
<ul>
<li>步骤 1：取得数组中的最大数，并取得位数；</li>
<li>步骤 2：arr 为原始数组，从最低位开始取每个位组成 radix 数组；</li>
<li>步骤 3：对 radix 进行计数排序（利用计数排序适用于小范围数的特点）；</li>
</ul>
</li>
<li><p>10.2 动图演示</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMzI0NTM2NjgtMTM5NzY2MjUyNy5naWY" alt="image"></p>
</li>
<li><p>10.3 代码实现</p>
</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;**



    * 基数排序



    * @param array



    * @return



    *&#x2F;



   public static int[] RadixSort(int[] array) &#123;



       if (array &#x3D;&#x3D; null || array.length &lt; 2)



           return array;



       &#x2F;&#x2F; 1.先算出最大数的位数；



       int max &#x3D; array[0];



       for (int i &#x3D; 1; i &lt; array.length; i++) &#123;



           max &#x3D; Math.max(max, array[i]);



       &#125;



       int maxDigit &#x3D; 0;



       while (max !&#x3D; 0) &#123;



           max &#x2F;&#x3D; 10;



           maxDigit++;



       &#125;



       int mod &#x3D; 10, div &#x3D; 1;



       ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketList &#x3D; new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();



       for (int i &#x3D; 0; i &lt; 10; i++)



           bucketList.add(new ArrayList&lt;Integer&gt;());



       for (int i &#x3D; 0; i &lt; maxDigit; i++, mod *&#x3D; 10, div *&#x3D; 10) &#123;



           for (int j &#x3D; 0; j &lt; array.length; j++) &#123;



               int num &#x3D; (array[j] % mod) &#x2F; div;



               bucketList.get(num).add(array[j]);



           &#125;



           int index &#x3D; 0;



           for (int j &#x3D; 0; j &lt; bucketList.size(); j++) &#123;



               for (int k &#x3D; 0; k &lt; bucketList.get(j).size(); k++)



                   array[index++] &#x3D; bucketList.get(j).get(k);



               bucketList.get(j).clear();



           &#125;



       &#125;



       return array;



   &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><p>10.4 算法分析</p>
<ul>
<li>最佳情况：T(n) = O(n * k)</li>
<li>最差情况：T(n) = O(n * k)</li>
<li>平均情况：T(n) = O(n * k)</li>
</ul>
</li>
<li><p>10.5 基数排序有两种方法：</p>
<ul>
<li>MSD 从高位开始进行排序</li>
<li>LSD 从低位开始进行排序</li>
</ul>
</li>
<li><p><strong>基数排序</strong> vs <strong>计数排序</strong> vs <strong>桶排序</strong></p>
<p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p>
<ul>
<li><strong>基数排序：</strong> 根据键值的每位数字来分配桶</li>
<li><strong>计数排序：</strong> 每个桶只存储单一键值</li>
<li><strong>桶排序：</strong> 每个桶存储一定范围的数值</li>
</ul>
</li>
</ul>
<h2 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h2><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>非递归</p>
<pre class="line-numbers language-none"><code class="language-none">function BinarySearch(arr, item) &#123;
     let left &#x3D; 0,right &#x3D; arr.length - 1
     while(left &lt;&#x3D; right)&#123;
       let mid &#x3D; Math.floor(left + right)
       if(arr[mid] &#x3D;&#x3D;&#x3D; item)&#123;
         return mid
       &#125;else if(item &lt; arr[mid])&#123;
         right &#x3D; mid - 1
       &#125;else&#123;
         left &#x3D; mid + 1
       &#125;
     &#125;
     return false
   &#125;
   &#x2F;&#x2F;使用二分查找必须是已经排好序的数组
   let arr &#x3D; [1, 4, 8, 20, 77, 266, 888, 1999, 2222, 4982]
   console.log(BinarySearch(arr, 77));  &#x2F;&#x2F;4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>递归</p>
<pre class="line-numbers language-none"><code class="language-none">
function BinarySearch(arr,item,start,end) &#123;
        var mid &#x3D; Math.floor((start+end)&#x2F;2)
        if(item &#x3D;&#x3D;&#x3D; arr[mid])&#123;
            return mid
        &#125;
        else if(item&lt;arr[mid])&#123;
            return BinarySearch(arr,item,start,mid-1)
        &#125;
        else&#123;
            return BinarySearch(arr,item,mid+1,end)
        &#125;
        return false
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" rel="tag"># 数据结构和算法</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/03/07/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/" rel="prev" title="前端基础知识">
                  <i class="fa fa-chevron-left"></i> 前端基础知识
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>







<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Colorfuls</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共43.7k字</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.4.0/pjax.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '.page-configurations',
    '.main-inner',
    '.post-toc-wrap',
    '.languages',
    '.pjax'
  ],
  analytics: false,
  cacheBust: false,
  scrollRestoration: false,
  scrollTo: !CONFIG.bookmark.enable
});

document.addEventListener('pjax:success', () => {
  pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  const hasTOC = document.querySelector('.post-toc');
  document.querySelector('.sidebar-inner').classList.toggle('sidebar-nav-active', hasTOC);
  document.querySelector(hasTOC ? '.sidebar-nav-toc' : '.sidebar-nav-overview').click();
  NexT.utils.updateSidebarPosition();
});
</script>


  






  



    <div class="pjax">


  
    </div>
  
  <script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
  
</body>
</html>
