<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Vue查漏补缺</title>
    <url>/2021/03/23/Vue%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/</url>
    <content><![CDATA[<h1 id="Vue-查漏补缺"><a href="#Vue-查漏补缺" class="headerlink" title="Vue 查漏补缺"></a>Vue 查漏补缺</h1><ol>
<li><h2 id="data-为什么被定义成函数"><a href="#data-为什么被定义成函数" class="headerlink" title="data 为什么被定义成函数"></a>data 为什么被定义成函数</h2><p>避免组件中的数据互相影响。同一个组件被复用多次会创建多个实例，如果 data 是一个对象的话，这些实例用的是同一个构造函数。为了保证组件的数据独立，要求每个组件都必须通过 data 函数返回一个对象作为组件的状态。</p>
<a id="more"></a>
</li>
<li><h2 id="vue-组件之间的传递分类："><a href="#vue-组件之间的传递分类：" class="headerlink" title="vue 组件之间的传递分类："></a>vue 组件之间的传递分类：</h2><ol>
<li>父向子传递:props</li>
<li>子向父传递：$emit</li>
<li>兄弟之间传递：借助中间代理：emit,$on</li>
<li>祖先传给孙子：provide,inject</li>
</ol>
</li>
<li><h2 id="v-model-中的实现原理及如何自定义-v-model"><a href="#v-model-中的实现原理及如何自定义-v-model" class="headerlink" title="v-model 中的实现原理及如何自定义 v-model"></a>v-model 中的实现原理及如何自定义 v-model</h2><p>v-model 可以看成是 value+input 方法的语法糖(组件)。原生的 v-model，会根据标签的不同生成不同的事件与属性。</p>
<p>自定义:自己写 model 属性，里面放上 Prop 和 event</p>
</li>
<li><h2 id="Vue-性能优化"><a href="#Vue-性能优化" class="headerlink" title="Vue 性能优化"></a>Vue 性能优化</h2><h5 id="编码优化"><a href="#编码优化" class="headerlink" title="编码优化"></a>编码优化</h5><ul>
<li>事件代理</li>
<li>keep-alive</li>
<li>拆分组件</li>
<li>key 保证唯一性</li>
<li>路由懒加载、异步组件</li>
<li>防抖节流</li>
</ul>
<h5 id="Vue-加载性能优化"><a href="#Vue-加载性能优化" class="headerlink" title="Vue 加载性能优化"></a>Vue 加载性能优化</h5><ul>
<li>第三方模块按需导入（babel-plugin-component)</li>
<li>图片懒加载</li>
</ul>
<p>用户体验</p>
<ul>
<li>app-skeleton 骨架屏</li>
<li>shellap p 壳</li>
<li>pwa</li>
</ul>
<p>SEO 优化</p>
<ul>
<li>预渲染</li>
</ul>
</li>
<li><h2 id="Computed、watch-和-method"><a href="#Computed、watch-和-method" class="headerlink" title="Computed、watch 和 method"></a>Computed、watch 和 method</h2><p><strong>computed</strong>：默认 computed 也是一个 watcher 具备缓存,只有当依赖的数据变化时才会计算，当数据没有变化时，它会读取缓存数据。如果一个数据依赖于其他数据，使用 computed</p>
<p><strong>watch</strong>:每次都需要执行函数。watch 更适用于数据变化时的异步操作。如果需要在某个数据变化时做一些事情，使用 watch。</p>
<p><strong>method</strong>:只要把方法用到模板上了，每次一变化就会重新渲染视图，性能开销大。</p>
</li>
<li><h2 id="vue-中的-watch-监听数据变化"><a href="#vue-中的-watch-监听数据变化" class="headerlink" title="vue 中的 watch 监听数据变化"></a>vue 中的 watch 监听数据变化</h2><ol>
<li><h3 id="watch-使用的几种方法"><a href="#watch-使用的几种方法" class="headerlink" title="watch 使用的几种方法"></a>watch 使用的几种方法</h3><ol>
<li><p>通过 watch 监听 data 数据的变化，数据发生变化时，就会打印当前的值</p>
<pre class="line-numbers language-none"><code class="language-none">watch: &#123;
    data(val, newval) &#123;
        console.log(val)
        console.log(newval)
    &#125;
  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>通过 watch 监听 docData 数据的变化，数据发生变化时，this,change_number++(使用深度监听)</p>
<pre class="line-numbers language-none"><code class="language-none">watch: &#123;
    docData: &#123;
      handler(newVal) &#123;
        this.change_number++
      &#125;,
      deep: true
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>通过 watch 监听 data 数据的变化，数据发生变化时,执行 changeData 方法</p>
<pre class="line-numbers language-none"><code class="language-none">watch: &#123;
    data： &#39;changeData&#39;  &#x2F;&#x2F; 值可以为methods的方法名
&#125;，
methods: &#123;
      changeData(curVal,oldVal)&#123;
    　　　 conosle.log(curVal,oldVal)
　　&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2></li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="生命周期图示"><a href="#生命周期图示" class="headerlink" title="生命周期图示"></a>生命周期图示</h3><p><img src="https://cn.vuejs.org/images/lifecycle.png" alt="Vue 实例生命周期"></p>
<ul>
<li><h4 id="beforeCreate"><a href="#beforeCreate" class="headerlink" title="beforeCreate"></a>beforeCreate</h4><ul>
<li>类型：Function</li>
<li>作用：在实例初始化之后，数据观测（data observer）和 event/watcher 事件配置之前被调用</li>
</ul>
</li>
<li><h4 id="created"><a href="#created" class="headerlink" title="created"></a>created</h4><ul>
<li>类型：Function</li>
<li>作用：在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测（data observer），property 和方法的运算，watch/event 事件回调。</li>
</ul>
</li>
<li><h4 id="beforeMount"><a href="#beforeMount" class="headerlink" title="beforeMount"></a>beforeMount</h4><ul>
<li>类型：Function</li>
<li>作用：在挂载开始之前被调用：相关的 render 函数首次被调用。</li>
</ul>
</li>
<li><h4 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a>mounted</h4><ul>
<li>类型：Function</li>
<li>作用：实例被挂载后调用，这时 el 被新创建的 vm.$el 替换了。</li>
</ul>
</li>
<li><h4 id="beforeUpdate"><a href="#beforeUpdate" class="headerlink" title="beforeUpdate"></a>beforeUpdate</h4><ul>
<li>类型：Function</li>
<li>作用：数据更新时调用，发生在虚拟 DOM 打补丁之前。</li>
</ul>
</li>
<li><h4 id="updated"><a href="#updated" class="headerlink" title="updated"></a>updated</h4><ul>
<li>类型：Function</li>
<li>作用：由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后回调用该钩子。</li>
</ul>
</li>
<li><h4 id="beforeDestroy"><a href="#beforeDestroy" class="headerlink" title="beforeDestroy"></a>beforeDestroy</h4><ul>
<li>类型：Function</li>
<li>作用：实例销毁之前调用。在这一步实例仍然完全可用。</li>
</ul>
</li>
<li><h4 id="destroyed"><a href="#destroyed" class="headerlink" title="destroyed"></a>destroyed</h4><ul>
<li>类型：Function</li>
<li>作用：实例销毁后调用。解绑 Vue 实例的所用指令，移除所有事件监听器。</li>
</ul>
</li>
</ul>
<h2 id="组件传值"><a href="#组件传值" class="headerlink" title="组件传值"></a>组件传值</h2><h3 id="provide-inject"><a href="#provide-inject" class="headerlink" title="provide/inject"></a>provide/inject</h3><ul>
<li><h5 id="类型："><a href="#类型：" class="headerlink" title="类型："></a>类型：</h5><ul>
<li><strong>provide</strong>：Object | () =&gt; Object</li>
<li><strong>inject</strong>：Array<string> | {[key: string] : string | Symbol | Object}</li>
</ul>
</li>
<li><h5 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h5><ul>
<li>provide 选项应该是一个对象或返回一个对象的函数。</li>
<li>inject 选项应该是：<ul>
<li>一个字符串数组或</li>
<li>一个对象，对象的 key 是本地的绑定名，value 是：<ul>
<li>在可用的注入内容中搜索用的 key（字符串或 Symbol），或</li>
<li>一个对象，该对象的：<ul>
<li>from property 是在可用的注入内容中搜索有用的 key</li>
<li>default property 是降级情况下使用的 value</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="model"><a href="#model" class="headerlink" title="model"></a>model</h2><ul>
<li>类型：{prop?: string , event ?:string}</li>
<li>作用：允许一个自定义组件在使用<code>v-model</code>时定制 prop 和 event。默认情况下，一个组件上的 v-model 会把<code>value</code>用作 prop 且把<strong>input</strong>用作 event，但是一些输入类型比如单选框和复选框按钮可能想使用 <code>value</code> prop 来达到不同的目的。使用 <code>model</code> 选项可以回避这些情况产生的冲突。</li>
</ul>
<p><code>model</code> 接受有两个属性：</p>
<ul>
<li>props 代替原来 <code>value</code> 的值。</li>
<li>event 代替原本 <code>input</code> 出发的事件。</li>
</ul>
<p><strong>子组件</strong></p>
<pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;
  &lt;div v-if&#x3D;&quot;show&quot;&gt;
    &lt;div&gt;
      &lt;p&gt;定制 v-model&lt;&#x2F;p&gt;
      &lt;button @click&#x3D;&quot;close&quot;&gt;关闭组件&lt;&#x2F;button&gt;
    &lt;&#x2F;div&gt;
  &lt;&#x2F;div&gt;
&lt;&#x2F;template&gt;

&lt;script&gt;
export default &#123;
  model: &#123;
    prop: &#39;show&#39;,
    event: &#39;close&#39;,
  &#125;,
  props: [&#39;show&#39;],
  methods: &#123;
    close() &#123;
      this.$emit(&#39;close&#39;, false)
    &#125;,
  &#125;,
&#125;
&lt;&#x2F;script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>父组件</strong></p>
<pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;
  &lt;div&gt;
    &lt;button @click&#x3D;&quot;show &#x3D; true&quot;&gt;打开model&lt;&#x2F;button&gt;
    &lt;child v-model&#x3D;&quot;show&quot;&gt;&lt;&#x2F;child&gt;
    &lt;!-- 等同于 --&gt;
    &lt;child :show&#x3D;&quot;show&quot; @close&#x3D;&quot;show &#x3D; $event&quot;&gt;&lt;&#x2F;child&gt;
  &lt;&#x2F;div&gt;
&lt;&#x2F;template&gt;

&lt;script&gt;
import Child from &#39;.&#x2F;child&#39;
export default &#123;
  components: &#123;
    Child,
  &#125;,
  data() &#123;
    return &#123;
      show: false,
    &#125;
  &#125;,
&#125;
&lt;&#x2F;script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol>
<li>当父组件点击 打开 model 按钮的时候，内部的 show 属性变为了 true, 这时因为子组件的显示与隐藏是根据 props 里面的 show 来确定的， 子组件将会显示。</li>
<li>点击子组件的 关闭组件 按钮, 出发了 close 事件，这个事件中将会像父级暴露一个 close 方法，并传递一个 false 参数。</li>
<li>父级触发 close 方法，改变 show 的值.</li>
</ol>
<h2 id="计算属性和侦听器"><a href="#计算属性和侦听器" class="headerlink" title="计算属性和侦听器"></a>计算属性和侦听器</h2><h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><p>对于任何复杂逻辑，都应当使用计算属性。</p>
]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>前端基础知识</title>
    <url>/2021/03/07/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h2 id="前端基础知识整理"><a href="#前端基础知识整理" class="headerlink" title="前端基础知识整理"></a>前端基础知识整理</h2><h3 id="1-typeof返回的数据类型"><a href="#1-typeof返回的数据类型" class="headerlink" title="1.typeof返回的数据类型"></a>1.typeof返回的数据类型</h3><p>typeof返回的数据类型包括undefined、 string、number、boolean、symbol、Object、Function类型</p>
<a id="more"></a>
<h3 id="2-检查数组的方式"><a href="#2-检查数组的方式" class="headerlink" title="2.检查数组的方式"></a>2.检查数组的方式</h3><ol>
<li>isArray()方法</li>
<li>toString.call()</li>
<li>instanceof Array</li>
</ol>
<h3 id="3-js中的call、apply、bind方法的区别"><a href="#3-js中的call、apply、bind方法的区别" class="headerlink" title="3.js中的call、apply、bind方法的区别"></a>3.js中的call、apply、bind方法的区别</h3><p>js中的call apply bind 都是用来改变方法上下文(context)，就是可以使函数可以被其他对象调用。</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> hxy <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
    name<span class="token operator">:</span> <span class="token string">'hxy'</span><span class="token punctuation">,</span>
    age<span class="token operator">:</span> <span class="token number">22</span><span class="token punctuation">,</span>
    <span class="token function">say</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">':'</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">+</span> x <span class="token operator">+</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">let</span> yyw <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
    name<span class="token operator">:</span> <span class="token string">'yyw'</span><span class="token punctuation">,</span>
    age<span class="token operator">:</span> <span class="token number">18</span>
<span class="token punctuation">&#125;</span>
hxy<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 实际上是调用的this.say() this指的是hxy</span>
hxy<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>yyw<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 调用apply后this改变指向，this指向yyw，相当于yyw.say()</span>
hxy<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>yyw<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
hxy<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>yyw<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>运行结果：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">hxy<span class="token operator">:</span><span class="token number">2212</span>
yyw<span class="token operator">:</span><span class="token number">1812</span>
yyw<span class="token operator">:</span><span class="token number">1812</span>
yyw<span class="token operator">:</span><span class="token number">1812</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="4-闭包"><a href="#4-闭包" class="headerlink" title="4.闭包"></a>4.闭包</h2><p>简单来说，闭包就是指能读取其他函数内部变量的函数<br>闭包的简单应用:</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">var</span> n <span class="token operator">=</span> <span class="token number">99</span><span class="token punctuation">;</span>
    <span class="token keyword">function</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> n<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> f2<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">result</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
\\返回n<span class="token operator">=</span><span class="token number">99</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>运行结果返回了f1中的变量n</p>
<p>闭包有三个特性:</p>
<blockquote>
<p>1.函数嵌套函数<br>2.函数内部可以引用外部的参数和变量<br>3.参数和变量不会被垃圾回收机制回收</p>
</blockquote>
<p>使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。</p>
<h3 id="5-js事件机制"><a href="#5-js事件机制" class="headerlink" title="5.js事件机制"></a>5.js事件机制</h3><p>DOM事件流分为三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段<br><strong>事件捕获（event capturing）</strong>：通俗的理解就是，当鼠标点击或者触发dom事件时，浏览器会从根节点开始由外到内进行事件传播，即点击了子元素，如果父元素通过事件捕获方式注册了对应的事件的话，会先触发父元素绑定的事件。<br><strong>事件冒泡（dubbed bubbling）</strong>：与事件捕获恰恰相反，事件冒泡顺序是由内到外进行事件传播，直到根节点。<br>dom标准事件流的处理顺序为先捕获、再冒泡</p>
<h3 id="常用的处理字符串方法"><a href="#常用的处理字符串方法" class="headerlink" title="常用的处理字符串方法"></a>常用的处理字符串方法</h3><p><strong><a href="https://links.jianshu.com/go?to=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/charAt">.charAt(index)</a></strong>:获取字符串索引对应的具体字符，参数index介于 0~length-1之间。</p>
<p><strong><a href="https://links.jianshu.com/go?to=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf">.indexOf(value,index)</a></strong>:返回字符串第一次出现指定值的索引，没有找到指定值就返回-1。<br> 字符串、数组都适用。<br> value：必需，规定需检索的字符串值。可选的整数参数。<br> index：规定在字符串中开始检索的位置。它的合法取值是 0 到 stringObject.length - 1。如省略该参数，则将从字符串的首字符开始检索。</p>
<p><strong><a href="https://links.jianshu.com/go?to=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/substr">.substr(start,length)</a></strong>:返回从指定位置开始到指定字符数的字符。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/16573783-49cd30241aecbd9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/895/format/webp" alt="img"></p>
<p><strong><a href="https://links.jianshu.com/go?to=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/substring">.substring(indexStart,indexEnd)</a></strong>:返回一个字符串从开始索引到结束索引之间的新字符串。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/16573783-263e9cc74899752c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/877/format/webp" alt="img"></p>
<p>**<a href="https://links.jianshu.com/go?to=https://www.cnblogs.com/webjoker/p/5218114.html">.split() 字符串</a>**：使用指定的分隔符字符串将一个<a href="https://links.jianshu.com/go?to=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/String"><code>String</code></a>对象分割成子字符串数组，以一个指定的分割字串来决定每个拆分的位置。</p>
<p>**<a href="https://links.jianshu.com/go?to=https://www.w3school.com.cn/jsref/jsref_replace.asp">.replace() 字符串</a>**：方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串</p>
<p><strong><a href="https://links.jianshu.com/go?to=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/toLowerCase">toLowerCase()</a></strong>:会将调用该方法的字符串值转为小写形式，并返回。</p>
<p><strong><a href="https://links.jianshu.com/go?to=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/toUpperCase">toUpperCase()</a></strong>:方法将调用该方法的字符串转为大写形式并返回（如果调用该方法的值不是字符串类型会被强制转换）。</p>
]]></content>
      <tags>
        <tag>front</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试题</title>
    <url>/2021/03/07/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h2 id="前端面试题"><a href="#前端面试题" class="headerlink" title="前端面试题"></a>前端面试题</h2><h3 id="window-对象-和-document-对象"><a href="#window-对象-和-document-对象" class="headerlink" title="window 对象 和 document 对象"></a>window 对象 和 document 对象</h3><p>window 对象：代表浏览器中一个打开的窗口<br>document 对象：代表整个 HTML 文档，可以用来访问页面中的所有元素，且每个载入浏览器的 HTML 文档都是 document 对象<br>document 对象是 window 对象的一部分，可以有 window. document 来访问</p>
<a id="more"></a>

<h3 id="javascript-中的-this-指的对象是什么？"><a href="#javascript-中的-this-指的对象是什么？" class="headerlink" title="javascript 中的 this 指的对象是什么？"></a>javascript 中的 this 指的对象是什么？</h3><p>查看 JavaScript 中 this 指向的对象，this 指向的一句话法则：</p>
<p>永远指向其所在函数的所有者如果没有所有者时，指向 window。</p>
<p>理解 this 的要点：关键在于将函数与函数名分开看待。同一个函数，在不同的执行方法下，会有不同的效果。</p>
<p>1）全局函数中的 this 指向</p>
<p>2）对象方法中的 this 指向</p>
<p>3）绑定函数时的 this</p>
<p>4）绑定函数时的 this</p>
<p>5）鼠标单击事件等进行函数的绑定时，this 的指向</p>
<p>6）setTimeout 等传参形式的 this 指向</p>
<p>7）改变 this 的方法：call,apply</p>
<h2 id="html-部分"><a href="#html-部分" class="headerlink" title="html 部分"></a>html 部分</h2><h3 id="说说你对语义化的理解？"><a href="#说说你对语义化的理解？" class="headerlink" title="说说你对语义化的理解？"></a>说说你对语义化的理解？</h3><pre class="line-numbers language-none"><code class="language-none">1，去掉或者丢失样式的时候能够让页面呈现出清晰的结构
2，有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；
3，方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；
4，便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="Doctype-作用-严格模式与混杂模式如何区分？它们有何意义"><a href="#Doctype-作用-严格模式与混杂模式如何区分？它们有何意义" class="headerlink" title="Doctype 作用? 严格模式与混杂模式如何区分？它们有何意义?"></a>Doctype 作用? 严格模式与混杂模式如何区分？它们有何意义?</h3><pre class="line-numbers language-none"><code class="language-none">（1）、&lt;!DOCTYPE&gt; 声明位于文档中的最前面，处于 &lt;html&gt; 标签之前。告知浏览器以何种模式来渲染文档。

（2）、严格模式的排版和 JS 运作模式是  以该浏览器支持的最高标准运行。

（3）、在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。

（4）、DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="你知道多少种-Doctype-文档类型？"><a href="#你知道多少种-Doctype-文档类型？" class="headerlink" title="你知道多少种 Doctype 文档类型？"></a>你知道多少种 Doctype 文档类型？</h3><pre class="line-numbers language-none"><code class="language-none"> 该标签可声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的 HTML 文档。
 HTML 4.01 规定了三种文档类型：Strict、Transitional 以及 Frameset。
 XHTML 1.0 规定了三种 XML 文档类型：Strict、Transitional 以及 Frameset。
Standards （标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页，而 Quirks
 （包容）模式（也就是松散呈现模式或者兼容模式）用于呈现为传统浏览器而设计的网页。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="DOM-操作——怎样添加、移除、移动、复制、创建和查找节点。"><a href="#DOM-操作——怎样添加、移除、移动、复制、创建和查找节点。" class="headerlink" title="DOM 操作——怎样添加、移除、移动、复制、创建和查找节点。"></a>DOM 操作——怎样添加、移除、移动、复制、创建和查找节点。</h3><pre class="line-numbers language-none"><code class="language-none">（1）创建新节点

      createDocumentFragment()    &#x2F;&#x2F;创建一个DOM片段

      createElement()   &#x2F;&#x2F;创建一个具体的元素

      createTextNode()   &#x2F;&#x2F;创建一个文本节点

（2）添加、移除、替换、插入

      appendChild()

      removeChild()

      replaceChild()

      insertBefore() &#x2F;&#x2F;在已有的子节点前插入一个新的子节点

（3）查找

      getElementsByTagName()    &#x2F;&#x2F;通过标签名称

      getElementsByName()    &#x2F;&#x2F;通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)

      getElementById()    &#x2F;&#x2F;通过元素Id，唯一性<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="html5-有哪些新特性、移除了那些元素？如何处理-HTML5-新标签的浏览器兼容问题？如何区分-HTML-和-HTML5？"><a href="#html5-有哪些新特性、移除了那些元素？如何处理-HTML5-新标签的浏览器兼容问题？如何区分-HTML-和-HTML5？" class="headerlink" title="html5 有哪些新特性、移除了那些元素？如何处理 HTML5 新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？"></a>html5 有哪些新特性、移除了那些元素？如何处理 HTML5 新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？</h3><pre class="line-numbers language-none"><code class="language-none">* HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。

* 拖拽释放(Drag and drop) API
  语义化更好的内容标签（header,nav,footer,aside,article,section）
  音频、视频API(audio,video)
  画布(Canvas) API
  地理(Geolocation) API
  本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；
  sessionStorage 的数据在浏览器关闭后自动删除

  表单控件，calendar、date、time、email、url、search
  新的技术webworker, websocket, Geolocation

* 移除的元素

纯表现的元素：basefont，big，center，font, s，strike，tt，u；

对可用性产生负面影响的元素：frame，frameset，noframes；

支持HTML5新标签：

* IE8&#x2F;IE7&#x2F;IE6支持通过document.createElement方法产生的标签，
  可以利用这一特性让这些浏览器支持HTML5新标签，

  浏览器支持新标签后，还需要添加标签默认的样式：

* 当然最好的方式是直接使用成熟的框架、使用最多的是html5shim框架
   &lt;!--[if lt IE 9]&gt;
   &lt;script&gt; src&#x3D;&quot;http:&#x2F;&#x2F;html5shim.googlecode.com&#x2F;svn&#x2F;trunk&#x2F;html5.js&quot;&lt;&#x2F;script&gt;
   &lt;![endif]--&gt;
如何区分：DOCTYPE声明新增的结构元素功能元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="documen-write-和-innerHTML-的区别"><a href="#documen-write-和-innerHTML-的区别" class="headerlink" title="documen.write 和 innerHTML 的区别"></a>documen.write 和 innerHTML 的区别</h2><pre class="line-numbers language-none"><code class="language-none">document.write只能重绘整个页面

innerHTML可以重绘页面的一部分<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      <tags>
        <tag>front</tag>
      </tags>
  </entry>
  <entry>
    <title>原型链与继承</title>
    <url>/2021/03/22/%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%B8%8E%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h2 id="原型链与继承"><a href="#原型链与继承" class="headerlink" title="原型链与继承"></a>原型链与继承</h2><p><strong>概念</strong><br>原型链是一种机制，指的是 JavaScript 每个对象<code>包括原型对象</code>都有一个内置的[[proto]]属性指向创建它的函数对象的原型对象，即 prototype 属性。</p>
<a id="more"></a>

<p><strong>作用</strong><br>原型链的存在，主要是为了实现对象的<code>继承</code>。</p>
<p>例子：例如父亲有一百万，父亲的儿子可以继承这一百万</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
array<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype <span class="token comment">//return ture</span>
<span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype <span class="token comment">//return true</span>
<span class="token class-name">Function</span><span class="token punctuation">.</span>prototype <span class="token operator">===</span> Array<span class="token punctuation">.</span>__proto__ <span class="token comment">//return true</span>
<span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype <span class="token comment">//return true</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token comment">//return true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最终指向都是 Object.prototype</p>
<p>Object.prototype.<strong>proto</strong> === null</p>
<p><img src="/images/%E5%8E%9F%E5%9E%8B%E9%93%BE.png" alt="原型链"><br><img src="/images/%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%B8%8E%E7%BB%A7%E6%89%BF.png" alt="原型链与继承"></p>
]]></content>
      <tags>
        <tag>原型链</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构和算法</title>
    <url>/2021/03/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ol>
<li>栈是一个后进先出的数据结构</li>
<li>JavaScript 中没有栈，但可以用 Array 实现栈的所有功能</li>
<li>栈常用操作:push、pop、stack[stack.length-1]<a id="more"></a>

</li>
</ol>
<h3 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h3><p><strong>1、把十进制数转为二进制数</strong><br>// 函数：将十进制转成二进制<br> // 十进制 二进制<br>// Decimal binary<br>function dec2bin(decNumber) {<br>// 1、定义栈对象<br>let stack = new Stack()</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">  <span class="token comment">// 2、循环操作</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span>decNumber <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token comment">// 2.1、获取余数，并且放入到栈中</span>
    stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>decNumber <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span>

    <span class="token comment">//2.2、获取整除后的结果，作为下一次运行的数字</span>
    decNumber <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>decNumber <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span>
  <span class="token punctuation">&#125;</span>

  <span class="token comment">// 3、从栈中取出0和1</span>
  <span class="token keyword">let</span> binaryString <span class="token operator">=</span> <span class="token string">""</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    binaryString <span class="token operator">+=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">return</span> binaryString
<span class="token punctuation">&#125;</span>
<span class="token comment">//测试十进制转二进制的函数</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">dec2bin</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//101</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">dec2bin</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//110010</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="队列-queue"><a href="#队列-queue" class="headerlink" title="队列(queue)"></a>队列(queue)</h2><blockquote>
<p>只允许在一端插入数据操作，在另一端进行删除数据操作的特殊线性表；<br>进行插入操作的一端称为队尾（入队列），进行删除操作的一端称为队头（出队列）；队列具有先进先出（FIFO）的特性。</p>
</blockquote>
<p>js 队列的实现（线性存储）</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//封装队列类</span>
<span class="token keyword">function</span> <span class="token function">Queue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token comment">//队列中的属性</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>items <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token comment">//栈的相关操作</span>
  <span class="token comment">//  1、将元素加入到队列中</span>
  <span class="token class-name">Queue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">add</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">element</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span>
  <span class="token punctuation">&#125;</span>
  <span class="token comment">// 2、从队列中删除前端元素</span>
  <span class="token class-name">Queue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">delete</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">&#125;</span>
  <span class="token comment">//3、查看队列前端元素</span>
  <span class="token class-name">Queue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">front</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
  <span class="token punctuation">&#125;</span>
  <span class="token comment">// 4、判断队列是否为空</span>
  <span class="token class-name">Queue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">isEmpty</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span>
  <span class="token punctuation">&#125;</span>
  <span class="token comment">// 5、获取队列中元素的个数</span>
  <span class="token class-name">Queue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">size</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">.</span>length
  <span class="token punctuation">&#125;</span>
  <span class="token comment">// 6、toString方法</span>
  <span class="token class-name">Queue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">toString</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">let</span> resultString <span class="token operator">=</span> <span class="token string">''</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      resultString <span class="token operator">+=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">' '</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> resultString
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">//队列的使用</span>
<span class="token keyword">let</span> q <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
q<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">'22'</span><span class="token punctuation">)</span>
q<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">'33'</span><span class="token punctuation">)</span>
q<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">'44'</span><span class="token punctuation">)</span>
q<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>q<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>q<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="链表结构"><a href="#链表结构" class="headerlink" title="链表结构"></a>链表结构</h2><ul>
<li>多个元素组成的列表。</li>
<li>元素存储不连续，用 next 指针连在一起。</li>
</ul>
<p><img src="/images/%E9%93%BE%E8%A1%A8.jpg" alt="链表"></p>
<h3 id="数组-vs-链表"><a href="#数组-vs-链表" class="headerlink" title="数组 vs 链表"></a>数组 vs 链表</h3><ul>
<li>数组：增删非首尾元素是往往需要移动元素。</li>
<li>链表：增删非首尾元素，不需要移动元素，只需要更改 next 的指向即可。</li>
</ul>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><ul>
<li>一种无序且唯一的数据结构</li>
<li>ES6 中有集合，名为 set</li>
<li>集合的常用操作：去重，判断某元素是否在集合中、求交集</li>
</ul>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//使用set对象</span>
<span class="token keyword">let</span> mySet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

mySet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
mySet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
mySet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
mySet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">'some text'</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> o <span class="token operator">=</span> <span class="token punctuation">&#123;</span> a<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">&#125;</span>
mySet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span>
mySet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> a<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
<span class="token comment">//是否存在该元素</span>
<span class="token keyword">const</span> has <span class="token operator">=</span> mySet<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span>
mySet<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
<span class="token comment">//遍历</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> item <span class="token keyword">of</span> mySet<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">//转换成数组</span>
<span class="token keyword">const</span> myArr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>mySet<span class="token punctuation">]</span>
<span class="token keyword">const</span> myArrs <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>mySet<span class="token punctuation">)</span>

<span class="token keyword">const</span> mySet2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token comment">//求交集</span>
<span class="token keyword">const</span> intersection <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">...</span>mySet<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token operator">=></span> mySet2<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">//求并集</span>
<span class="token keyword">const</span> difference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">...</span>mySet2<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token operator">!</span>mySet2<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><blockquote>
<p>字典是以[键，值]的形式来存储元素。字典也称作映射、符号表或关联数组。</p>
<p>集合、字典、散列表都可以存储不重复的数据。字典和我们上面实现的集合很像。</p>
<p>ES5 包含了一个 Map 类的实现，即我们所说的字典。</p>
</blockquote>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> m <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">//增</span>
m<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'aa'</span><span class="token punctuation">)</span>
m<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'bb'</span><span class="token punctuation">)</span>
<span class="token comment">//删</span>
m<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">)</span>
<span class="token comment">// m.clear();</span>

<span class="token comment">//改</span>
m<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'aaa'</span><span class="token punctuation">)</span>

<span class="token comment">//查</span>
m<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>两数之和</p>
<p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> <span class="token function-variable function">twoSum</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">nums<span class="token punctuation">,</span> target</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">const</span> n <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
    <span class="token keyword">const</span> n2 <span class="token operator">=</span> target <span class="token operator">-</span> n
    <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>n2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token keyword">return</span> <span class="token punctuation">[</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>n2<span class="token punctuation">)</span><span class="token punctuation">,</span> i<span class="token punctuation">]</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
      map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> i<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">const</span> nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  target <span class="token operator">=</span> <span class="token number">9</span>
<span class="token function">twoSum</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><ul>
<li><p>一种分层数据的抽象模型</p>
</li>
<li><p>前端工作中常见的树包括：DOM、树、级联选择、树形控件</p>
</li>
<li><p>JS 中没有树，但是可以用 Object 和 Array 构建树</p>
</li>
<li><p>树的常用操作：深度/广度优先遍历、先中后序遍历</p>
<ul>
<li><p>深度优先遍历：尽可能深的搜索树的分支</p>
</li>
<li><p>广度优先遍历：先访问离根节点最近的节点</p>
</li>
</ul>
</li>
</ul>
<p><img src="/images/%E6%A0%91.png" alt="树"></p>
<h3 id="深度优先遍历算法口诀"><a href="#深度优先遍历算法口诀" class="headerlink" title="深度优先遍历算法口诀"></a>深度优先遍历算法口诀</h3><ol>
<li>访问根节点</li>
<li>对根节点的 children 挨个进行深度优先遍历</li>
</ol>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> tree <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  val<span class="token operator">:</span> <span class="token string">'a'</span><span class="token punctuation">,</span>
  children<span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">&#123;</span>
      val<span class="token operator">:</span> <span class="token string">'b'</span><span class="token punctuation">,</span>
      children<span class="token operator">:</span> <span class="token punctuation">[</span>
        <span class="token punctuation">&#123;</span>
          val<span class="token operator">:</span> <span class="token string">'d'</span><span class="token punctuation">,</span>
          children<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
        <span class="token punctuation">&#123;</span>
          val<span class="token operator">:</span> <span class="token string">'e'</span><span class="token punctuation">,</span>
          children<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
      <span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
    <span class="token punctuation">&#123;</span>
      val<span class="token operator">:</span> <span class="token string">'c'</span><span class="token punctuation">,</span>
      children<span class="token operator">:</span> <span class="token punctuation">[</span>
        <span class="token punctuation">&#123;</span>
          val<span class="token operator">:</span> <span class="token string">'f'</span><span class="token punctuation">,</span>
          children<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
        <span class="token punctuation">&#123;</span>
          val<span class="token operator">:</span> <span class="token string">'g'</span><span class="token punctuation">,</span>
          children<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
      <span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
  <span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">const</span> <span class="token function-variable function">dfs</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
  root<span class="token punctuation">.</span>children<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>dfs<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token function">dfs</span><span class="token punctuation">(</span>tree<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="广度优先遍历算法口诀"><a href="#广度优先遍历算法口诀" class="headerlink" title="广度优先遍历算法口诀"></a>广度优先遍历算法口诀</h3><ol>
<li>新建一个队列，把根节点入队。</li>
<li>把队头出队并访问。</li>
<li>把队头的 children 挨个入队</li>
<li>重复第二、三步，直到队列为空。</li>
</ol>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> <span class="token function-variable function">bfs</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">const</span> q <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">]</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>q<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">const</span> n <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
    n<span class="token punctuation">.</span>children<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">child</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
      q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token function">bfs</span><span class="token punctuation">(</span>tree<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="二叉树是什么？"><a href="#二叉树是什么？" class="headerlink" title="二叉树是什么？"></a>二叉树是什么？</h3><ul>
<li>树中每个节点最多只能有两个子节点。</li>
<li>在 JS 中通常用 Object 来模拟二叉树。</li>
</ul>
<h3 id="先序遍历算法口诀"><a href="#先序遍历算法口诀" class="headerlink" title="先序遍历算法口诀"></a>先序遍历算法口诀</h3><ol>
<li><p>访问根节点。</p>
</li>
<li><p>对根节点的左子树进行先序遍历。</p>
</li>
<li><p>对根节点的右子树进行先序遍历。</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> bt <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  val<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  left<span class="token operator">:</span> <span class="token punctuation">&#123;</span>
    val<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
    left<span class="token operator">:</span> <span class="token punctuation">&#123;</span>
      val<span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span>
      left<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
      right<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
    right<span class="token operator">:</span> <span class="token punctuation">&#123;</span>
      val<span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">,</span>
      left<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
      right<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
  right<span class="token operator">:</span> <span class="token punctuation">&#123;</span>
    val<span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span>
    left<span class="token operator">:</span> <span class="token punctuation">&#123;</span>
      val<span class="token operator">:</span> <span class="token number">6</span><span class="token punctuation">,</span>
      left<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
      right<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
    right<span class="token operator">:</span> <span class="token punctuation">&#123;</span>
      val<span class="token operator">:</span> <span class="token number">7</span><span class="token punctuation">,</span>
      left<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
      right<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
<span class="token punctuation">&#125;</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> bt
<span class="token keyword">const</span> bt <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./bt'</span><span class="token punctuation">)</span>
<span class="token comment">//先序遍历算法</span>
<span class="token keyword">const</span> <span class="token function-variable function">preorder</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span>
  <span class="token punctuation">&#125;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
  <span class="token function">preorder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
  <span class="token function">preorder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token function">preorder</span><span class="token punctuation">(</span>bt<span class="token punctuation">)</span>
<span class="token comment">//函数调用堆栈，先序遍历非递归版</span>
<span class="token keyword">const</span> <span class="token function-variable function">preorder</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">const</span> stack <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">]</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>stack<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">const</span> n <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token function">preorder</span><span class="token punctuation">(</span>bt<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/images/%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="二叉树"></p>
</li>
</ol>
<h3 id="中序遍历算法口诀"><a href="#中序遍历算法口诀" class="headerlink" title="中序遍历算法口诀"></a>中序遍历算法口诀</h3><ol>
<li><p>对根节点的左子树进行中序遍历。</p>
</li>
<li><p>访问根节点。</p>
</li>
<li><p>对根节点的右子树进行中序遍历。</p>
</li>
</ol>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> bt <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./bt'</span><span class="token punctuation">)</span>
<span class="token comment">//中序遍历算法</span>
<span class="token keyword">const</span> <span class="token function-variable function">inorder</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span>
  <span class="token punctuation">&#125;</span>
  <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
  <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>
<span class="token function">inorder</span><span class="token punctuation">(</span>bt<span class="token punctuation">)</span>
<span class="token comment">//中序遍历算法，非递归版</span>
<span class="token keyword">const</span> <span class="token function-variable function">inorder</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">const</span> stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token keyword">let</span> p <span class="token operator">=</span> root
  <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">||</span> stack<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span>
      p <span class="token operator">=</span> p<span class="token punctuation">.</span>left
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">const</span> n <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
    p <span class="token operator">=</span> n<span class="token punctuation">.</span>right
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token function">inorder</span><span class="token punctuation">(</span>bt<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="后序遍历算法口诀"><a href="#后序遍历算法口诀" class="headerlink" title="后序遍历算法口诀"></a>后序遍历算法口诀</h3><ol>
<li>对根节点的左子树进行后序遍历。</li>
<li>对根节点的右子树进行后续遍历。</li>
<li>访问根节点。</li>
</ol>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> bt <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./bt'</span><span class="token punctuation">)</span>
<span class="token comment">//后续遍历算法口诀，递归版</span>
<span class="token keyword">const</span> <span class="token function-variable function">postorder</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span>
  <span class="token punctuation">&#125;</span>
  <span class="token function">postorder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
  <span class="token function">postorder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>
<span class="token function">postorder</span><span class="token punctuation">(</span>bt<span class="token punctuation">)</span>
<span class="token comment">//后续遍历算法，非递归版</span>
<span class="token keyword">const</span> <span class="token function-variable function">postorder</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">const</span> outputStack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token keyword">const</span> stack <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">]</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>stack<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">const</span> n <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    outputStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>outputStack<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">const</span> n <span class="token operator">=</span> outputStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token function">postorder</span><span class="token punctuation">(</span>bt<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      <tags>
        <tag>数据结构和算法</tag>
      </tags>
  </entry>
  <entry>
    <title>递归创建从大到小排列的数组</title>
    <url>/2021/03/02/%E9%80%92%E5%BD%92%E4%BB%8E%E5%A4%A7%E5%88%B0%E5%B0%8F%E6%8E%92%E5%88%97%E7%9A%84%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h3 id="使用递归创建从大到小排列的数组"><a href="#使用递归创建从大到小排列的数组" class="headerlink" title="使用递归创建从大到小排列的数组"></a>使用递归创建从大到小排列的数组</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">countdown</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token function">countdown</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
    arr<span class="token punctuation">.</span><span class="token function">unshift</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>
    <span class="token keyword">return</span> arr
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<a id="more"></a>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">countdown</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token function">countdown</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
    arr<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span>
    <span class="token keyword">return</span> arr
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">countdown</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">return</span> n <span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token operator">?</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token function">countdown</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">countdown</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">return</span> n <span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token operator">?</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token punctuation">[</span>n<span class="token punctuation">,</span> <span class="token operator">...</span><span class="token function">countdown</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="使用递归创建数组范围"><a href="#使用递归创建数组范围" class="headerlink" title="使用递归创建数组范围"></a><strong>使用递归创建数组范围</strong></h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">rangeOfNumbers</span><span class="token punctuation">(</span><span class="token parameter">startNum<span class="token punctuation">,</span> endNum</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>endNum <span class="token operator">-</span> startNum <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token punctuation">[</span>startNum<span class="token punctuation">]</span>
  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">var</span> numbers <span class="token operator">=</span> <span class="token function">rangeOfNumbers</span><span class="token punctuation">(</span>startNum<span class="token punctuation">,</span> endNum <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
    numbers<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>endNum<span class="token punctuation">)</span>
    <span class="token keyword">return</span> numbers
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">rangeOfNumbers</span><span class="token punctuation">(</span><span class="token parameter">startNum<span class="token punctuation">,</span> endNum</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">return</span> startNum <span class="token operator">===</span> endNum
    <span class="token operator">?</span> <span class="token punctuation">[</span>startNum<span class="token punctuation">]</span>
    <span class="token operator">:</span> <span class="token function">rangeOfNumbers</span><span class="token punctuation">(</span>startNum<span class="token punctuation">,</span> endNum <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>endNum<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">rangeOfNumbers</span><span class="token punctuation">(</span><span class="token parameter">startNum<span class="token punctuation">,</span> endNum</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">return</span> startNum <span class="token operator">===</span> endNum
    <span class="token operator">?</span> <span class="token punctuation">[</span>startNum<span class="token punctuation">]</span>
    <span class="token operator">:</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token function">rangeOfNumbers</span><span class="token punctuation">(</span>startNum<span class="token punctuation">,</span> endNum <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> endNum<span class="token punctuation">]</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器：文档，事件，接口</title>
    <url>/2021/02/23/%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%9A%E6%96%87%E6%A1%A3%EF%BC%8C%E4%BA%8B%E4%BB%B6%EF%BC%8C%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="DOM-树"><a href="#DOM-树" class="headerlink" title="DOM 树"></a>DOM 树</h1><p>HTML 文档的主干是标签（tag）。</p>
<p>根据文档对象模型（DOM），每个 HTML 标签都是一个对象。嵌套的标签是闭合标签的“子标签（children）”。标签内的文本也是一个对象。</p>
<a id="more"></a>
<p>所有这些对象都可以通过 JavaScript 来访问，我们可以使用它们来修改页面。</p>
<p>一共有 <a href="https://dom.spec.whatwg.org/#node">12 种节点类型</a>。实际上，我们通常用到的是其中的 4 种：</p>
<ol>
<li><code>document</code> — DOM 的“入口点”。</li>
<li>元素节点 — HTML 标签，树构建块。</li>
<li>文本节点 — 包含文本。</li>
<li>注释 — 有时我们可以将一些信息放入其中，它不会显示，但 JS 可以从 DOM 中读取它。</li>
</ol>
<p><strong>DOM 集合是只读的</strong></p>
<p>DOM 集合，甚至可以说本章中列出的 <strong>所有</strong> 导航（navigation）属性都是只读的。</p>
<p>我们不能通过类似 <code>childNodes[i] = ...</code> 的操作来替换一个子节点。</p>
<p>修改子节点需要使用其它方法。我们将会在下一章中看到它们。</p>
<p><strong>DOM 集合是实时的</strong></p>
<p>除小部分例外，几乎所有的 DOM 集合都是 <strong>实时</strong> 的。换句话说，它们反映了 DOM 的当前状态。</p>
<p>如果我们保留一个对 <code>elem.childNodes</code> 的引用，然后向 DOM 中添加/移除节点，那么这些节点的更新会自动出现在集合中。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a href="https://zh.javascript.info/dom-nodes#zong-jie">总结</a></h2><p>HTML/XML 文档在浏览器内均被表示为 DOM 树。</p>
<ul>
<li>标签（tag）成为元素节点，并形成文档结构。</li>
<li>文本（text）成为文本节点。</li>
<li>……等，HTML 中的所有东西在 DOM 中都有它的位置，甚至对注释也是如此。</li>
</ul>
<h1 id="遍历-DOM"><a href="#遍历-DOM" class="headerlink" title="遍历 DOM"></a>遍历 DOM</h1><p>DOM 让我们可以对元素和它们中的内容做任何事，但是首先我们需要获取到对应的 DOM 对象。</p>
<p>对 DOM 的所有操作都是以 <code>document</code> 对象开始。它是 DOM 的主“入口点”。从它我们可以访问任何节点。</p>
<p><strong>在 DOM 的世界中，<code>null</code> 就意味着“不存在”</strong></p>
<p>在 DOM 中，<code>null</code> 值就意味着“不存在”或者“没有这个节点”。</p>
<p><strong>DOM 集合是只读的</strong></p>
<p><strong>DOM 集合是实时的</strong></p>
<p><strong>不要使用</strong> <code>for..in</code> <strong>来遍历集合</strong></p>
<h2 id="更多链接：表格"><a href="#更多链接：表格" class="headerlink" title="更多链接：表格"></a><a href="https://zh.javascript.info/dom-navigation#dom-navigation-tables">更多链接：表格</a></h2><table> 元素支持 (除了上面给出的，之外) 以下这些属性:
table.rows — <tr> 元素的集合。table.caption/tHead/tFoot — 引用元素 <caption>，<thead>，<tfoot>。table.tBodies — <tbody> 元素的集合（根据标准还有很多元素，但是这里至少会有一个 — 即使没有被写在 HTML 源文件中，浏览器也会将其放入 DOM 中）。

<thead>，<tfoot>，<tbody> 元素提供了 rows 属性：
tbody.rows — 表格内部 <tr> 元素的集合。

<tr>：
tr.cells — 在给定 <tr> 中的 <td> 和 <th> 单元格的集合。tr.sectionRowIndex — 给定的 <tr> 在封闭的 <thead>/<tbody>/<tfoot> 中的位置（索引）。tr.rowIndex — 在整个表格中 <tr> 的编号（包括表格的所有行）。

<td> 和 <th>：
td.cellIndex — 在封闭的 <tr> 中单元格的编号。

<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><a href="https://zh.javascript.info/dom-navigation#zong-jie">总结</a></h2><p>给定一个 DOM 节点，我们可以使用导航（navigation）属性访问其直接的邻居。</p>
<p>这些属性主要分为两组：</p>
<ul>
<li>对于所有节点：<code>parentNode</code>，<code>childNodes</code>，<code>firstChild</code>，<code>lastChild</code>，<code>previousSibling</code>，<code>nextSibling</code>。</li>
<li>仅对于元素节点：<code>parentElement</code>，<code>children</code>，<code>firstElementChild</code>，<code>lastElementChild</code>，<code>previousElementSibling</code>，<code>nextElementSibling</code>。</li>
</ul>
<p>某些类型的 DOM 元素，例如 table，提供了用于访问其内容的其他属性和集合。</p>
<h1 id="搜索：getElement，querySelector"><a href="#搜索：getElement，querySelector" class="headerlink" title="搜索：getElement，querySelector"></a>搜索：getElement<em>，querySelector</em></h1><h2 id="document-getElementById-或者只使用-id"><a href="#document-getElementById-或者只使用-id" class="headerlink" title="document.getElementById 或者只使用 id"></a><a href="https://zh.javascript.info/searching-elements-dom#documentgetelementbyid-huo-zhe-zhi-shi-yong-id">document.getElementById 或者只使用 id</a></h2><p>如果一个元素有 <code>id</code> 特性（attribute），那我们就可以使用 <code>document.getElementById(id)</code> 方法获取该元素，无论它在哪里。</p>
<p><strong><code>id</code> 必须是唯一的</strong></p>
<p><code>id</code> 必须是唯一的。在文档中，只能有一个元素带有给定的 <code>id</code>。</p>
<p>如果有多个元素都带有同一个 <code>id</code>，那么使用它的方法的行为是不可预测的，例如 <code>document.getElementById</code> 可能会随机返回其中一个元素。因此，请遵守规则，保持 <code>id</code> 的唯一性。</p>
<p><strong>只有 <code>document.getElementById</code>，没有 <code>anyElem.getElementById</code></strong></p>
<p><code>getElementById</code> 方法只能被在 <code>document</code> 对象上调用。它会在整个文档中查找给定的 <code>id</code>。</p>
<h2 id="querySelectorAll"><a href="#querySelectorAll" class="headerlink" title="querySelectorAll"></a><a href="https://zh.javascript.info/searching-elements-dom#querySelectorAll">querySelectorAll</a></h2><p>到目前为止，最通用的方法是 <code>elem.querySelectorAll(css)</code>，它返回 <code>elem</code> 中与给定 CSS 选择器匹配的所有元素。</p>
<h2 id="matches"><a href="#matches" class="headerlink" title="matches"></a><a href="https://zh.javascript.info/searching-elements-dom#matches">matches</a></h2><p>之前的方法是搜索 DOM。</p>
<p><a href="http://dom.spec.whatwg.org/#dom-element-matches">elem.matches(css)</a> 不会查找任何内容，它只会检查 <code>elem</code> 是否与给定的 CSS 选择器匹配。它返回 <code>true</code> 或 <code>false</code>。</p>
<h2 id="closest"><a href="#closest" class="headerlink" title="closest"></a><a href="https://zh.javascript.info/searching-elements-dom#closest">closest</a></h2><p>元素的祖先（ancestor）是：父级，父级的父级，它的父级等。祖先们一起组成了从元素到顶端的父级链。</p>
<p><code>elem.closest(css)</code> 方法会查找与 CSS 选择器匹配的最近的祖先。<code>elem</code> 自己也会被搜索。</p>
<p>换句话说，方法 <code>closest</code> 在元素中得到了提升，并检查每个父级。如果它与选择器匹配，则停止搜索并返回该祖先。</p>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a><a href="https://zh.javascript.info/searching-elements-dom#zong-jie">总结</a></h2><p>目前为止，最常用的是 <code>querySelector</code> 和 <code>querySelectorAll</code>，但是 <code>getElement(s)By*</code> 可能会偶尔有用，或者可以在旧脚本中找到。</p>
<p>此外：</p>
<ul>
<li><code>elem.matches(css)</code> 用于检查 <code>elem</code> 与给定的 CSS 选择器是否匹配。</li>
<li><code>elem.closest(css)</code> 用于查找与给定 CSS 选择器相匹配的最近的祖先。<code>elem</code> 本身也会被检查。</li>
</ul>
<p>让我们在这里提一下另一种用来检查子级与父级之间关系的方法，因为它有时很有用：</p>
<ul>
<li>如果 <code>elemB</code> 在 <code>elemA</code> 内（<code>elemA</code> 的后代）或者 <code>elemA==elemB</code>，<code>elemA.contains(elemB)</code> 将返回 true。</li>
</ul>
<h1 id="节点属性：type，tag-和-content"><a href="#节点属性：type，tag-和-content" class="headerlink" title="节点属性：type，tag 和 content"></a>节点属性：type，tag 和 content</h1><h2 id="DOM-节点类"><a href="#DOM-节点类" class="headerlink" title="DOM 节点类"></a><a href="https://zh.javascript.info/basic-dom-node-properties#dom-jie-dian-lei">DOM 节点类</a></h2><p>不同的 DOM 节点可能有不同的属性。例如，标签 <code>&lt;a&gt;</code> 相对应的元素节点具有链接相关的（link-related）属性，标签 <code>&lt;input&gt;</code> 相对应的元素节点具有与输入相关的属性，等。文本节点与元素节点不同。但是所有这些标签对应的 DOM 节点之间也存在共有的属性和方法，因为所有类型的 DOM 节点都形成了一个单一层次的结构（single hierarchy）。</p>
<p>每个 DOM 节点都属于相应的内建类。</p>
<p>层次结构（hierarchy）的根节点是 <a href="https://dom.spec.whatwg.org/#eventtarget">EventTarget</a>，<a href="http://dom.spec.whatwg.org/#interface-node">Node</a> 继承自它，其他 DOM 节点继承自 Node。</p>
<p><img src="E:\Markdown图片\image-20210202215947121.png" alt="image-20210202215947121"></p>
<h1 id="特性和属性（Attributes-and-properties）"><a href="#特性和属性（Attributes-and-properties）" class="headerlink" title="特性和属性（Attributes and properties）"></a>特性和属性（Attributes and properties）</h1><p>当浏览器加载页面时，它会“读取”（或者称之为：“解析”）HTML 并从中生成 DOM 对象。对于元素节点，大多数标准的 HTML 特性（attributes）会自动变成 DOM 对象的属性（properties）。</p>
<h2 id="HTML-特性"><a href="#HTML-特性" class="headerlink" title="HTML 特性"></a><a href="https://zh.javascript.info/dom-attributes-and-properties#html-te-xing">HTML 特性</a></h2><p>在 HTML 中，标签可能拥有特性（attributes）。当浏览器解析 HTML 文本，并根据标签创建 DOM 对象时，浏览器会辨别 <strong>标准的</strong> 特性并以此创建 DOM 属性。</p>
<p>所以，当一个元素有 <code>id</code> 或其他 <strong>标准的</strong> 特性，那么就会生成对应的 DOM 属性。但是非 <strong>标准的</strong> 特性则不会。</p>
<p>HTML 特性有以下几个特征：</p>
<ul>
<li>它们的名字是大小写不敏感的（<code>id</code> 与 <code>ID</code> 相同）。</li>
<li>它们的值总是字符串类型的。</li>
</ul>
<h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a><a href="https://zh.javascript.info/dom-attributes-and-properties#zong-jie">总结</a></h2><ul>
<li>特性（attribute）— 写在 HTML 中的内容。</li>
<li>属性（property）— DOM 对象中的内容。</li>
</ul>
<p>简略的对比：</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">属性</th>
<th align="left">特性</th>
</tr>
</thead>
<tbody><tr>
<td align="left">类型</td>
<td align="left">任何值，标准的属性具有规范中描述的类型</td>
<td align="left">字符串</td>
</tr>
<tr>
<td align="left">名字</td>
<td align="left">名字（name）是大小写敏感的</td>
<td align="left">名字（name）是大小写不敏感的</td>
</tr>
</tbody></table>
<h1 id="Window-大小和滚动"><a href="#Window-大小和滚动" class="headerlink" title="Window 大小和滚动"></a>Window 大小和滚动</h1><h2 id="窗口的-width-height"><a href="#窗口的-width-height" class="headerlink" title="窗口的 width/height"></a><a href="https://zh.javascript.info/size-and-scroll-window#chuang-kou-de-widthheight">窗口的 width/height</a></h2><p>为了获取窗口（window）的宽度和高度，我们可以使用 <code>document.documentElement</code> 的 <code>clientWidth/clientHeight</code>：</p>
<h2 id="滚动：scrollTo，scrollBy，scrollIntoView"><a href="#滚动：scrollTo，scrollBy，scrollIntoView" class="headerlink" title="滚动：scrollTo，scrollBy，scrollIntoView"></a><a href="https://zh.javascript.info/size-and-scroll-window#window-scroll">滚动：scrollTo，scrollBy，scrollIntoView</a></h2><p>可以通过更改 <code>scrollTop/scrollLeft</code> 来滚动常规元素。</p>
<p>我们可以使用 <code>document.documentElement.scrollTop/scrollLeft</code> 对页面进行相同的操作（Safari 除外，而应该使用 <code>document.body.scrollTop/Left</code> 代替）。</p>
<p>方法 <code>scrollBy(x,y)</code> 将页面滚动至 <strong>相对于当前位置的 <code>(x, y)</code> 位置</strong>。例如，<code>scrollBy(0,10)</code> 会将页面向下滚动 <code>10px</code>。</p>
<p>方法 <code>scrollTo(pageX,pageY)</code> 将页面滚动至 <strong>绝对坐标</strong>，使得可见部分的左上角具有相对于文档左上角的坐标 <code>(pageX, pageY)</code>。就像设置了 <code>scrollLeft/scrollTop</code> 一样。</p>
<p>要滚动到最开始，我们可以使用 <code>scrollTo(0,0)</code>。</p>
<h2 id="scrollIntoView"><a href="#scrollIntoView" class="headerlink" title="scrollIntoView"></a><a href="https://zh.javascript.info/size-and-scroll-window#scrollintoview">scrollIntoView</a></h2><p>为了完整起见，让我们再介绍一种方法：<a href="https://developer.mozilla.org/zh/docs/Web/API/Element/scrollIntoView">elem.scrollIntoView(top)</a>。</p>
<p>对 <code>elem.scrollIntoView(top)</code> 的调用将滚动页面以使 <code>elem</code> 可见。它有一个参数：</p>
<ul>
<li>如果 <code>top=true</code>（默认值），页面滚动，使 <code>elem</code> 出现在窗口顶部。元素的上边缘将与窗口顶部对齐。</li>
<li>如果 <code>top=false</code>，页面滚动，使 <code>elem</code> 出现在窗口底部。元素的底部边缘将与窗口底部对齐。</li>
</ul>
<p>下面这个按钮会滚动页面，以使其自身定位在窗口顶部：</p>
<p>this.scrollIntoView()</p>
<p>下面这个按钮会滚动页面，以使其自身定位在窗口底部：</p>
<p>this.scrollIntoView(false)</p>
<h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a><a href="https://zh.javascript.info/size-and-scroll-window#zong-jie">总结</a></h2><p>几何：</p>
<ul>
<li><p>文档可见部分的 width/height（内容区域的 width/height）：<code>document.documentElement.clientWidth/clientHeight</code></p>
</li>
<li><p>整个文档的 width/height，其中包括滚动出去的部分：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> scrollHeight <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>
  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>scrollHeight<span class="token punctuation">,</span>
  document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>scrollHeight<span class="token punctuation">,</span>
  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>offsetHeight<span class="token punctuation">,</span>
  document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>offsetHeight<span class="token punctuation">,</span>
  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>clientHeight<span class="token punctuation">,</span>
  document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>clientHeight
<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>滚动：</p>
</li>
<li><p>读取当前的滚动：<code>window.pageYOffset/pageXOffset</code>。</p>
</li>
<li><p>更改当前的滚动：</p>
<ul>
<li><code>window.scrollTo(pageX,pageY)</code> — 绝对坐标，</li>
<li><code>window.scrollBy(x,y)</code> — 相对当前位置进行滚动，</li>
<li><code>elem.scrollIntoView(top)</code> — 滚动以使 <code>elem</code> 可见（<code>elem</code> 与窗口的顶部/底部对齐）。</li>
</ul>
</li>
</ul>
<h1 id="创建自定义事件"><a href="#创建自定义事件" class="headerlink" title="创建自定义事件"></a>创建自定义事件</h1><p>我们不仅可以分配事件处理程序，还可以从 JavaScript 生成事件。</p>
<p>自定义事件可用于创建“图形组件”。</p>
<h2 id="事件构造器"><a href="#事件构造器" class="headerlink" title="事件构造器"></a><a href="https://zh.javascript.info/dispatch-events#shi-jian-gou-zao-qi">事件构造器</a></h2><p>内建事件类形成一个层次结构（hierarchy），类似于 DOM 元素类。根是内建的 <a href="http://www.w3.org/TR/dom/#event">Event</a> 类。</p>
<p>我们可以像这样创建 <code>Event</code> 对象：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> event <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Event</span><span class="token punctuation">(</span>type<span class="token punctuation">[</span><span class="token punctuation">,</span> options<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>参数：</p>
<ul>
<li><p><strong>type</strong> —— 事件类型，可以是像这样 <code>&quot;click&quot;</code> 的字符串，或者我们自己的像这样 <code>&quot;my-event&quot;</code> 的参数。</p>
</li>
<li><p><strong>options</strong> —— 具有两个可选属性的对象：</p>
<ul>
<li><code>bubbles: true/false</code> —— 如果为 <code>true</code>，那么事件会冒泡。</li>
<li><code>cancelable: true/false</code> —— 如果为 <code>true</code>，那么“默认行为”就会被阻止。稍后我们会看到对于自定义事件，它意味着什么。</li>
</ul>
<p>默认情况下，以上两者都为 false：<code>&#123;bubbles: false, cancelable: false&#125;</code>。</p>
</li>
</ul>
<h2 id="dispatchEvent"><a href="#dispatchEvent" class="headerlink" title="dispatchEvent"></a><a href="https://zh.javascript.info/dispatch-events#dispatchevent">dispatchEvent</a></h2><p>事件对象被创建后，我们应该使用 <code>elem.dispatchEvent(event)</code> 调用在元素上“运行”它。</p>
<p>然后，处理程序会对它做出反应，就好像它是一个常规的浏览器事件一样。如果事件是用 <code>bubbles</code> 标志创建的，那么它会冒泡。</p>
<h1 id="表单属性和方法"><a href="#表单属性和方法" class="headerlink" title="表单属性和方法"></a>表单属性和方法</h1><p>表单（form）以及例如 <code>&lt;input&gt;</code> 的控件（control）元素有许多特殊的属性和事件。</p>
<h2 id="导航：表单和元素"><a href="#导航：表单和元素" class="headerlink" title="导航：表单和元素"></a><a href="https://zh.javascript.info/form-elements#dao-hang-biao-dan-he-yuan-su">导航：表单和元素</a></h2><p>文档中的表单是特殊集合 <code>document.forms</code> 的成员。</p>
<p>这就是所谓的“命名的集合”：既是被命名了的，也是有序的。我们既可以使用名字，也可以使用在文档中的编号来获取表单。</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">document<span class="token punctuation">.</span>forms<span class="token punctuation">.</span>my <span class="token operator">-</span> name<span class="token operator">=</span><span class="token string">"my"</span> 的表单
document<span class="token punctuation">.</span>forms<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> 文档中的第一个表单<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>当我们有了一个表单时，其中的任何元素都可以通过命名的集合 <code>form.elements</code> 来获取到。</p>
<h2 id="反向引用：element-form"><a href="#反向引用：element-form" class="headerlink" title="反向引用：element.form"></a><a href="https://zh.javascript.info/form-elements#fan-xiang-yin-yong-elementform">反向引用：element.form</a></h2><p>对于任何元素，其对应的表单都可以通过 <code>element.form</code> 访问到。因此，表单引用了所有元素，元素也引用了表单。</p>
<p>这是一张示意图：</p>
<p><img src="E:\Markdown图片\image-20210221110537095.png" alt="image-20210221110537095"></p>
<h2 id="表单元素"><a href="#表单元素" class="headerlink" title="表单元素"></a><a href="https://zh.javascript.info/form-elements#biao-dan-yuan-su">表单元素</a></h2><p>让我们来谈谈表单控件。</p>
<h3 id="input-和-textarea"><a href="#input-和-textarea" class="headerlink" title="input 和 textarea"></a><a href="https://zh.javascript.info/form-elements#input-he-textarea">input 和 textarea</a></h3><p>我们可以通过 <code>input.value</code>（字符串）或 <code>input.checked</code>（布尔值）来访问复选框（checkbox）中的它们的 <code>value</code>。</p>
]]></content>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>javaScript学习笔记</title>
    <url>/2021/02/06/javaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h1><h2 id="对象引用和复制"><a href="#对象引用和复制" class="headerlink" title="对象引用和复制"></a>对象引用和复制</h2><p>与原始类型相比，对象的根本区别之一是对象是“通过引用”被存储和复制的，与原始类型值相反：字符串，数字，布尔值等 —— 始终是以“整体值”的形式被复制的。</p>
<a id="more"></a>

<h3 id="克隆与合并，Object-assign"><a href="#克隆与合并，Object-assign" class="headerlink" title="克隆与合并，Object.assign"></a>克隆与合并，Object.assign</h3><p>Object.assign(dest, [src1, src2, src3…])</p>
<ul>
<li>第一个参数 dest 是指目标对象。</li>
<li>更后面的参数 src1, …, srcN（可按需传递多个参数）是源对象。</li>
<li>该方法将所有源对象的属性拷贝到目标对象 dest 中。换句话说，从第二个开始的所有参数的属性都被拷贝到第一个参数的对象中。</li>
<li>调用结果返回 dest。</li>
<li>可以用它来合并多个对象</li>
</ul>
<p>​ 对象方法,”this”</p>
<ul>
<li>对象方法的调用时基于“引用类型”的调用</li>
</ul>
<h3 id="Symbol-类型"><a href="#Symbol-类型" class="headerlink" title="Symbol 类型"></a>Symbol 类型</h3><pre><code>  1. 防止自己在对象中写的属性被其他人篡改，隐藏该属性
  2. 用for..in.., Object.keys(obj)访问不到，但是使用Object.assign是可以复制过来的</code></pre>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><pre><code>  1. 对象是具有一些特殊特性的关联数组。
  2. 它们存储属性（键值对），其中：
       1. 属性的键必须是字符串或者 symbol（通常是字符串）。
       2. 值可以是任何类型。
  3. 下面的方法访问属性
       1. 点符号: obj.property。
       2. 方括号 obj[&quot;property&quot;]，方括号允许从变量中获取键，例如 obj[varWithKey]。
  4. 其他操作：
       1. 删除属性：delete obj.prop。
       2. 检查是否存在给定键的属性：&quot;key&quot; in obj。
       3. 遍历对象：for(let key in obj) 循环。</code></pre>
<h3 id="原始类型的方法"><a href="#原始类型的方法" class="headerlink" title="原始类型的方法"></a>原始类型的方法</h3><ul>
<li>基本类型不是对象。</li>
<li>基本类型不能存储数据。</li>
<li>所有的属性/方法操作都是在临时对象的帮助下执行的。</li>
</ul>
<h3 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h3><p>​ parseInt(str, radix)` 的第二个参数</p>
<ul>
<li>parseInt() 函数具有可选的第二个参数。它指定了数字系统的基数，因此 parseInt 还可以解析十六进制数字、二进制数字等的字符串：</li>
<li>alert( parseInt(‘0xff’, 16) ); // 255</li>
<li>alert( parseInt(‘ff’, 16) ); // 255，没有 0x 仍然有效</li>
<li>alert( parseInt(‘2n9c’, 36) ); // 123456</li>
</ul>
<p>​ prompt</p>
<ul>
<li>注意在 prompt 前面的一元加号 +。它将立即把值转换成数字。</li>
<li>否则，a 和 b 将会是字符串，它们的总和将是它们的连接，即：”1” + “2” = “12”。</li>
</ul>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="str"><a href="#str" class="headerlink" title="str"></a>str</h3><h3 id="1-str-indexOf-substr-pos-。"><a href="#1-str-indexOf-substr-pos-。" class="headerlink" title="1. str.indexOf(substr, pos)。"></a>1. str.indexOf(substr, pos)。</h3><p>​ 1. 它从给定位置 pos 开始，在 str 中查找 substr，如果没有找到，则返回 -1，否则返回匹配成功的位置。<br>​ 2. 还有一个类似的方法 str.lastIndexOf(substr, position)，它从字符串的末尾开始搜索到开头。</p>
<h3 id="2-按位（bitwise）NOT-技巧"><a href="#2-按位（bitwise）NOT-技巧" class="headerlink" title="2. 按位（bitwise）NOT 技巧"></a>2. 按位（bitwise）NOT 技巧</h3><p>​ 1. 它将数字转换为 32-bit 整数（如果存在小数部分，则删除小数部分），然后对其二进制表示形式中的所有位均取反。</p>
<h3 id="3-获取子字符串"><a href="#3-获取子字符串" class="headerlink" title="3. 获取子字符串"></a>3. 获取子字符串</h3><pre><code> 1.  JavaScript 中有三种获取字符串的方法：substring、substr 和 slice。
             1.  str.slice(start [, end])，返回字符串从 start 到（但不包括）end 的部分。
             2.  如果没有第二个参数，slice 会一直运行到字符串末尾：
                    1.  let str = &quot;stringify&quot;;
                               alert( str.slice(0, 5) ); // &#39;strin&#39;，从 0 到 5 的子字符串（不包括 5）
                               alert( str.slice(0, 1) ); // &#39;s&#39;，从 0 到 1，但不包括 1，所以只有在 0 处的字符
                               let str = &quot;stringify&quot;;
                               alert( str.slice(2) ); // 从第二个位置直到结束
                       2.  str.substring(start [, end])返回字符串在 start 和 end 之间 的部分。这与 slice 几乎相同，但它允许 start 大于 end。
                               et str = &quot;stringify&quot;;
                                      // 这些对于 substring 是相同的
                                      alert( str.substring(2, 6) ); // &quot;ring&quot;
                                      alert( str.substring(6, 2) ); // &quot;ring&quot;
                                      // ……但对 slice 是不同的：
                                      alert( str.slice(2, 6) ); // &quot;ring&quot;（一样）
                                      alert( str.slice(6, 2) ); // &quot;&quot;（空字符串）
           3.  str.substr(start [, length]) 返回字符串从 start 开始的给定 length 的部分。与以前的方法相比，这个允许我们指定 length 而不是结束位置：
                   . let str = &quot;stringify&quot;;
                          alert( str.substr(2, 4) ); // &#39;ring&#39;，从位置 2 开始，获取 4 个字符
                          2. 第一个参数可能是负数，从结尾算起：
                                 let str = &quot;stringify&quot;;
                                 alert( str.substr(-4, 2) ); // &#39;gi&#39;，从第 4 位获取 2 个字符</code></pre>
<p>​ 方法 选择方式…… 负值参数<br>​ - slice(start, end) 从 start 到 end（不含 end） 允许<br>​ - substring(start, end) start 与 end 之间（包括 start，但不包括 end） 负值代表 0<br>​ - substr(start, length) 从 start 开始获取长为 length 的字符串 允许 start 为负数</p>
<p>​</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul>
<li>数组, 声明, pop/push, shift/unshift 方法, 内部, 性能, 循环, 关于 “length”, new Array(), 多维数组, toString, 不要使用 == 比较数组</li>
</ul>
<p>​ Iterable object（可迭代对象）</p>
<ul>
<li>可迭代（Iterable） 对象是数组的泛化。这个概念是说任何对象都可以被定制为可在 for..of 循环中使用的对象。</li>
</ul>
<h2 id="Map-and-Set（映射和集合）"><a href="#Map-and-Set（映射和集合）" class="headerlink" title="Map and Set（映射和集合）"></a>Map and Set（映射和集合）</h2><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><ul>
<li>Map 是一个带键的数据项的集合，就像一个 Object 一样。 但是它们最大的差别是 Map 允许任何类型的键（key）。</li>
</ul>
<p>它的方法和属性如下：</p>
<ul>
<li>new Map() —— 创建 map。</li>
<li>map.set(key, value) —— 根据键存储值。</li>
<li>map.get(key) —— 根据键来返回值，如果 map 中不存在对应的 key，则返回 undefined。</li>
<li>map.has(key) —— 如果 key 存在则返回 true，否则返回 false。</li>
<li>map.delete(key) —— 删除指定键的值。</li>
<li>map.clear() —— 清空 map。</li>
<li>map.size —— 返回当前元素个数。</li>
</ul>
<h3 id="Map-迭代"><a href="#Map-迭代" class="headerlink" title="Map 迭代"></a>Map 迭代</h3><p>如果要在 map 里使用循环，可以使用以下三个方法：</p>
<ul>
<li>map.keys() —— 遍历并返回所有的键（returns an iterable for keys），</li>
<li>map.values() —— 遍历并返回所有的值（returns an iterable for values），</li>
<li>map.entries() —— 遍历并返回所有的实体（returns an iterable for entries）[key, value]，for..of 在默认情况下使用的就是这个。</li>
</ul>
<h3 id="Object-entries：从对象创建-Map"><a href="#Object-entries：从对象创建-Map" class="headerlink" title="Object.entries：从对象创建 Map"></a>Object.entries：从对象创建 Map</h3><p>如果我们想从一个已有的普通对象（plain object）来创建一个 Map，那么我们可以使用内建方法 Object.entries(obj)，该返回对象的键/值对数组，该数组格式完全按照 Map 所需的格式。</p>
<h3 id="Object-fromEntries：从-Map-创建对象"><a href="#Object-fromEntries：从-Map-创建对象" class="headerlink" title="Object.fromEntries：从 Map 创建对象"></a>Object.fromEntries：从 Map 创建对象</h3><p>Object.fromEntries 方法的作用是相反的：给定一个具有 [key, value] 键值对的数组，它会根据给定数组创建一个对象：</p>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>Set 是一个特殊的类型集合 —— “值的集合”（没有键），它的每一个值只能出现一次。</p>
<p>它的主要方法如下：</p>
<ul>
<li>new Set(iterable) —— 创建一个 set，如果提供了一个 iterable 对象（通常是数组），将会从数组里面复制值到 set 中。</li>
<li>set.add(value) —— 添加一个值，返回 set 本身</li>
<li>set.delete(value) —— 删除值，如果 value 在这个方法调用的时候存在则返回 true ，否则返回 false。</li>
<li>set.has(value) —— 如果 value 在 set 中，返回 true，否则返回 false。</li>
<li>set.clear() —— 清空 set。</li>
<li>set.size —— 返回元素个数。</li>
</ul>
<p>Map 中用于迭代的方法在 Set 中也同样支持：</p>
<ul>
<li>set.keys() —— 遍历并返回所有的值（returns an iterable object for values），</li>
<li>set.values() —— 与 set.keys() 作用相同，这是为了兼容 Map，</li>
<li>set.entries() —— 遍历并返回所有的实体（returns an iterable object for entries）[value, value]，它的存在也是为了兼容 Map。</li>
</ul>
<h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><p>解构赋值 是一种特殊的语法，它使我们可以将数组或对象“拆包”为到一系列变量中，因为有时候使用变量更加方便。解构操作对那些具有很多参数和默认值等的函数也很奏效。<br>解构赋值, 数组解构, 对象解构, 嵌套解构, 智能函数参数</p>
<ul>
<li>解构赋值可以立即将一个对象或数组映射到多个变量上。</li>
<li>解构对象的完整语法：<ul>
<li>let {prop : varName = default, …rest} = object</li>
<li>这表示属性 prop 会被赋值给变量 varName，如果没有这个属性的话，就会使用默认值 default。</li>
<li>没有对应映射的对象属性会被复制到 rest 对象。</li>
</ul>
</li>
<li>解构数组的完整语法：<ul>
<li>let [item1 = default, item2, …rest] = array</li>
<li>数组的第一个元素被赋值给 item1，第二个元素被赋值给 item2，剩下的所有元素被复制到另一个数组 rest。</li>
</ul>
</li>
<li>从嵌套数组/对象中提取数据也是可以的，此时等号左侧必须和等号右侧有相同的结构。</li>
</ul>
<h2 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h2><p>该对象存储日期和时间，并提供了日期/时间的管理方法。<br>例如，我们可以使用它来存储创建/修改时间，或者用来测量时间，再或者仅用来打印当前时间。</p>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>创建一个新的 Date 对象，只需要调用 new Date()，在调用时可以带有下面这些参数之一：</p>
<ul>
<li><p>new Date()</p>
<ul>
<li>不带参数 —— 创建一个表示当前日期和时间的 Date 对象：<ul>
<li>let now = new Date();</li>
</ul>
</li>
</ul>
</li>
<li><p>new Date(milliseconds)</p>
<ul>
<li>创建一个 Date 对象，其时间等于 1970-01-01 00:00:00 UTC+0 再过一毫秒（1/1000 秒）。</li>
<li>传入的整数参数代表的是自 1970-01-01 00:00:00 以来经过的毫秒数，该整数被称为 时间戳。</li>
<li>这是一种日期的轻量级数字表示形式。我们通常使用 new Date(timestamp) 通过时间戳来创建日期，并可以使用 date.getTime() 将现有的 Date 对象转化为时间戳。</li>
</ul>
</li>
<li><p>new Date(datestring)</p>
<ul>
<li>如果只有一个参数，并且是字符串，那么它会被自动解析。该算法与 Date.parse 所使用的算法相同</li>
</ul>
</li>
<li><p>new Date(year, month, date, hours, minutes, seconds, ms)</p>
<ul>
<li>使用当前时区中的给定组件创建日期。只有前两个参数是必须的。</li>
<li>自动校准（Autocorrection）</li>
</ul>
</li>
</ul>
<p>自动校准 是 Date 对象的一个非常方便的特性。我们可以设置超范围的数值，它会自动校准。<br>超出范围的日期组件将会被自动分配。</p>
<h2 id="JSON-方法，toJSON"><a href="#JSON-方法，toJSON" class="headerlink" title="JSON 方法，toJSON"></a>JSON 方法，toJSON</h2><p>假设我们有一个复杂的对象，我们希望将其转换为字符串，以通过网络发送，或者只是为了在日志中输出它。</p>
<p>当然，这样的字符串应该包含所有重要的属性。</p>
<h3 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify"></a>JSON.stringify</h3><p>JSON（JavaScript Object Notation）是表示值和对象的通用格式。在 RFC 4627 标准中有对其的描述。最初它是为 JavaScript 而创建的，但许多其他编程语言也有用于处理它的库。因此，当客户端使用 JavaScript 而服务器端是使用 Ruby/PHP/Java 等语言编写的时，使用 JSON 可以很容易地进行数据交换。</p>
<p>JavaScript 提供了如下方法：</p>
<ul>
<li>JSON.stringify 将对象转换为 JSON。</li>
<li>JSON.parse 将 JSON 转换回对象。</li>
</ul>
<p>方法 JSON.stringify(student) 接收对象并将其转换为字符串。<br>得到的 json 字符串是一个被称为 JSON 编码（JSON-encoded） 或 序列化（serialized） 或 字符串化（stringified） 或 编组化（marshalled） 的对象。</p>
<p>请注意，JSON 编码的对象与对象字面量有几个重要的区别：:</p>
<ul>
<li>字符串使用双引号。JSON 中没有单引号或反引号。所以 ‘John’ 被转换为 “John”。</li>
<li>对象属性名称也是双引号的。这是强制性的。所以 age:30 被转换成 “age”:30。</li>
</ul>
<p>JSON.stringify 也可以应用于原始（primitive）数据类型。<br>JSON 支持以下数据类型：</p>
<ul>
<li>Objects { … }</li>
<li>Arrays [ … ]</li>
<li>Primitives：<ul>
<li>strings，</li>
<li>numbers，</li>
<li>boolean values true/false，</li>
<li>null。</li>
</ul>
</li>
</ul>
<p>JSON 是语言无关的纯数据规范，因此一些特定于 JavaScript 的对象属性会被 JSON.stringify 跳过。<br>即：</p>
<ul>
<li>函数属性（方法）。</li>
<li>Symbol 类型的属性。</li>
<li>存储 undefined 的属性。</li>
</ul>
<p>​ 排除和转换：replacer</p>
<p>JSON.stringify 的完整语法是：<br>let json = JSON.stringify(value, [replacer, space])<br> value<br>要编码的值。<br>replacer<br>要编码的属性数组或映射函数 function(key, value)。<br>space<br>用于格式化的空格数量</p>
<h2 id="Rest-参数与-Spread-语法"><a href="#Rest-参数与-Spread-语法" class="headerlink" title="Rest 参数与 Spread 语法"></a>Rest 参数与 Spread 语法</h2><p>在 JavaScript 中，很多内建函数都支持传入任意数量的参数。<br>例如：</p>
<ul>
<li>Math.max(arg1, arg2, …, argN) —— 返回入参中的最大值。</li>
<li>Object.assign(dest, src1, …, srcN) —— 依次将属性从 src1..N 复制到 dest。</li>
</ul>
<h3 id="Rest-参数-…"><a href="#Rest-参数-…" class="headerlink" title="Rest 参数 …"></a>Rest 参数 …</h3><p>在 JavaScript 中，无论函数是如何定义的，你都可以使用任意数量的参数调用函数。<br>Rest 参数可以通过使用三个点 … 并在后面跟着包含剩余参数的数组名称，来将它们包含在函数定义中。这些点的字面意思是“将剩余参数收集到一个数组中”。<br>Rest 参数必须放到参数列表的末尾<br>Rest 参数会收集剩余的所有参数，因此下面这种用法没有意义，并且会导致错误：<br>function f(arg1, …rest, arg2) { // arg2 在 …rest 后面？！<br>// error<br>}<br>…rest 必须处在最后。</p>
<p>​ “arguments” 变量</p>
<p>有一个名为 arguments 的特殊的类数组对象，该对象按参数索引包含所有参数。</p>
<p>在过去，JavaScript 中没有 rest 参数，而使用 arguments 是获取函数所有参数的唯一方法。现在它仍然有效，我们可以在一些老代码里找到它。</p>
<p>但缺点是，尽管 arguments 是一个类数组，也是可迭代对象，但它终究不是数组。它不支持数组方法，因此我们不能调用 arguments.map(…) 等方法。</p>
<p>此外，它始终包含所有参数，我们不能像使用 rest 参数那样只截取入参的一部分。</p>
<p>因此，当我们需要这些功能时，最好使用 rest 参数。</p>
<h3 id="Spread-语法"><a href="#Spread-语法" class="headerlink" title="Spread 语法"></a>Spread 语法</h3><p>在脚本执行时，可能参数数组中有很多个元素，也可能一个都没有。并且这样设置的代码也很丑。<br>Spread 语法 来帮助你了！它看起来和 rest 参数很像，也使用 …，但是二者的用途完全相反。<br>当在函数调用中使用 …arr 时，它会把可迭代对象 arr “展开”到参数列表中。</p>
<p>以 Math.max 为例：</p>
<pre><code>  1. - let arr = [3, 5, 1];
  2. - alert( Math.max(...arr) ); // 5（spread 语法把数组转换为参数列表）</code></pre>
<p>我们还可以通过这种方式传递多个可迭代对象：</p>
<pre><code>  1. let arr1 = [1, -2, 3, 4];
  2. let arr2 = [8, 3, -8, 1];
  3.
  4. alert( Math.max(...arr1, ...arr2) ); // 8</code></pre>
<p>我们甚至还可以将 spread 语法与常规值结合使用：</p>
<pre><code>  1. let arr1 = [1, -2, 3, 4];
  2. let arr2 = [8, 3, -8, 1];
  3.
  4. alert( Math.max(1, ...arr1, 2, ...arr2, 25) ); // 25</code></pre>
<p>并且，我们还可以使用 spread 语法来合并数组：</p>
<pre><code>  1. let arr = [3, 5, 1];
  2. let arr2 = [8, 9, 15];
  3.
  4. let merged = [0, ...arr, 2, ...arr2];
  5.
  6. alert(merged); // 0,3,5,1,2,8,9,15（0，然后是 arr，然后是 2，然后是 arr2）</code></pre>
<p>在上面的示例中，我们使用数组展示了 spread 语法，其实任何可迭代对象都可以。</p>
<p>例如，在这儿我们使用 spread 语法将字符串转换为字符数组：</p>
<ul>
<li>let str = “Hello”;</li>
<li>alert( […str] ); // H,e,l,l,o<br>Spread 语法内部使用了迭代器来收集元素，与 for..of 的方式相同</li>
</ul>
<p>不过 Array.from(obj) 和 […obj] 存在一个细微的差别：</p>
<ul>
<li>Array.from 适用于类数组对象也适用于可迭代对象。</li>
<li>Spread 语法只适用于可迭代对象。<br>因此，对于将一些“东西”转换为数组的任务，Array.from 往往更通用。</li>
</ul>
<p>​ 总结<br> 当我们在代码中看到 “…” 时，它要么是 rest 参数，要么就是 spread 语法。</p>
<p>有一个简单的方法可以区分它们：</p>
<ul>
<li><p>若 … 出现在函数参数列表的最后，那么它就是 rest 参数，它会把参数列表中剩余的参数收集到一个数组中。</p>
</li>
<li><p>若 … 出现在函数调用或类似的表达式中，那它就是 spread 语法，它会把一个数组展开为列表。</p>
</li>
<li><p>使用场景：</p>
</li>
<li><p>Rest 参数用于创建可接受任意数量参数的函数。</p>
</li>
<li><p>Spread 语法用于将数组传递给通常需要含有许多参数的列表的函数。<br>它们俩的出现帮助我们轻松地在列表和参数数组之间来回转换。</p>
</li>
</ul>
<p>“旧式”的 arguments（类数组且可迭代的对象）也依然能够帮助我们获取函数调用中的所有参数。</p>
<h2 id="变量作用域，闭包"><a href="#变量作用域，闭包" class="headerlink" title="变量作用域，闭包"></a>变量作用域，闭包</h2><h3 id="Step-1-变量"><a href="#Step-1-变量" class="headerlink" title="Step 1. 变量"></a>Step 1. 变量</h3><p>在 JavaScript 中，每个运行的函数，代码块 {…} 以及整个脚本，都有一个被称为 词法环境（Lexical Environment） 的内部（隐藏）的关联对象。</p>
<p>词法环境对象由两部分组成：</p>
<pre><code>  1. 环境记录（Environment Record） —— 一个存储所有局部变量作为其属性（包括一些其他信息，例如 this 的值）的对象。
  2. 对 外部词法环境 的引用，与外部代码相关联。</code></pre>
<p>一个“变量”只是 环境记录 这个特殊的内部对象的一个属性。“获取或修改变量”意味着“获取或修改词法环境的一个属性”。</p>
<ul>
<li>变量是特殊内部对象的属性，与当前正在执行的（代码）块/函数/脚本有关。</li>
<li>操作变量实际上是操作该对象的属性。</li>
</ul>
<h3 id="Step-2-函数声明"><a href="#Step-2-函数声明" class="headerlink" title="Step 2. 函数声明"></a>Step 2. 函数声明</h3><p>一个函数其实也是一个值，就像变量一样。</p>
<p><strong>* *不同之处在于函数声明的初始化会被立即完成。 **</strong></p>
<p>当创建了一个词法环境（Lexical Environment）时，函数声明会立即变为即用型函数（不像 let 那样直到声明处才可用）。</p>
<h3 id="Step-3-内部和外部的词法环境"><a href="#Step-3-内部和外部的词法环境" class="headerlink" title="Step 3. 内部和外部的词法环境"></a>Step 3. 内部和外部的词法环境</h3><p>在一个函数运行时，在调用刚开始时，会自动创建一个新的词法环境以存储这个调用的局部变量和参数。</p>
<p><strong>* *当代码要访问一个变量时 —— 首先会搜索内部词法环境，然后搜索外部环境，然后搜索更外部的环境，以此类推，直到全局词法环境。 **</strong></p>
<p>如果在任何地方都找不到这个变量，那么在严格模式下就会报错（在非严格模式下，为了向下兼容，给未定义的变量赋值会创建一个全局变量）。</p>
<h3 id="Step-4-返回函数"><a href="#Step-4-返回函数" class="headerlink" title="Step 4. 返回函数"></a>Step 4. 返回函数</h3><p>所有的函数在“诞生”时都会记住创建它们的词法环境。从技术上讲，这里没有什么魔法：所有函数都有名为 [[Environment]] 的隐藏属性，该属性保存了对创建该函数的词法环境的引用。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a><strong>闭包</strong></h3><p>开发者通常应该都知道“闭包”这个通用的编程术语。</p>
<p><a href="https://en.wikipedia.org/wiki/Closure_(computer_programming)">闭包</a> 是指内部函数总是可以访问其所在的外部函数中声明的变量和参数，即使在其外部函数被返回（寿命终结）了之后。</p>
<p>也就是说：JavaScript 中的函数会自动通过隐藏的 <code>[[Environment]]</code> 属性记住创建它们的位置，所以它们都可以访问外部变量。</p>
<p>在面试时，前端开发者通常会被问到“什么是闭包？”，正确的回答应该是闭包的定义，并解释清楚为什么 JavaScript 中的所有函数都是闭包的，以及可能的关于 <code>[[Environment]]</code> 属性和词法环境原理的技术细节。</p>
<h3 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a><strong>垃圾收集</strong></h3><p>通常，函数调用完成后，会将词法环境和其中的所有变量从内存中删除。因为现在没有任何对它们的引用了。与 JavaScript 中的任何其他对象一样，词法环境仅在可达时才会被保留在内存中。</p>
<p>但是，如果有一个嵌套的函数在函数结束后仍可达，则它将具有引用词法环境的 <code>[[Environment]]</code> 属性。</p>
<h3 id="实际开发中的优化"><a href="#实际开发中的优化" class="headerlink" title="实际开发中的优化"></a>实际开发中的优化</h3><p>正如我们所看到的，理论上当函数可达时，它外部的所有变量也都将存在。</p>
<p>但在实际中，JavaScript 引擎会试图优化它。它们会分析变量的使用情况，如果从代码中可以明显看出有未使用的外部变量，那么就会将其删除。</p>
<p><strong>在 V8（Chrome，Edge，Opera）中的一个重要的副作用是，此类变量在调试中将不可用。</strong></p>
<h1 id="函数对象-NFE"><a href="#函数对象-NFE" class="headerlink" title="函数对象, NFE"></a>函数对象, NFE</h1><p>在 JavaScript 中，函数就是对象。</p>
<h2 id="属性-“name”"><a href="#属性-“name”" class="headerlink" title="属性 “name”"></a>属性 “name”</h2><p>函数对象包含一些便于使用的属性。</p>
<ol>
<li><p>一个函数的名字可以通过属性 “name” 来访问。</p>
</li>
<li><p>名称赋值的逻辑很智能。即使函数被创建时没有名字，名称赋值的逻辑也能给它赋予一个正确的名字，然后进行赋值。</p>
</li>
<li><p>以默认值的方式完成了赋值时，它也有效。</p>
</li>
<li><p>如果函数自己没有提供，那么在赋值中，会根据上下文来推测一个。</p>
<p>对象方法也有名字，</p>
</li>
</ol>
<h2 id="属性-“length”"><a href="#属性-“length”" class="headerlink" title="属性 “length”"></a>属性 “length”</h2><p>内置属性 “length”，它返回函数入参的个数</p>
<p>属性 <code>length</code> 有时在操作其它函数的函数中用于做 <a href="https://zh.wikipedia.org/wiki/%E5%86%85%E7%9C%81_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">内省/运行时检查（introspection）</a>。</p>
<h2 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h2><p><strong>属性不是变量</strong></p>
<p>被赋值给函数的属性，比如 <code>sayHi.counter = 0</code>，<strong>不会</strong> 在函数内定义一个局部变量 <code>counter</code>。换句话说，属性 <code>counter</code> 和变量 <code>let counter</code> 是毫不相关的两个东西。</p>
<p>我们可以把函数当作对象，在它里面存储属性，但是这对它的执行没有任何影响。变量不是函数属性，反之亦然。它们之间是平行的。</p>
<h2 id="命名函数表达式"><a href="#命名函数表达式" class="headerlink" title="命名函数表达式"></a>命名函数表达式</h2><p>命名函数表达式（NFE，Named Function Expression），指带有名字的函数表达式的术语。</p>
<pre class="line-numbers language-none"><code class="language-none">let sayHi &#x3D; function func(who) &#123;
  alert(&#96;Hello, $&#123;who&#125;&#96;);
&#125;;

sayHi(&quot;John&quot;); &#x2F;&#x2F; Hello, John<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>关于名字 <code>func</code> 有两个特殊的地方，这就是添加它的原因：</p>
<ol>
<li>它允许函数在内部引用自己。</li>
<li>它在函数外是不可见的。</li>
</ol>
<p>下面的函数 <code>sayHi</code> 会在没有入参 <code>who</code> 时，以 <code>&quot;Guest&quot;</code> 为入参调用自己：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> <span class="token function-variable function">sayHi</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token parameter">who</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>who<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hello, </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>who<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
    <span class="token function">func</span><span class="token punctuation">(</span><span class="token string">'Guest'</span><span class="token punctuation">)</span> <span class="token comment">// 使用 func 再次调用函数自身</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// Hello, Guest</span>
<span class="token comment">// 但这不工作：</span>
<span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// Error, func is not defined（在函数外不可见）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="问题（待解决）"><a href="#问题（待解决）" class="headerlink" title="问题（待解决）"></a>问题（待解决）</h2><h3 id="任意数量的括号求和"><a href="#任意数量的括号求和" class="headerlink" title="任意数量的括号求和"></a><a href="https://zh.javascript.info/function-object#ren-yi-shu-liang-de-kuo-hao-qiu-he">任意数量的括号求和</a></h3><p>重要程度: 2</p>
<p>写一个函数 <code>sum</code>，它有这样的功能：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">3</span> <span class="token comment">// 1 + 2</span>
<span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">6</span> <span class="token comment">// 1 + 2 + 3</span>
<span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">6</span>
<span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span>
<span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">15</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>P.S. 提示：你可能需要创建自定义对象来为你的函数提供基本类型转换。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a href="https://zh.javascript.info/function-object#zong-jie">总结</a></h2><p>函数就是对象。</p>
<p>它们的一些属性：</p>
<ul>
<li><code>name</code> —— 函数的名字。通常取自函数定义，但如果函数定义时没设定函数名，JavaScript 会尝试通过函数的上下文猜一个函数名（例如把赋值的变量名取为函数名）。</li>
<li><code>length</code> —— 函数定义时的入参的个数。Rest 参数不参与计数。</li>
</ul>
<h1 id="调度：setTimeout-和-setInterval"><a href="#调度：setTimeout-和-setInterval" class="headerlink" title="调度：setTimeout 和 setInterval"></a>调度：setTimeout 和 setInterval</h1><p>有时我们并不想立即执行一个函数，而是等待特定一段时间之后再执行。这就是所谓的“计划调用（scheduling a call）”。</p>
<p>目前有两种方式可以实现：</p>
<ul>
<li><code>setTimeout</code> 允许我们将函数推迟到一段时间间隔之后再执行。</li>
<li><code>setInterval</code> 允许我们重复运行一个函数，从一段时间间隔之后开始运行，之后以该时间间隔连续重复运行该函数。</li>
</ul>
<p>这两个方法并不在 JavaScript 的规范中。但是大多数运行环境都有内建的调度程序，并且提供了这些方法。目前来讲，所有浏览器以及 Node.js 都支持这两个方法。</p>
<h2 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h2><p>语法：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> timerId <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>func<span class="token operator">|</span>code<span class="token punctuation">,</span> <span class="token punctuation">[</span>delay<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>arg1<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>arg2<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">...</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>参数说明：</p>
<ul>
<li><p><code>func|code</code></p>
<p>想要执行的函数或代码字符串。 一般传入的都是函数。由于某些历史原因，支持传入代码字符串，但是不建议这样做。</p>
</li>
<li><p><code>delay</code></p>
<p>执行前的延时，以毫秒为单位（1000 毫秒 = 1 秒），默认值是 0；</p>
</li>
<li><p><code>arg1</code>，<code>arg2</code>…</p>
<p>要传入被执行函数（或代码字符串）的参数列表（IE9 以下不支持）</p>
</li>
</ul>
<h2 id="嵌套的-setTimeout"><a href="#嵌套的-setTimeout" class="headerlink" title="嵌套的 setTimeout"></a><a href="https://zh.javascript.info/settimeout-setinterval#qian-tao-de-settimeout">嵌套的 setTimeout</a></h2><p>周期性调度有两种方式。</p>
<p>一种是使用 <code>setInterval</code>，另外一种就是嵌套的 <code>setTimeout</code>，就像这样：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">/** instead of:
let timerId = setInterval(() => alert('tick'), 2000);
*/</span>

<span class="token keyword">let</span> timerId <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">tick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'tick'</span><span class="token punctuation">)</span>
  timerId <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>tick<span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span> <span class="token comment">// (*)</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面这个 <code>setTimeout</code> 在当前这一次函数执行完时 <code>(*)</code> 立即调度下一次调用。</p>
<p>嵌套的 <code>setTimeout</code> 要比 <code>setInterval</code> 灵活得多。采用这种方式可以根据当前执行结果来调度下一次调用，因此下一次调用可以与当前这一次不同。</p>
<p><strong>传入一个函数，但不要执行它</strong></p>
<p>新手开发者有时候会误将一对括号 <code>()</code> 加在函数后面：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 错的！</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这样不行，因为 <code>setTimeout</code> 期望得到一个对函数的引用。而这里的 <code>sayHi()</code> 很明显是在执行函数，所以实际上传入 <code>setTimeout</code> 的是 <strong>函数的执行结果</strong>。在这个例子中，<code>sayHi()</code> 的执行结果是 <code>undefined</code>（也就是说函数没有返回任何结果），所以实际上什么也没有调度。</p>
<h3 id="用-clearTimeout-来取消调度"><a href="#用-clearTimeout-来取消调度" class="headerlink" title="用 clearTimeout 来取消调度"></a><a href="https://zh.javascript.info/settimeout-setinterval#yong-cleartimeout-lai-qu-xiao-tiao-du">用 clearTimeout 来取消调度</a></h3><p><code>setTimeout</code> 在调用时会返回一个“定时器标识符（timer identifier）”，在我们的例子中是 <code>timerId</code>，我们可以使用它来取消执行。</p>
<p>取消调度的语法：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> timerId <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">clearTimeout</span><span class="token punctuation">(</span>timerId<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval"></a><a href="https://zh.javascript.info/settimeout-setinterval#setinterval">setInterval</a></h2><p><code>setInterval</code> 方法和 <code>setTimeout</code> 的语法相同：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> timerId <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span>func<span class="token operator">|</span>code<span class="token punctuation">,</span> <span class="token punctuation">[</span>delay<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>arg1<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>arg2<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">...</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>所有参数的意义也是相同的。不过与 <code>setTimeout</code> 只执行一次不同，<code>setInterval</code> 是每间隔给定的时间周期性执行。</p>
<p>想要阻止后续调用，我们需要调用 <code>clearInterval(timerId)</code>。</p>
<p><strong>alert 弹窗显示的时候计时器依然在进行计时</strong></p>
<p>在大多数浏览器中，包括 Chrome 和 Firefox，在显示 <code>alert/confirm/prompt</code> 弹窗时，内部的定时器仍旧会继续“嘀嗒”。</p>
<p>所以，在运行上面的代码时，如果在一定时间内没有关掉 <code>alert</code> 弹窗，那么在你关闭弹窗后，下一个 <code>alert</code> 会立即显示。两次 <code>alert</code> 之间的时间间隔将小于 2 秒。</p>
<p><strong>嵌套的 <code>setTimeout</code> 能够精确地设置两次执行之间的延时，而 <code>setInterval</code> 却不能。</strong></p>
<h2 id="零延时的-setTimeout"><a href="#零延时的-setTimeout" class="headerlink" title="零延时的 setTimeout"></a><a href="https://zh.javascript.info/settimeout-setinterval#ling-yan-shi-de-settimeout">零延时的 setTimeout</a></h2><p>这儿有一种特殊的用法：<code>setTimeout(func, 0)</code>，或者仅仅是 <code>setTimeout(func)</code>。</p>
<p>这样调度可以让 <code>func</code> 尽快执行。但是只有在当前正在执行的脚本执行完成后，调度程序才会调用它。</p>
<p>也就是说，该函数被调度在当前脚本执行完成“之后”立即执行。</p>
<p>例如，下面这段代码会先输出 “Hello”，然后立即输出 “World”：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'World'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'Hello'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>第一行代码“将调用安排到日程（calendar）0 毫秒处”。但是调度程序只有在当前脚本执行完毕时才会去“检查日程”，所以先输出 <code>&quot;Hello&quot;</code>，然后才输出 <code>&quot;World&quot;</code>。</p>
<p><strong>零延时实际上不为零（在浏览器中）</strong></p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><a href="https://zh.javascript.info/settimeout-setinterval#zong-jie">总结</a></h2><ul>
<li><code>setTimeout(func, delay, ...args)</code> 和 <code>setInterval(func, delay, ...args)</code> 方法允许我们在 <code>delay</code> 毫秒之后运行 <code>func</code> 一次或以 <code>delay</code> 毫秒为时间间隔周期性运行 <code>func</code>。</li>
<li>要取消函数的执行，我们应该调用 <code>clearInterval/clearTimeout</code>，并将 <code>setInterval/setTimeout</code> 返回的值作为入参传入。</li>
<li>嵌套的 <code>setTimeout</code> 比 <code>setInterval</code> 用起来更加灵活，允许我们更精确地设置两次执行之间的时间。</li>
<li>零延时调度 <code>setTimeout(func, 0)</code>（与 <code>setTimeout(func)</code> 相同）用来调度需要尽快执行的调用，但是会在当前脚本执行完成后进行调用。</li>
<li>浏览器会将 <code>setTimeout</code> 或 <code>setInterval</code> 的五层或更多层嵌套调用（调用五次之后）的最小延时限制在 4ms。这是历史遗留问题。</li>
</ul>
<h1 id="函数绑定"><a href="#函数绑定" class="headerlink" title="函数绑定"></a>函数绑定</h1><p>当将对象方法作为回调进行传递，例如传递给 <code>setTimeout</code>，这儿会存在一个常见的问题：“丢失 <code>this</code>”。</p>
<h2 id="丢失-“this”"><a href="#丢失-“this”" class="headerlink" title="丢失 “this”"></a><a href="https://zh.javascript.info/bind#diu-shi-this">丢失 “this”</a></h2><p>下面是使用 <code>setTimeout</code> 时 <code>this</code> 是如何丢失的：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  firstName<span class="token operator">:</span> <span class="token string">'John'</span><span class="token punctuation">,</span>
  <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hello, </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>firstName<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">!</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
<span class="token punctuation">&#125;</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span>sayHi<span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span> <span class="token comment">// Hello, undefined!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="解决方案-1：包装器"><a href="#解决方案-1：包装器" class="headerlink" title="解决方案 1：包装器"></a><a href="https://zh.javascript.info/bind#jie-jue-fang-an-1-bao-zhuang-qi">解决方案 1：包装器</a></h2><p>最简单的解决方案是使用一个包装函数：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  firstName<span class="token operator">:</span> <span class="token string">'John'</span><span class="token punctuation">,</span>
  <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hello, </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>firstName<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">!</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
<span class="token punctuation">&#125;</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  user<span class="token punctuation">.</span><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// Hello, John!</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>现在它可以正常工作了，因为它从外部词法环境中获取到了 <code>user</code>，就可以正常地调用方法了。</p>
<h2 id="解决方案-2：bind"><a href="#解决方案-2：bind" class="headerlink" title="解决方案 2：bind"></a><a href="https://zh.javascript.info/bind#jie-jue-fang-an-2-bind">解决方案 2：bind</a></h2><p>函数提供了一个内建方法 <a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Function/bind">bind</a>，它可以绑定 <code>this</code>。</p>
<p>基本的语法是：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 稍后将会有更复杂的语法</span>
<span class="token keyword">let</span> boundFunc <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><code>func.bind(context)</code> 的结果是一个特殊的类似于函数的“外来对象（exotic object）”，它可以像函数一样被调用，并且透明地（transparently）将调用传递给 <code>func</code> 并设定 <code>this=context</code>。</p>
<p><code>boundFunc</code> 调用就像绑定了 <code>this</code> 的 <code>func</code>。</p>
<h2 id="在没有上下文情况下的-partial"><a href="#在没有上下文情况下的-partial" class="headerlink" title="在没有上下文情况下的 partial"></a><a href="https://zh.javascript.info/bind#zai-mei-you-shang-xia-wen-qing-kuang-xia-de-partial">在没有上下文情况下的 partial</a></h2><p>当我们想绑定一些参数（arguments），但是这里没有上下文 <code>this</code>，应该怎么办？例如，对于一个对象方法。</p>
<p>原生的 <code>bind</code> 不允许这种情况。我们不可以省略上下文直接跳到参数（arguments）。</p>
<p><code>partial(func[, arg1, arg2...])</code> 调用的结果是一个包装器 <code>(*)</code>，它调用 <code>func</code> 并具有以下内容：</p>
<ul>
<li>与它获得的函数具有相同的 <code>this</code>（对于 <code>user.sayNow</code> 调用来说，它是 <code>user</code>）</li>
<li>然后给它 <code>...argsBound</code> —— 来自于 <code>partial</code> 调用的参数（<code>&quot;10:00&quot;</code>）</li>
<li>然后给它 <code>...args</code> —— 给包装器的参数（<code>&quot;Hello&quot;</code>）</li>
</ul>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a><a href="https://zh.javascript.info/bind#zong-jie">总结</a></h2><p>方法 <code>func.bind(context, ...args)</code> 返回函数 <code>func</code> 的“绑定的（bound）变体”，它绑定了上下文 <code>this</code> 和第一个参数（如果给定了）。</p>
<p>通常我们应用 <code>bind</code> 来绑定对象方法的 <code>this</code>，这样我们就可以把它们传递到其他地方使用。例如，传递给 <code>setTimeout</code>。</p>
<p>当我们绑定一个现有的函数的某些参数时，绑定后的（不太通用的）函数被称为 <strong>partially applied</strong> 或 <strong>partial</strong>。</p>
<p>当我们不想一遍又一遍地重复相同的参数时，partial 非常有用。就像我们有一个 <code>send(from, to)</code> 函数，并且对于我们的任务来说，<code>from</code> 应该总是一样的，那么我们就可以搞一个 partial 并使用它。</p>
<h1 id="深入理解箭头函数"><a href="#深入理解箭头函数" class="headerlink" title="深入理解箭头函数"></a>深入理解箭头函数</h1><p>让我们深入研究一下箭头函数。</p>
<p>箭头函数不仅仅是编写简洁代码的“捷径”。它还具有非常特殊且有用的特性。</p>
<p>JavaScript 充满了我们需要编写在其他地方执行的小函数的情况。</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> <span class="token function-variable function">sum</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=></span> a <span class="token operator">+</span> b

<span class="token comment">/* 这个箭头函数是下面这个函数的更短的版本：

let sum = function(a, b) &#123;
  return a + b;
&#125;;
*/</span>

<span class="token function">alert</span><span class="token punctuation">(</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>如果我们只有一个参数，还可以省略掉参数外的圆括号，使代码更短。</li>
<li>如果没有参数，括号将是空的（但括号应该保留）：</li>
</ul>
<h2 id="箭头函数没有-“this”"><a href="#箭头函数没有-“this”" class="headerlink" title="箭头函数没有 “this”"></a><a href="https://zh.javascript.info/arrow-functions#jian-tou-han-shu-mei-you-this">箭头函数没有 “this”</a></h2><p>正如我们在 <a href="https://zh.javascript.info/object-methods">对象方法，”this”</a> 一章中所学到的，箭头函数没有 <code>this</code>。如果访问 <code>this</code>，则会从外部获取。</p>
<p><strong>不能对箭头函数进行 <code>new</code> 操作</strong></p>
<p>不具有 <code>this</code> 自然也就意味着另一个限制：箭头函数不能用作构造器（constructor）。不能用 <code>new</code> 调用它们。</p>
<h2 id="箭头函数没有-“arguments”"><a href="#箭头函数没有-“arguments”" class="headerlink" title="箭头函数没有 “arguments”"></a><a href="https://zh.javascript.info/arrow-functions#jian-tou-han-shu-mei-you-arguments">箭头函数没有 “arguments”</a></h2><p>箭头函数也没有 <code>arguments</code> 变量。</p>
<p>当我们需要使用当前的 <code>this</code> 和 <code>arguments</code> 转发一个调用时，这对装饰器（decorators）来说非常有用。</p>
<h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a><a href="https://zh.javascript.info/arrow-functions#zong-jie">总结</a></h2><p>箭头函数：</p>
<ul>
<li>没有 <code>this</code></li>
<li>没有 <code>arguments</code></li>
<li>不能使用 <code>new</code> 进行调用</li>
<li>它们也没有 <code>super</code></li>
</ul>
<h1 id="Mixin-模式"><a href="#Mixin-模式" class="headerlink" title="Mixin 模式"></a>Mixin 模式</h1><p><a href="https://en.wikipedia.org/wiki/Mixin">mixin</a> 是一个包含可被其他类使用而无需继承的方法的类。</p>
<h2 id="EventMixin"><a href="#EventMixin" class="headerlink" title="EventMixin"></a><a href="https://zh.javascript.info/mixins#eventmixin">EventMixin</a></h2><p>现在让我们为实际运用构造一个 mixin。</p>
<p>例如，许多浏览器对象的一个重要功能是它们可以生成事件。事件是向任何有需要的人“广播信息”的好方法。因此，让我们构造一个 mixin，使我们能够轻松地将与事件相关的函数添加到任意 class/object 中。</p>
<ul>
<li>Mixin 将提供 <code>.trigger(name, [...data])</code> 方法，以在发生重要的事情时“生成一个事件”。<code>name</code> 参数（arguments）是事件的名称，<code>[...data]</code> 是可选的带有事件数据的其他参数（arguments）。</li>
<li>此外还有 <code>.on(name, handler)</code> 方法，它为具有给定名称的事件添加了 <code>handler</code> 函数作为监听器（listener）。当具有给定 <code>name</code> 的事件触发时将调用该方法，并从 <code>.trigger</code> 调用中获取参数（arguments）。</li>
<li>……还有 <code>.off(name, handler)</code> 方法，它会删除 <code>handler</code> 监听器（listener）。</li>
</ul>
<h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a><a href="https://zh.javascript.info/mixins#zong-jie">总结</a></h2><p><em>Mixin</em> — 是一个通用的面向对象编程术语：一个包含其他类的方法的类。</p>
<p>一些其它编程语言允许多重继承。JavaScript 不支持多重继承，但是可以通过将方法拷贝到原型中来实现 mixin。</p>
<p>我们可以使用 mixin 作为一种通过添加多种行为（例如上文中所提到的事件处理）来扩充类的方法。</p>
<p><strong>受保护的属性通常以下划线 <code>_</code> 作为前缀。</strong></p>
<h1 id="简介：回调"><a href="#简介：回调" class="headerlink" title="简介：回调"></a>简介：回调</h1><p>JavaScript 主机（host）环境提供了许多函数，这些函数允许我们计划 <strong>异步</strong> 行为（action）。</p>
<p>脚本是“异步”调用的，因为它从现在开始加载，但是在这个加载函数执行完成后才运行。</p>
<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p>Promise 对象的构造器（constructor）语法如下：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// executor（生产者代码，“歌手”）</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>传递给 <code>new Promise</code> 的函数被称为 <strong>executor</strong>。当 <code>new Promise</code> 被创建，executor 会自动运行。</p>
<p>当 executor 获得了结果，无论是早还是晚都没关系，它应该调用以下回调之一：</p>
<ul>
<li><code>resolve(value)</code> — 如果任务成功完成并带有结果 <code>value</code>。</li>
<li><code>reject(error)</code> — 如果出现了 error，<code>error</code> 即为 error 对象。</li>
</ul>
<p>executor 会自动运行并尝试执行一项工作。尝试结束后，如果成功则调用 <code>resolve</code>，如果出现 error 则调用 <code>reject</code>。</p>
<p>由 <code>new Promise</code> 构造器返回的 <code>promise</code> 对象具有以下内部属性：</p>
<ul>
<li><code>state</code> — 最初是 <code>&quot;pending&quot;</code>，然后在 <code>resolve</code> 被调用时变为 <code>&quot;fulfilled&quot;</code>，或者在 <code>reject</code> 被调用时变为 <code>&quot;rejected&quot;</code>。</li>
<li><code>result</code> — 最初是 <code>undefined</code>，然后在 <code>resolve(value)</code> 被调用时变为 <code>value</code>，或者在 <code>reject(error)</code> 被调用时变为 <code>error</code>。</li>
</ul>
<table>
<thead>
<tr>
<th align="left">Promises</th>
<th align="left">Callbacks</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Promises 允许我们按照自然顺序进行编码。首先，我们运行 <code>loadScript</code> 和 <code>.then</code> 来处理结果。</td>
<td align="left">在调用 <code>loadScript(script, callback)</code> 时，在我们处理的地方（disposal）必须有一个 <code>callback</code> 函数。换句话说，在调用 <code>loadScript</code> <strong>之前</strong>，我们必须知道如何处理结果。</td>
</tr>
<tr>
<td align="left">我们可以根据需要，在 promise 上多次调用 <code>.then</code>。每次调用，我们都会在“订阅列表”中添加一个新的“分析”，一个新的订阅函数。在下一章将对此内容进行详细介绍：<a href="https://zh.javascript.info/promise-chaining">Promise 链</a>。</td>
<td align="left">只能有一个回调。</td>
</tr>
</tbody></table>
<p>因此，promise 为我们提供了更好的代码流和灵活性。</p>
<p>一个 promise 构造器和一个简单的 executor 函数，该 executor 函数具有包含时间（即 <code>setTimeout</code>）的“生产者代码”：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// 当 promise 被构造完成时，自动执行此函数</span>

  <span class="token comment">// 1 秒后发出工作已经被完成的信号，并带有结果 "done"</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'done'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 new Promise()的时候，Promise 的执行器就会立马执行，但是<strong>调用 resolve()会触发异步操作，传入的 then()方法的函数会被添加到任务队列并异步执行</strong></p>
<p><code>promise</code> 对象代表异步执行结果，通过构造函数 <code>new Promise</code> 创建，其参数是 executor function 可能有一些异步代码，对象其后的方法 <code>.then</code>、<code>.catch</code>、<code>.finally</code> 相当于回调函数。</p>
<p>一开始创建的 <code>promise</code> 对象状态是 <code>pending</code>（表示初始状态）然后在 executor function 中会有条件地执行 <code>resolve</code> 或 <code>reject</code> 之一，这样就会改变 <code>promise</code> 对象的状态为 <code>settled</code>（表示状态确定，可以触发对象后的方法 <code>.finally</code>）</p>
<p><code>promise</code> 对象确定的状态其实有两种，如果在 executor function 调用的是 <code>resolve</code> 状态就变成 <code>resolved</code> 相应地会调用对象后的方法 <code>.then</code>；而如果在 executor function 调用的是 <code>reject</code> 状态就变成 <code>rejected</code> 相应地会调用对象后的方法 <code>.catch</code>（其实这是 <code>.then(null, rejectFunc)</code> 缩写形式）</p>
<h1 id="Promise-链"><a href="#Promise-链" class="headerlink" title="Promise 链"></a>Promise 链</h1><p>它的理念是将 result 通过 <code>.then</code> 处理程序（handler）链进行传递。</p>
<p>运行流程如下：</p>
<ol>
<li>初始 promise 在 1 秒后进行 resolve <code>(*)</code>，</li>
<li>然后 <code>.then</code> 处理程序（handler）被调用 <code>(**)</code>。</li>
<li>它返回的值被传入下一个 <code>.then</code> 处理程序（handler）<code>(***)</code></li>
<li>……依此类推。</li>
</ol>
<p><strong>新手常犯的一个经典错误：从技术上讲，我们也可以将多个 <code>.then</code> 添加到一个 promise 上。但这并不是 promise 链（chaining）。</strong></p>
<h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a><a href="https://zh.javascript.info/promise-chaining#zong-jie">总结</a></h2><p>如果 <code>.then</code>（或 <code>catch/finally</code> 都可以）处理程序（handler）返回一个 promise，那么链的其余部分将会等待，直到它状态变为 settled。当它被 settled 后，其 result（或 error）将被进一步传递下去。</p>
<p><img src="E:\Markdown图片\image-20210128140346440.png" alt="image-20210128140346440"></p>
<h1 id="使用-promise-进行错误处理"><a href="#使用-promise-进行错误处理" class="headerlink" title="使用 promise 进行错误处理"></a>使用 promise 进行错误处理</h1><p>Promise 链在错误（error）处理中十分强大。当一个 promise 被 reject 时，控制权将移交至最近的 rejection 处理程序（handler）。</p>
<h2 id="隐式-try…catch"><a href="#隐式-try…catch" class="headerlink" title="隐式 try…catch"></a><a href="https://zh.javascript.info/promise-error-handling#yin-shi-trycatch">隐式 try…catch</a></h2><p>Promise 的执行者（executor）和 promise 的处理程序（handler）周围有一个“隐式的 <code>try..catch</code>”。如果发生异常，它（译注：指异常）就会被捕获，并被视为 rejection 进行处理。</p>
<p>下面这段代码：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'Whoops!'</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span>alert<span class="token punctuation">)</span> <span class="token comment">// Error: Whoops!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>……与下面这段代码工作上完全相同：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'Whoops!'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span>alert<span class="token punctuation">)</span> <span class="token comment">// Error: Whoops!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>在 executor 周围的“隐式 <code>try..catch</code>”自动捕获了 error，并将其变为 rejected promise。</p>
<p>这不仅仅发生在 executor 函数中，同样也发生在其 handler 中。如果我们在 <code>.then</code> 处理程序（handler）中 <code>throw</code>，这意味着 promise 被 rejected，因此控制权移交至最近的 error 处理程序（handler）。</p>
<p>一个例子：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'ok'</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">result</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'Whoops!'</span><span class="token punctuation">)</span> <span class="token comment">// reject 这个 promise</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span>alert<span class="token punctuation">)</span> <span class="token comment">// Error: Whoops!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="再次抛出（Rethrowing）"><a href="#再次抛出（Rethrowing）" class="headerlink" title="再次抛出（Rethrowing）"></a><a href="https://zh.javascript.info/promise-error-handling#zai-ci-pao-chu-rethrowing">再次抛出（Rethrowing）</a></h2><p>链尾端的 <code>.catch</code> 的表现有点像 <code>try..catch</code>。我们可能有许多个 <code>.then</code> 处理程序（handler），然后在尾端使用一个 <code>.catch</code> 处理上面的所有 error。</p>
<h2 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a><a href="https://zh.javascript.info/promise-error-handling#zong-jie">总结</a></h2><ul>
<li><code>.catch</code> 处理 promise 中的各种 error：在 <code>reject()</code> 调用中的，或者在处理程序（handler）中抛出的（thrown）error。</li>
<li>我们应该将 <code>.catch</code> 准确地放到我们想要处理 error，并知道如何处理这些 error 的地方。处理程序应该分析 error（可以自定义 error 类来帮助分析）并再次抛出未知的 error（可能它们是编程错误）。</li>
<li>如果没有办法从 error 中恢复的话，不使用 <code>.catch</code> 也可以。</li>
<li>在任何情况下我们都应该有 <code>unhandledrejection</code> 事件处理程序（用于浏览器，以及其他环境的模拟），以跟踪未处理的 error 并告知用户（可能还有我们的服务器）有关信息，以使我们的应用程序永远不会“死掉”。</li>
</ul>
<h1 id="Promise-API"><a href="#Promise-API" class="headerlink" title="Promise API"></a>Promise API</h1><h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a><a href="https://zh.javascript.info/promise-api#promiseall">Promise.all</a></h2><p>假设我们希望并行执行多个 promise，并等待所有 promise 都准备就绪。语法：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> promise <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">...</span>promises<span class="token operator">...</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><code>Promise.all(iterable)</code> <strong>允许在</strong> <code>iterable</code> <strong>中使用 non-promise 的“常规”值</strong></p>
<p><code>Promise.all</code> 接受一个 promise 数组作为参数（从技术上讲，它可以是任何可迭代的，但通常是一个数组）并返回一个新的 promise。</p>
<p><strong>如果任意一个 promise 被 reject，由 <code>Promise.all</code> 返回的 promise 就会立即 reject，并且带有的就是这个 error。</strong></p>
<h2 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled"></a><a href="https://zh.javascript.info/promise-api#promiseallsettled">Promise.allSettled</a></h2><p><code>Promise.allSettled</code> 等待所有的 promise 都被 settle，无论结果如何。结果数组具有：</p>
<ul>
<li><code>&#123;status:&quot;fulfilled&quot;, value:result&#125;</code> 对于成功的响应，</li>
<li><code>&#123;status:&quot;rejected&quot;, reason:error&#125;</code> 对于 error。</li>
</ul>
<h2 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a><a href="https://zh.javascript.info/promise-api#promiserace">Promise.race</a></h2><p>与 <code>Promise.all</code> 类似，但只等待第一个 settled 的 promise 并获取其结果（或 error）。</p>
<p><code>Promise.all</code> 可能是在实战中使用最多的。</p>
<h1 id="微任务（Microtask）"><a href="#微任务（Microtask）" class="headerlink" title="微任务（Microtask）"></a>微任务（Microtask）</h1><p>Promise 的处理程序（handlers）<code>.then</code>、<code>.catch</code> 和 <code>.finally</code> 都是异步的。</p>
<p>即便一个 promise 立即被 resolve，<code>.then</code>、<code>.catch</code> 和 <code>.finally</code> <strong>下面</strong> 的代码也会在这些处理程序（handler）之前被执行。</p>
<h2 id="微任务队列（Microtask-queue）"><a href="#微任务队列（Microtask-queue）" class="headerlink" title="微任务队列（Microtask queue）"></a><a href="https://zh.javascript.info/microtask-queue#wei-ren-wu-dui-lie-microtaskqueue">微任务队列（Microtask queue）</a></h2><p>异步任务需要适当的管理。为此，ECMA 标准规定了一个内部队列 <code>PromiseJobs</code>，通常被称为“微任务队列（microtask queue）”（ES8 术语）。</p>
<p>如 <a href="https://tc39.github.io/ecma262/#sec-jobs-and-job-queues">规范</a> 中所述：</p>
<ul>
<li>队列（queue）是先进先出的：首先进入队列的任务会首先运行。</li>
<li>只有在 JavaScript 引擎中没有其它任务在运行时，才开始执行任务队列中的任务。</li>
</ul>
<p>当一个 promise 准备就绪时，它的 <code>.then/catch/finally</code> 处理程序（handler）就会被放入队列中：但是它们不会立即被执行。当 JavaScript 引擎执行完当前的代码，它会从队列中获取任务并执行它。</p>
<p>如果有一个包含多个 <code>.then/catch/finally</code> 的链，那么它们中的每一个都是异步执行的。也就是说，它会首先进入队列，然后在当前代码执行完成并且先前排队的处理程序（handler）都完成时才会被执行。</p>
<h2 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a><a href="https://zh.javascript.info/microtask-queue#zong-jie">总结</a></h2><p>Promise 处理始终是异步的，因为所有 promise 行为都会通过内部的 “promise jobs” 队列，也被称为“微任务队列”（ES8 术语）。</p>
<p>因此，<code>.then/catch/finally</code> 处理程序（handler）总是在当前代码完成后才会被调用。</p>
<p>如果我们需要确保一段代码在 <code>.then/catch/finally</code> 之后被执行，我们可以将它添加到链式调用的 <code>.then</code> 中。</p>
<h1 id="Async-await"><a href="#Async-await" class="headerlink" title="Async/await"></a>Async/await</h1><h2 id="Async-function"><a href="#Async-function" class="headerlink" title="Async function"></a><a href="https://zh.javascript.info/async-await#asyncfunction">Async function</a></h2><p>Async/await 是以更舒适的方式使用 promise 的一种特殊语法，同时它也非常易于理解和使用。</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">return</span> <span class="token number">1</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>在函数前面的 “async” 这个单词表达了一个简单的事情：即这个函数总是返回一个 promise。其他值将自动被包装在一个 resolved 的 promise 中。</p>
<h2 id="Await"><a href="#Await" class="headerlink" title="Await"></a><a href="https://zh.javascript.info/async-await#await">Await</a></h2><p>语法如下：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 只在 async 函数内工作</span>
<span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token keyword">await</span> promise<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>关键字 <code>await</code> 让 JavaScript 引擎等待直到 promise 完成（settle）并返回结果。</p>
<h1 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h1><p>常规函数只会返回一个单一值（或者不返回任何值）。</p>
<p>而 Generator 可以按需一个接一个地返回（“yield”）多个值。它们可与 <a href="https://zh.javascript.info/iterable">iterable</a> 完美配合使用，从而可以轻松地创建数据流。</p>
<h2 id="Generator-函数"><a href="#Generator-函数" class="headerlink" title="Generator 函数"></a><a href="https://zh.javascript.info/generators#generator-han-shu">Generator 函数</a></h2><p>要创建一个 generator，我们需要一个特殊的语法结构：<code>function*</code>，即所谓的 “generator function”。</p>
<p>像这样：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">generateSequence</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">yield</span> <span class="token number">1</span>
  <span class="token keyword">yield</span> <span class="token number">2</span>
  <span class="token keyword">return</span> <span class="token number">3</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>一个 generator 的主要方法就是 <code>next()</code>。当被调用时（译注：指 <code>next()</code> 方法），它会恢复上图所示的运行，执行直到最近的 <code>yield &lt;value&gt;</code> 语句（<code>value</code> 可以被省略，默认为 <code>undefined</code>）。然后函数执行暂停，并将产出的（yielded）值返回到外部代码。</p>
<p><code>next()</code> 的结果始终是一个具有两个属性的对象：</p>
<ul>
<li><code>value</code>: 产出的（yielded）的值。</li>
<li><code>done</code>: 如果 generator 函数已执行完成则为 <code>true</code>，否则为 <code>false</code>。</li>
</ul>
<p>代码恢复执行并返回下一个 <code>yield</code> 的值：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> two <span class="token operator">=</span> generator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token function">alert</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>two<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// &#123;value: 2, done: false&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><strong><code>function\* f(…)</code> 或 <code>function \*f(…)</code>？</strong></p>
<p>这两种语法都是对的。</p>
<p>但是通常更倾向于第一种语法，因为星号 <code>*</code> 表示它是一个 generator 函数，它描述的是函数种类而不是名称，因此 <code>*</code> 应该和 <code>function</code> 关键字紧贴一起。</p>
<h2 id="“yield”-是一条双向路"><a href="#“yield”-是一条双向路" class="headerlink" title="“yield” 是一条双向路"></a><a href="https://zh.javascript.info/generators#yield-shi-yi-tiao-shuang-xiang-lu">“yield” 是一条双向路</a></h2><p>目前看来，generator 和可迭代对象类似，都具有用来生成值的特殊语法。但实际上，generator 更加强大且灵活。</p>
<p>这是因为 <code>yield</code> 是一条双向路（two-way street）：它不仅可以向外返回结果，而且还可以将外部的值传递到 generator 内。</p>
<p>调用 <code>generator.next(arg)</code>，我们就能将参数 <code>arg</code> 传递到 generator 内部。这个 <code>arg</code> 参数会变成 <code>yield</code> 的结果。</p>
<h2 id="generator-throw"><a href="#generator-throw" class="headerlink" title="generator.throw"></a><a href="https://zh.javascript.info/generators#generatorthrow">generator.throw</a></h2><p>正如我们在上面的例子中观察到的那样，外部代码可能会将一个值传递到 generator，作为 <code>yield</code> 的结果。</p>
<p>……但是它也可以在那里发起（抛出）一个 error。这很自然，因为 error 本身也是一种结果。</p>
<p>要向 <code>yield</code> 传递一个 error，我们应该调用 <code>generator.throw(err)</code>。在这种情况下，<code>err</code> 将被抛到对应的 <code>yield</code> 所在的那一行。</p>
<h2 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a><a href="https://zh.javascript.info/generators#zong-jie">总结</a></h2><ul>
<li>Generator 是通过 generator 函数 <code>function* f(…) &#123;…&#125;</code> 创建的。</li>
<li>在 generator（仅在）内部，存在 <code>yield</code> 操作。</li>
<li>外部代码和 generator 可能会通过 <code>next/yield</code> 调用交换结果。</li>
</ul>
<h1 id="异步迭代和-generator"><a href="#异步迭代和-generator" class="headerlink" title="异步迭代和 generator"></a>异步迭代和 generator</h1><p>异步迭代允许我们对按需通过异步请求而得到的数据进行迭代。</p>
<p>当值是以异步的形式出现时，例如在 <code>setTimeout</code> 或者另一种延迟之后，就需要异步迭代。</p>
<p>最常见的场景是，对象需要发送一个网络请求以传递下一个值，稍后我们将看到一个它的真实示例。</p>
<p>要使对象异步迭代：</p>
<ol>
<li>使用 <code>Symbol.asyncIterator</code> 取代 <code>Symbol.iterator</code>。</li>
<li><code>next()</code> 方法应该返回一个 <code>promise</code>（带有下一个值，并且状态为 <code>fulfilled</code>）。<ul>
<li>关键字 <code>async</code> 可以实现这一点，我们可以简单地使用 <code>async next()</code>。</li>
</ul>
</li>
<li>我们应该使用 <code>for await (let item of iterable)</code> 循环来迭代这样的对象。<ul>
<li>注意关键字 <code>await</code>。</li>
</ul>
</li>
</ol>
<p>作为开始的示例，让我们创建一个可迭代的 <code>range</code> 对象，与前面的那个类似，不过现在它将异步地每秒返回一个值。</p>
<p>我们需要做的就是对上面代码中的部分代码进行替换：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> range <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">from</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  to<span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">,</span>

  <span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>asyncIterator<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// (1)</span>
    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>
      current<span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>from<span class="token punctuation">,</span>
      last<span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>to<span class="token punctuation">,</span>

      <span class="token keyword">async</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// (2)</span>

        <span class="token comment">// 注意：我们可以在 async next 内部使用 "await"</span>
        <span class="token keyword">await</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// (3)</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>current <span class="token operator">&lt;=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>last<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
          <span class="token keyword">return</span> <span class="token punctuation">&#123;</span> done<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> value<span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>current<span class="token operator">++</span> <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
          <span class="token keyword">return</span> <span class="token punctuation">&#123;</span> done<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
<span class="token punctuation">&#125;</span>

<span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">for</span> <span class="token keyword">await</span> <span class="token punctuation">(</span><span class="token keyword">let</span> value <span class="token keyword">of</span> range<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// (4)</span>
    <span class="token function">alert</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token comment">// 1,2,3,4,5</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>正如我们所看到的，其结构与常规的 iterator 类似:</p>
<ol>
<li>为了使一个对象可以异步迭代，它必须具有方法 <code>Symbol.asyncIterator</code> <code>(1)</code>。</li>
<li>这个方法必须返回一个带有 <code>next()</code> 方法的对象，<code>next()</code> 方法会返回一个 promise <code>(2)</code>。</li>
<li>这个 <code>next()</code> 方法可以不是 <code>async</code> 的，它可以是一个返回值是一个 <code>promise</code> 的常规的方法，但是使用 <code>async</code> 关键字可以允许我们在方法内部使用 <code>await</code>，所以会更加方便。这里我们只是用于延迟 1 秒的操作 <code>(3)</code>。</li>
<li>我们使用 <code>for await(let value of range)</code> <code>(4)</code> 来进行迭代，也就是在 <code>for</code> 后面添加 <code>await</code>。它会调用一次 <code>range[Symbol.asyncIterator]()</code> 方法一次，然后调用它的 <code>next()</code> 方法获取值。</li>
</ol>
<p>这是一个对比 Iterator 和异步 iterator 之间差异的表格：</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">Iterator</th>
<th align="left">异步 iterator</th>
</tr>
</thead>
<tbody><tr>
<td align="left">提供 iterator 的对象方法</td>
<td align="left"><code>Symbol.iterator</code></td>
<td align="left"><code>Symbol.asyncIterator</code></td>
</tr>
<tr>
<td align="left"><code>next()</code> 返回的值是</td>
<td align="left">任意值</td>
<td align="left"><code>Promise</code></td>
</tr>
<tr>
<td align="left">要进行循环，使用</td>
<td align="left"><code>for..of</code></td>
<td align="left"><code>for await..of</code></td>
</tr>
</tbody></table>
<h1 id="模块-Module-简介"><a href="#模块-Module-简介" class="headerlink" title="模块 (Module) 简介"></a>模块 (Module) 简介</h1><p>社区发明了许多种方法来将代码组织到模块中，使用特殊的库按需加载模块。</p>
<p>列举一些（出于历史原因）：</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Asynchronous_module_definition">AMD</a> —— 最古老的模块系统之一，最初由 <a href="http://requirejs.org/">require.js</a> 库实现。</li>
<li><a href="http://wiki.commonjs.org/wiki/Modules/1.1">CommonJS</a> —— 为 Node.js 服务器创建的模块系统。</li>
<li><a href="https://github.com/umdjs/umd">UMD</a> —— 另外一个模块系统，建议作为通用的模块系统，它与 AMD 和 CommonJS 都兼容。</li>
</ul>
<h2 id="什么是模块？"><a href="#什么是模块？" class="headerlink" title="什么是模块？"></a><a href="https://zh.javascript.info/modules-intro#shi-mo-shi-mo-kuai">什么是模块？</a></h2><p>一个模块（module）就是一个文件。一个脚本就是一个模块。就这么简单。</p>
<p>模块可以相互加载，并可以使用特殊的指令 <code>export</code> 和 <code>import</code> 来交换功能，从另一个模块调用一个模块的函数：</p>
<ul>
<li><code>export</code> 关键字标记了可以从当前模块外部访问的变量和函数。</li>
<li><code>import</code> 关键字允许从其他模块导入功能。</li>
</ul>
<h2 id="模块核心功能"><a href="#模块核心功能" class="headerlink" title="模块核心功能"></a><a href="https://zh.javascript.info/modules-intro#mo-kuai-he-xin-gong-neng">模块核心功能</a></h2><h3 id="始终使用-“use-strict”"><a href="#始终使用-“use-strict”" class="headerlink" title="始终使用 “use strict”"></a><a href="https://zh.javascript.info/modules-intro#shi-zhong-shi-yong-usestrict">始终使用 “use strict”</a></h3><p>模块始终默认使用 <code>use strict</code>，例如，对一个未声明的变量赋值将产生错误（译注：在浏览器控制台可以看到 error 信息）。</p>
<h3 id="模块级作用域"><a href="#模块级作用域" class="headerlink" title="模块级作用域"></a><a href="https://zh.javascript.info/modules-intro#mo-kuai-ji-zuo-yong-yu">模块级作用域</a></h3><p>每个模块都有自己的顶级作用域（top-level scope）。换句话说，一个模块中的顶级作用域变量和函数在其他脚本中是不可见的。</p>
<h3 id="模块代码仅在第一次导入时被解析"><a href="#模块代码仅在第一次导入时被解析" class="headerlink" title="模块代码仅在第一次导入时被解析"></a><a href="https://zh.javascript.info/modules-intro#mo-kuai-dai-ma-jin-zai-di-yi-ci-dao-ru-shi-bei-jie-xi">模块代码仅在第一次导入时被解析</a></h3><p>如果同一个模块被导入到多个其他位置，那么它的代码仅会在第一次导入时执行，然后将导出（export）的内容提供给所有的导入（importer）。</p>
<h3 id="在一个模块中，“this”-是-undefined"><a href="#在一个模块中，“this”-是-undefined" class="headerlink" title="在一个模块中，“this” 是 undefined"></a><a href="https://zh.javascript.info/modules-intro#zai-yi-ge-mo-kuai-zhong-this-shi-undefined">在一个模块中，“this” 是 undefined</a></h3><p>这是一个小功能，但为了完整性，我们应该提到它。</p>
<p>在一个模块中，顶级 <code>this</code> 是 undefined。</p>
<h3 id="import-meta"><a href="#import-meta" class="headerlink" title="import.meta"></a><a href="https://zh.javascript.info/modules-intro#importmeta">import.meta</a></h3><p><code>import.meta</code> 对象包含关于当前模块的信息。</p>
<p>它的内容取决于其所在的环境。在浏览器环境中，它包含当前脚本的 URL，或者如果它是在 HTML 中的话，则包含当前页面的 URL。</p>
<h3 id="模块脚本是延迟的"><a href="#模块脚本是延迟的" class="headerlink" title="模块脚本是延迟的"></a><a href="https://zh.javascript.info/modules-intro#mo-kuai-jiao-ben-shi-yan-chi-de">模块脚本是延迟的</a></h3><p>模块脚本 <strong>总是</strong> 被延迟的，与 <code>defer</code> 特性（在 <a href="https://zh.javascript.info/script-async-defer">脚本：async，defer</a> 一章中描述的）对外部脚本和内联脚本（inline script）的影响相同。</p>
<p>也就是说：</p>
<ul>
<li>下载外部模块脚本 <code>&lt;script type=&quot;module&quot; src=&quot;...&quot;&gt;</code> 不会阻塞 HTML 的处理，它们会与其他资源并行加载。</li>
<li>模块脚本会等到 HTML 文档完全准备就绪（即使它们很小并且比 HTML 加载速度更快），然后才会运行。</li>
<li>保持脚本的相对顺序：在文档中排在前面的脚本先执行。</li>
</ul>
<p>它的一个副作用是，模块脚本总是会“看到”已完全加载的 HTML 页面，包括在它们下方的 HTML 元素。</p>
<h3 id="不允许裸模块（“bare”-module）"><a href="#不允许裸模块（“bare”-module）" class="headerlink" title="不允许裸模块（“bare” module）"></a><a href="https://zh.javascript.info/modules-intro#bu-yun-xu-luo-mo-kuai-baremodule">不允许裸模块（“bare” module）</a></h3><p>在浏览器中，<code>import</code> 必须给出相对或绝对的 URL 路径。没有任何路径的模块被称为“裸（bare）”模块。在 <code>import</code> 中不允许这种模块。</p>
<h3 id="兼容性，“nomodule”"><a href="#兼容性，“nomodule”" class="headerlink" title="兼容性，“nomodule”"></a><a href="https://zh.javascript.info/modules-intro#jian-rong-xing-nomodule">兼容性，“nomodule”</a></h3><p>旧时的浏览器不理解 <code>type=&quot;module&quot;</code>。未知类型的脚本会被忽略。</p>
<h2 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a><a href="https://zh.javascript.info/modules-intro#gou-jian-gong-ju">构建工具</a></h2><p>在实际开发中，浏览器模块很少被以“原始”形式进行使用。通常，我们会使用一些特殊工具，例如 <a href="https://webpack.js.org/">Webpack</a>，将它们打包在一起，然后部署到生产环境的服务器。</p>
<p>使用打包工具的一个好处是 —— 它们可以更好地控制模块的解析方式，允许我们使用裸模块和更多的功能，例如 CSS/HTML 模块等。</p>
<p>构建工具做以下这些事儿：</p>
<ol>
<li>从一个打算放在 HTML 中的 <code>&lt;script type=&quot;module&quot;&gt;</code> “主”模块开始。</li>
<li>分析它的依赖：它的导入，以及它的导入的导入等。</li>
<li>使用所有模块构建一个文件（或者多个文件，这是可调的），并用打包函数（bundler function）替代原生的 <code>import</code> 调用，以使其正常工作。还支持像 HTML/CSS 模块等“特殊”的模块类型。</li>
<li>在处理过程中，可能会应用其他转换和优化：<ul>
<li>删除无法访问的代码。</li>
<li>删除未使用的导出（“tree-shaking”）。</li>
<li>删除特定于开发的像 <code>console</code> 和 <code>debugger</code> 这样的语句。</li>
<li>可以使用 <a href="https://babeljs.io/">Babel</a> 将前沿的现代的 JavaScript 语法转换为具有类似功能的旧的 JavaScript 语法。</li>
<li>压缩生成的文件（删除空格，用短的名字替换变量等）。</li>
</ul>
</li>
</ol>
<h2 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a><a href="https://zh.javascript.info/modules-intro#zong-jie">总结</a></h2><p>下面总结一下模块的核心概念：</p>
<ol>
<li>一个模块就是一个文件。浏览器需要使用<script type="module">以使 import/export 可以工作。模块（译注：相较于常规脚本）有几点差别：<ul>
<li>默认是延迟解析的（deferred）。</li>
<li>Async 可用于内联脚本。</li>
<li>要从另一个源（域/协议/端口）加载外部脚本，需要 CORS header。</li>
<li>重复的外部脚本会被忽略</li>
</ul>
</li>
<li>模块具有自己的本地顶级作用域，并可以通过 <code>import/export</code> 交换功能。</li>
<li>模块始终使用 <code>use strict</code>。</li>
<li>模块代码只执行一次。导出仅创建一次，然后会在导入之间共享。</li>
</ol>
<h1 id="Proxy-和-Reflect"><a href="#Proxy-和-Reflect" class="headerlink" title="Proxy 和 Reflect"></a>Proxy 和 Reflect</h1><p>一个 <code>Proxy</code> 对象包装另一个对象并拦截诸如读取/写入属性和其他操作，可以选择自行处理它们，或者透明地允许该对象处理它们。</p>
<p>Proxy 被用于了许多库和某些浏览器框架。</p>
<h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a><a href="https://zh.javascript.info/proxy#proxy">Proxy</a></h2><p>语法：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li><code>target</code> —— 是要包装的对象，可以是任何东西，包括函数。</li>
<li><code>handler</code> —— 代理配置：带有“捕捉器”（“traps”，即拦截操作的方法）的对象。比如 <code>get</code> 捕捉器用于读取 <code>target</code> 的属性，<code>set</code> 捕捉器用于写入 <code>target</code> 的属性，等等。</li>
</ul>
<p>对 <code>proxy</code> 进行操作，如果在 <code>handler</code> 中存在相应的捕捉器，则它将运行，并且 Proxy 有机会对其进行处理，否则将直接对 target 进行处理。</p>
<p>由于没有捕捉器，所有对 <code>proxy</code> 的操作都直接转发给了 <code>target</code>。</p>
<ol>
<li>写入操作 <code>proxy.test=</code> 会将值写入 <code>target</code>。</li>
<li>读取操作 <code>proxy.test</code> 会从 <code>target</code> 返回对应的值。</li>
<li>迭代 <code>proxy</code> 会从 <code>target</code> 返回对应的值。</li>
</ol>
<h2 id="带有-“get”-捕捉器的默认值"><a href="#带有-“get”-捕捉器的默认值" class="headerlink" title="带有 “get” 捕捉器的默认值"></a><a href="https://zh.javascript.info/proxy#dai-you-get-bu-zhuo-qi-de-mo-ren-zhi">带有 “get” 捕捉器的默认值</a></h2><p>最常见的捕捉器是用于读取/写入的属性。</p>
<p>要拦截读取操作，<code>handler</code> 应该有 <code>get(target, property, receiver)</code> 方法。</p>
<p>读取属性时触发该方法，参数如下：</p>
<ul>
<li><code>target</code> —— 是目标对象，该对象被作为第一个参数传递给 <code>new Proxy</code>，</li>
<li><code>property</code> —— 目标属性名，</li>
<li><code>receiver</code> —— 如果目标属性是一个 getter 访问器属性，则 <code>receiver</code> 就是本次读取属性所在的 <code>this</code> 对象。通常，这就是 <code>proxy</code> 对象本身（或者，如果我们从 proxy 继承，则是从该 proxy 继承的对象）。现在我们不需要此参数，因此稍后我们将对其进行详细介绍。</li>
</ul>
<h2 id="使用-“set”-捕捉器进行验证"><a href="#使用-“set”-捕捉器进行验证" class="headerlink" title="使用 “set” 捕捉器进行验证"></a><a href="https://zh.javascript.info/proxy#shi-yong-set-bu-zhuo-qi-jin-hang-yan-zheng">使用 “set” 捕捉器进行验证</a></h2><p>假设我们想要一个专门用于数字的数组。如果添加了其他类型的值，则应该抛出一个错误。</p>
<p>当写入属性时 <code>set</code> 捕捉器被触发。</p>
<p><code>set(target, property, value, receiver)</code>：</p>
<ul>
<li><code>target</code> —— 是目标对象，该对象被作为第一个参数传递给 <code>new Proxy</code>，</li>
<li><code>property</code> —— 目标属性名称，</li>
<li><code>value</code> —— 目标属性的值，</li>
<li><code>receiver</code> —— 与 <code>get</code> 捕捉器类似，仅与 setter 访问器属性相关。</li>
</ul>
<p>如果写入操作（setting）成功，<code>set</code> 捕捉器应该返回 <code>true</code>，否则返回 <code>false</code>（触发 <code>TypeError</code>）。</p>
<h2 id="使用-“ownKeys”-和-“getOwnPropertyDescriptor”-进行迭代"><a href="#使用-“ownKeys”-和-“getOwnPropertyDescriptor”-进行迭代" class="headerlink" title="使用 “ownKeys” 和 “getOwnPropertyDescriptor” 进行迭代"></a><a href="https://zh.javascript.info/proxy#shi-yong-ownkeys-he-getownpropertydescriptor-jin-hang-die-dai">使用 “ownKeys” 和 “getOwnPropertyDescriptor” 进行迭代</a></h2><p><code>Object.keys</code>，<code>for..in</code> 循环和大多数其他遍历对象属性的方法都使用内部方法 <code>[[OwnPropertyKeys]]</code>（由 <code>ownKeys</code> 捕捉器拦截) 来获取属性列表。</p>
<p>这些方法在细节上有所不同：</p>
<ul>
<li><code>Object.getOwnPropertyNames(obj)</code> 返回非 Symbol 键。</li>
<li><code>Object.getOwnPropertySymbols(obj)</code> 返回 Symbol 键。</li>
<li><code>Object.keys/values()</code> 返回带有 <code>enumerable</code> 标志的非 Symbol 键/值（属性标志在 <a href="https://zh.javascript.info/property-descriptors">属性标志和属性描述符</a> 一章有详细讲解)。</li>
<li><code>for..in</code> 循环遍历所有带有 <code>enumerable</code> 标志的非 Symbol 键，以及原型对象的键。</li>
</ul>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Js代码题</title>
    <url>/2021/03/26/Js%E4%BB%A3%E7%A0%81%E9%A2%98/</url>
    <content><![CDATA[<h2 id="JS-问题"><a href="#JS-问题" class="headerlink" title="JS 问题"></a>JS 问题</h2><pre class="line-numbers language-none"><code class="language-none">function Bar() &#123;
  return
  &#123;
    a: 1
  &#125;
&#125;
const f &#x3D; Bar()
console.log(f.a)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>输出 error，因为<code>return</code>后没有值，即使格式化也没有用，因此下方的<code>Object</code>和<code>return</code>没有关联</p>
<a id="more"></a>
<h2 id="js将多层嵌套的数组转换为一层数组"><a href="#js将多层嵌套的数组转换为一层数组" class="headerlink" title="js将多层嵌套的数组转换为一层数组"></a>js将多层嵌套的数组转换为一层数组</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">]</span>

<span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">transfer</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">level</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">let</span> list <span class="token operator">=</span> <span class="token keyword">this</span>
  <span class="token keyword">const</span> <span class="token function-variable function">flat</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">list</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> list<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">prev<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
      next <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span> <span class="token operator">?</span> next <span class="token operator">:</span> <span class="token punctuation">[</span>next<span class="token punctuation">]</span>
      <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">...</span>prev<span class="token punctuation">,</span> <span class="token operator">...</span>next<span class="token punctuation">]</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token parameter">level <span class="token operator">></span> <span class="token number">0</span></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    list <span class="token operator">=</span> <span class="token function">flat</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span>
    level<span class="token operator">--</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">return</span> list
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>let list = this</code>调用时候的数组，在原型链上的东西，使用时即调用本身。</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>css布局问题</title>
    <url>/2021/04/05/css%E5%B8%83%E5%B1%80%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="css-布局问题"><a href="#css-布局问题" class="headerlink" title="css 布局问题"></a>css 布局问题</h1><h2 id="让一个块级元素垂直居中的方法"><a href="#让一个块级元素垂直居中的方法" class="headerlink" title="让一个块级元素垂直居中的方法"></a>让一个块级元素垂直居中的方法</h2><h3 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h3><ul>
<li><p>利用弹性布局实现，在父容器中添加</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.out</span> <span class="token punctuation">&#123;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 500px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 500px<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> skyblue<span class="token punctuation">;</span>
  <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>
  <span class="token property">align-items</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span> <span class="token comment">/*垂直居中*/</span>
  <span class="token comment">/*justify-content: center;*/</span> <span class="token comment">/*水平居中*/</span>
<span class="token punctuation">&#125;</span>
<span class="token selector">.in</span> <span class="token punctuation">&#123;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> salmon<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<a id="more"></a>
<h3 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h3></li>
</ul>
<p>设置父元素相对定位，子元素<code>position: absolute;top: 50%;</code>同时 margin-top 值为-(子元素高度的一半)，</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.out</span> <span class="token punctuation">&#123;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 500px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 500px<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> skyblue<span class="token punctuation">;</span>
  <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token selector">.in</span> <span class="token punctuation">&#123;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> salmon<span class="token punctuation">;</span>
  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
  <span class="token property">top</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>
  <span class="token property">margin-top</span><span class="token punctuation">:</span> -50px<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="第三种方法"><a href="#第三种方法" class="headerlink" title="第三种方法"></a>第三种方法</h3><p>在父容器中设置<code>display:flex</code>，子元素设置<code>align-self:center</code>。</p>
<h3 id="第四种方法"><a href="#第四种方法" class="headerlink" title="第四种方法"></a>第四种方法</h3><p>设置父元素为相对定位，子元素为绝对定位，同时设置子元素的 top,bottom,left,right 值为 0，最后设置<code>margin:auto;</code>这能实现块元素的垂直+水平居中</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.out</span> <span class="token punctuation">&#123;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 500px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 500px<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> skyblue<span class="token punctuation">;</span>
  <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token selector">.in</span> <span class="token punctuation">&#123;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> salmon<span class="token punctuation">;</span>
  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
  <span class="token property">top</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
  <span class="token property">bottom</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
  <span class="token property">left</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
  <span class="token property">right</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
  <span class="token property">margin</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="让一个元素水平居中"><a href="#让一个元素水平居中" class="headerlink" title="让一个元素水平居中"></a>让一个元素水平居中</h2><h3 id="一：行内元素"><a href="#一：行内元素" class="headerlink" title="一：行内元素"></a>一：行内元素</h3><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="二：采用-margin"><a href="#二：采用-margin" class="headerlink" title="二：采用 margin"></a>二：采用 margin</h3><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">margin</span><span class="token punctuation">:</span> 0 auto<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="三：采用-table-实现"><a href="#三：采用-table-实现" class="headerlink" title="三：采用 table 实现"></a>三：采用 table 实现</h3><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.main</span> <span class="token punctuation">&#123;</span>
  <span class="token property">display</span><span class="token punctuation">:</span> table-cell<span class="token punctuation">;</span>
  <span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>
  <span class="token property">vertical-align</span><span class="token punctuation">:</span> middle<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token selector">.box7</span> <span class="token punctuation">&#123;</span>
  <span class="token property">display</span><span class="token punctuation">:</span> inline-block<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="四：利用父元素的-position"><a href="#四：利用父元素的-position" class="headerlink" title="四：利用父元素的 position"></a>四：利用父元素的 position</h3><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.content7</span> <span class="token punctuation">&#123;</span>
  <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token selector">.contentBo7</span> <span class="token punctuation">&#123;</span>
  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
  <span class="token property">left</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
  <span class="token property">right</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 80%<span class="token punctuation">;</span>
  <span class="token property">border</span><span class="token punctuation">:</span> 2px solid red<span class="token punctuation">;</span>
  <span class="token property">margin</span><span class="token punctuation">:</span> 0 auto<span class="token punctuation">;</span>
  <span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="实现元素水平垂直居中"><a href="#实现元素水平垂直居中" class="headerlink" title="实现元素水平垂直居中"></a>实现元素水平垂直居中</h2><h3 id="1-绝对定位，利用负边距"><a href="#1-绝对定位，利用负边距" class="headerlink" title="1.绝对定位，利用负边距"></a>1.绝对定位，利用负边距</h3><p>利用负边距实现子元素居中(相对于父元素(<code>position:relative</code>))，需已知子元素的 width 与 height；且把子元素的 position 设为 absolute，绝对定位；以及设置 left 和 top 为 50%；再加上负边距，margin-left 值为 width 的一半，同样的，margin-top 值为 height 的一半。</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.page</span> <span class="token punctuation">&#123;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 600px<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> pink<span class="token punctuation">;</span>
  <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token selector">.content</span> <span class="token punctuation">&#123;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> paleturquoise<span class="token punctuation">;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
  <span class="token property">top</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>
  <span class="token property">left</span><span class="token punctuation">:</span> 50<span class="token punctuation">;</span>
  <span class="token property">margin-top</span><span class="token punctuation">:</span> -100px<span class="token punctuation">;</span>
  <span class="token property">margin-left</span><span class="token punctuation">:</span> -100px<span class="token punctuation">;</span>
  <span class="token property">overflow</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="2-绝对定位，margin-auto"><a href="#2-绝对定位，margin-auto" class="headerlink" title="2.绝对定位，margin: auto"></a>2.绝对定位，<strong>margin: auto</strong></h3><p>使用绝对定位方式</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.page</span> <span class="token punctuation">&#123;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 600px<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> pink<span class="token punctuation">;</span>
  <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token selector">.content</span> <span class="token punctuation">&#123;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> paleturquoise<span class="token punctuation">;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
  <span class="token property">top</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
  <span class="token property">right</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
  <span class="token property">bottom</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
  <span class="token property">left</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
  <span class="token property">margin</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span>
  <span class="token property">overflow</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="3-Flex"><a href="#3-Flex" class="headerlink" title="3.Flex"></a>3.Flex</h3><p>Flex 布局即为弹性布局，只需将父元素设置三个属性即可。</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.page</span> <span class="token punctuation">&#123;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 600px<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> pink<span class="token punctuation">;</span>
  <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>
  <span class="token property">justify-content</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>
  <span class="token property">align-items</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="4-Transform"><a href="#4-Transform" class="headerlink" title="4.Transform"></a>4.Transform</h3><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.page</span> <span class="token punctuation">&#123;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 600px<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> pink<span class="token punctuation">;</span>
  <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token selector">.content</span> <span class="token punctuation">&#123;</span>
  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
  <span class="token property">top</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>
  <span class="token property">left</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>
  <span class="token property">-webkit-transform</span><span class="token punctuation">:</span> <span class="token function">translate</span><span class="token punctuation">(</span>-50%<span class="token punctuation">,</span> -50%<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token property">-ms-transform</span><span class="token punctuation">:</span> <span class="token function">translate</span><span class="token punctuation">(</span>-50%<span class="token punctuation">,</span> -50%<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">translate</span><span class="token punctuation">(</span>-50%<span class="token punctuation">,</span> -50%<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="5-Table"><a href="#5-Table" class="headerlink" title="5.Table"></a>5.Table</h3><p>模拟表格效果</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.page</span> <span class="token punctuation">&#123;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 600px<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> pink<span class="token punctuation">;</span>
  <span class="token property">display</span><span class="token punctuation">:</span> table<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token selector">.content</span> <span class="token punctuation">&#123;</span>
  <span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>
  <span class="token property">vertical-align</span><span class="token punctuation">:</span> middle<span class="token punctuation">;</span>
  <span class="token property">display</span><span class="token punctuation">:</span> teble-cell<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
</search>
