---
title: 图解http读书笔记
date: 2022-07-28 10:13:36
tags:
		- 'http'
---

# 图解HTTP读书笔记



## 网络基础 TCP/IP

如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信的规则都需要事先确定。不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为协议（protocol）。

TCP/IP有多重理解的方式。

1. 把与互联网相关联的协议集合起来总称为TCP/IP。
2. TCP/IP是指TCP和IP这两种协议。
3. TCP/IP是在IP协议的通信过程中，使用到的协议族的统称。

<!--more-->

### TCP/IP的分层管理

TCP/IP协议族按层次分别分为一下4层：应用层、传输层、网络层和数据链路层。

#### 应用层

应用层决定了向用户提供应用服务时通信的活动。

TCP/IP协议族内预存了各类通用的应用服务。比如：FTP(File Transfer Protocol 文件传输协议)和DNS（Domain Name System，域名系统）服务就是其中两类。

HTTP协议也处于该层。

#### 传输层

传输层对于上层应用层，提供处于网络连接中的两台计算机之间的数据传输。

在传输层有两个性质不同的协议：TCP(Transmission Control Protocol，传输控制协议)和UDP(User Data Protocol，用户数据报协议)。

#### 网络层(又名网络互连层)

网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方。

与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线。

#### 链路层（又名数据链路层，网络接口层）

用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC(Network Interface Card，网络适配器，即网卡)，以及光纤等物理可见部分（还包括连接器等一切传输媒介）。硬件上的范畴均在链路层的作用范之内。

### TCP/IP通信传输流



![](/images/TCPIP通信传输封装.png)

发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。

这种把数据信息包装起来的做法称为封装（encapsulate）。

## 与HTTP关系密切的协议：IP、TCP和DNS

### 负责传输的IP协议

IP(Internet Protocol)网际协议位于网络层。

IP协议的作用是把各种数据包传送给对方。而要保证确实传送到对方哪里，则需要满足各类条件。其中两个重要的条件是IP地址和MAC地址（Media Access Control Address）。

IP地址标明了节点被分配到的地址，MAC地址时值网卡所属的固定地址。IP地址可以和MAC地址进行配对。IP地址可变换，但MAC地址基本上不会更改。

### 使用ARP协议凭借MAC地址进行通信

IP间通信依赖MAC地址。ARP(Address Resolution Protocol)是一种用以解析地址的协议，根据通信方的IP地址就可以反查出对应的MAC地址。

### 负责域名解析的DNS服务

DNS(Domain Name System)服务是和HTTP协议一样位于应用层的协议。它提供域名到IP地址之间的解析服务。

计算机既可以被赋予IP地址，也可以被赋予主机名和域名。

DNS协议提供通过域名查找IP地址，或逆向从IP地址反查域名的服务。

下图可以了解到IP协议、TCP协议和DNS服务在使用HTTP协议的通信过程中各自发挥了哪些作用。

![](/images/输入一个URL经历的过程.png)

### URI和URL

#### 统一资源标识符

URI是Uniform Resource Identifier的缩写。

##### Uniform

规定统一的格式可方便处理多种不同类型的资源，而不用根据上下文环境来识别资源指定的访问方式。

##### Resource

资源的定义是 “可标识的任何东西” 。除了文档文件、图像或服务等能够区别于其他类型的，全都可作为资源。资源不仅可以是单一的，也可以是多数的集合体。

##### Identifier

表示可标识的对象。也称为标识符。

URI就是由某个协议方案表示的资源的定位标识符。协议方案是指访问资源所使用的协议类型名称。 

#### URI格式

表示指定的URI，要使用涵盖全部必要信息的绝对URI、绝对URL以及相对URL。相对URL，是指从浏览器中基本URI处指定的URL。

绝对URI的格式。

![](/images/绝对URI的格式.png)

使用http: 或 https: 等协议方案名获取访问资源时要指定协议类型。不区分字母大小写，最后附一个冒号（:）。



## 简单的HTTP协议

### HTTP协议用于客户端和服务器端之间的通信

HTTP协议和TCP/IP协议族内的其他的众多的协议相同，用于客户端和服务器之间的通信。

请求访问文本或图像等资源的一端称为客户端，而提供资源响应的一端称为服务器端，两端有可能会互换，但就从一条通信路线来说，服务器端和客户端的角色是确定的，而用HTTP协议能够明确区分哪端是客户端，哪端是服务器端。

### 通过请求和响应的交换达成通信

HTTP协议规定请求从客户端发出，最后服务器响应该请求并返回。

请求报文是请求方法、请求URI、协议版本、可选的请求首部字段和内容实体构成的。

![](/images/请求报文.png)

响应报文基本上由协议版本、状态码（表示请求成功或失败的数字代码）、用已解释状态码的原因短语、可选的响应首部字段以及实体主体构成。

![](/images/请求报文.png)



### HTTP是不保存状态的协议

HTTP是一种不保存状态，即无状态协议。HTTP协议自身不对请求和响应之间的通信状态进行保存。也就是说在HTTP这个级别，协议对于发送过的请求或响应都不做持久化处理。

使用HTTP协议，每当有新的请求发送时，就会有对应的新响应产生，协议本身并不保留之前一切的请求或响应报文的信息。这是为了更快的处理大量事务，确保协议的可伸缩性，而特意把HTTP协议设计成如此简单的。

HTTP/1.1虽然是无状态协议，但为了实现期望的保持装填功能，于是引入了Cookie技术。

### 请求URI定位资源

HTTP协议使用URI定位互联网上的资源。正是因为URI的特定功能，在互联网上任意位置的资源都能访问到。

### 告知服务器意图的HTTP方法

#### GET:获取资源

GET方法用来请求访问已被URI识别的资源。

#### POST:传输实体方法

POST方法用来传输实体的主体。

#### PUT:传输文件

PUT方法用来传输文件。就像FTP协议的文件上传一样，要求在请求报文的主题中包含文件内容，然后保存到请求URI指定的位置。

#### HEAD: 获得报文首部

HEAD方法和GET方法一样，只是不返回报文主题部分。用于确认URI的有限性及资源更新的日期时间等。

#### DELETE: 删除文件

DELETE方法用来删除文件，是与PUT相反的方法。DELETE方法按请求URI删除指定的资源。

#### OPTIONS: 询问支持的方法

#### TRACE：追踪路径

TRACE方法是让Web服务器端将之前的请求通信环回给客户端的方法。

#### CONNETCT：要求用隧道协议连接代理

CONNECT方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。主要使用SSL(Secure Sockets Layer，安全套接层)和TLS(Transport Layer Security，传输层安全)协议把通信内容加密后经网络隧道传输。



### 持久连接节省通信量

#### 持久连接

为了解决TCP每次请求都会造成无谓的TCP连接建立和断开，增加通信量的开销。HTTP/1.1和一部分的HTTP/1.0想出了持久连接(HTTP Persistent Connections，也称为HTTP keep-alive 或 HTTP connection reuse)的方法。持久连接的特点是，只要任意一端没有明确提出断开连接，则保持TCP连接状态。

持久连接的好处在于减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。另外，减少开销的那部分时间，使HTTP请求和响应能够更早地结束，这样web页面的显速度也就相应提高了。

在HTTP/1.1中，所有的连接默认都是持久连接的，但在HTTP/1.0内并未标准化。

#### 管线化

持久连接使得多数请求以管线化(pipelining)方式发送成为可能。从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。

### 使用Cookie的状态管理

HTTP是无状态协议，它不对之前发生过的请求和响应的状态进行管理。也就是说，无法根据之前的状态进行本次的请求处理。

无状态协议由于不必保存状态，自然可减少服务器的CPU及内存资源的消耗。

Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态。

Cookie会根据从服务器端发送的响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去。

服务器端发现客户端发送过来的Cookie后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。



![](/images/有无Cookie的请求.png)





## HTTP报文内的HTTP信息

### HTTP报文

用于HTTP协议交互的信息被称为HTTP报文。请求端（客户端）的HTTP报文叫做请求报文，响应端（服务器端）的叫做响应报文。HTTP报文本身是由多行（用CR+LF做换行符）数据构成的字符串文本。

HTTP报文大致可分为报文首部和报文主题两块。

请求报文和响应报文的首部内容由以下数据组成。

![HTTP请求行和状态行](/images/HTTP请求行和状态行.png)

#### 请求行

包含用于请求的方法，请求URI和HTTP版本。

#### 状态行

包含表明响应结果的状态码，原因短语和HTTP版本。

#### 首部字段

包含表示请求和响应的各种条件和属性的各类首部。

一般有4种首部：通用首部、请求首部、响应首部和实体首部。

#### 其他

可能包含HTTP的RFC里未定义的首部（Cookie等）。

### 编码提升传输速率

HTTP在传输数据时可以按照数据原貌直接传输，但也可以在传输过程中通过编码提升传输速率。

#### 报文主体和实体主体的差异

##### 报文（message）

是HTTP通信中的基本单位，由8位组字节流组成，通过HTTP通信传输。

##### 实体（entity）

作为请求或响应的有效载荷数据（补充项）被传输，其内容由实体首部和实体主体组成。

HTTP报文的主题用于传输请求或响应的实体主体。

通常，报文主题等于实体主体。只有当传输中进行编码操作时，实体主题的内容发生变化，才导致它和报文主题产生差异。

#### 压缩传输的内容编码

HTTP协议中有一种被称为内容编码的功能能使邮件容量变小的操作。

内容编码指明应用在实体内容上的编码格式，并保持实体信息原样压缩。内容编码后的实体由客户端接收并负责解码。

常用的内容编码有以下几种。

- gzip(GNU zip)
- compress(UNIX 系统的标准压缩)
- deflate(zlib)
- identity(不进行编码)

#### 分割发送的分块传输编码

在HTTP通信过程中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面。在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面。

把实体主题分块的功能称为分块传输编码（Chunked Transfer Coding）

![分块传输编码](/images/分块传输编码.png)



分块传输编码会将实体主体分成多个部分（块）。每一块都会用十六进制来标记块的大小，而实体主体的最后一块会使用 “0(CR+LF)”来标记。

使用分块传输编码的实体主题会由接收的客户端负责解码，恢复到编码前的实体主体。

HTTP/1.1中存在一种称为传输编码(Transfer Coding)的机制，它可以在通信时按某种编码方式传输，但只定义作用于分块传输编码中。



## 返回结果的HTTP状态码

### 状态码告知从服务器端返回的请求结果

状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。

数字中的第一位指定了响应类别，后两位无分类。相应类别有以下5种。

![状态码的类别](/images/状态码的类别.png)



### 2xx成功

2xx的响应结果表明请求被正常处理了。

#### 200 OK

表示从客户端发来的请求在服务器端被正常处理了。

#### 204 No Content

该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。

#### 206 Partial Content

表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。

### 3xx重定向

3xx响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。

#### 301 Moved Permanently

永久重定向。该状态码表示请求的资源已被分配了新的URI，以后应使用资源现在所指的URI。

#### 302 Found

临时性重定向。该状态码表示请求的资源已被分配了新的URI，希望用户（本次）能使用新的URI访问。

#### 303 See Other

该状态码表示由于请求的资源存在着另一个URI，应使用GET方法定向获取请求的资源。

303与302类似，但302状态码明确表示客户端应当使用GET方法获取资源。

#### 304 Not Modified

该状态码表示客户端发送附带条件的请求时，服务端允许请求访问资源，但未满足条件的情况。

#### 307 Temporary Redirect

临时重定向。

### 4xx客户端错误

#### 400 Bad Request

该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。

#### 401 Unauthorized

该状态码表示发送的请求需要有通过HTTP认证（BASIC认证，DIGEST认证）的认证信息。另外若之前已进行过1次请求，则表示用户认证失败。

#### 403 Forbidden

该状态码表明对请求资源的访问被服务器拒绝了。

#### 404 Not Found

该状态码表明服务器上无法找到请求的资源。

### 5xx服务器错误

#### 500 Internal Server Error 

该状态码表明服务器端在执行请求时发生了错误。

#### 503 Service Unavailable

该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。



## 与HTTP协作的Web服务器

### 用单台虚拟主机实现多个域名

HTTP/1.1规范允许一台HTTP服务器搭建多个Web站点。

在相同的IP地址下，由于虚拟主机可以寄存多个不同主机名和域名的Web网站，因此在发送HTTP请求时，必须在Host首部内完整指定主机名或域名的URI。

### 通信数据转发程序：代理、网关、隧道

HTTP通信时，除客户端和服务器以外，还有一些用于通信数据转发的应用程序，例如代理、网关和隧道。它们可以配合服务器工作。

##### 代理

代理是一种有转发功能的应用程序，它扮演了位于服务器和客户端 “中间人”的角色，接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端。

##### 网关

网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理，有时客户端可能都不会察觉，自己的通信目标是一个网关。

##### 隧道

隧道是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序。

####  代理

代理服务器的基本行为就是接口客户端发送的请求然后转发给其他服务器。代理不改变请求URI，会直接发送给前方持有资源的目标服务器。

持有资源实体的服务器被称为源服务器。从服务器返回的响应经过代理服务器后再传给客户端。

![代理](/images/代理.png)

在HTTP通信过程中，可级联多台代理服务器。请求和响应的转发会经过数台类似锁链一样连接起来的代理服务器。转发时，需要附加Via首部字段以标记出经过的主机信息。

使用代理服务器的理由有：

1. 利用缓存技术减少网络带宽的流量
2. 组织内部针对特定网站的访问控制
3. 以获取访问日志为主要目的

代理有多种使用方法，按两种基准分类。一种是是否使用缓存，另一种是是否会修改报文。

##### 缓存代理

代理转发响应时，缓存代理（Caching Proxy）会预先将资源的副本（缓存）保存在代理服务器上。

当代理再次接收到对相同资源的请求时，就可以不从源服务器那里获取资源，而是将之前缓存的资源作为响应返回。

##### 透明代理

转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理（`TransParent Proxy`）。反之，对报文内容进行加工的代理被称为非透明代理。

#### 网关

网关的工作机制和代理十分相似。而网关能使通信线路上的服务器提供非HTTP协议服务。

利用网关能提高通信的安全性，因为可以在客户端与网关之间的通信线路上加密以确保连接的安全。

#### 隧道

隧道可按要求建立起一条与其他服务器的通信线路，届时使用SSL等加密手段进行通信。隧道的目的是确保客户端能与服务器进行安全的通信。

隧道本身不会去解析HTTP请求。也就是说，请求保持原样中转给之后的服务器。隧道会在通信双方断开连接时结束。

![隧道](/images/隧道.png)



### 保存资源的缓存

缓存是指代理服务器或客户端本地磁盘内保存的资源副本。利用缓存可减少对源服务器的访问，因此也就节省了通信流量和通信时间。

缓存服务器是代理服务器的一种，并归类在缓存代理类型中。当代理转发从服务器返回的响应时，代理服务器将会保存一份资源的副本。

![缓存服务器.png](/images/缓存服务器.png)



### 缓存的有效期限

即便缓存服务器内有缓存，也不能保证每次都会返回对同资源的请求。因为这关系到被缓存资源的有效性问题。

当遇上源服务器上的资源更新时，如果还是使用不变的缓存，那就会演变成返回更新前的 “旧”资源了。

即便存在缓存，也会因为客户端的要求，缓存的有效期等因素，向源服务器确认资源的有效性。若判断缓存失效，缓存服务器将会再次从源服务器上获取新资源。

![缓存的有效期限.png](/images/缓存的有效期限.png)



### 客户端的缓存

缓存不仅可以存在于缓存服务期内，还可以存在客户端浏览器中。客户端缓存称为临时网络文件（Temporary Internet File）。

浏览器缓存如果有效，就不必再向服务器请求相同的资源了，可以直接从本地磁盘内读取。



## HTTP首部

### HTTP报文首部

HTTP协议的请求和响应报文中必定包含HTTP首部。首部内容对客户端和服务器分别处理请求和响应提供所需的信息。

报文首部由几个字段构成

#### HTTP请求报文

在请求中，HTTP报文由方法、URI、HTTP版本、HTTP首部字段等部分构成。

![HTTP请求报文.png](/images/HTTP请求报文.png)



#### HTTP响应报文

在响应中，HTTP报文由HTTP版本、状态码（数字和原因短语）、HTTP首部字段3部分构成。

![HTTP响应报文.png](/images/HTTP响应报文.png)



### HTTP首部字段

#### HTTP首部字段传递重要信息

HTTP首部字段是构成HTTP报文的要素之一。在客户端与服务器之间以HTTP协议进行通信的过程中，无论是请求还是响应都会使用首部字段，它能起到传递额外重要信息的作用。

使用首部字段是为了给浏览器和服务器提供报文主题大小、所使用的语言、认证信息等内容。

#### HTTP首部字段结构

HTTP首部字段是由首部字段名和字段值构成的，中间由冒号 “：”分割。

 例如，在 HTTP 首部中以 Content-Type 这个字段来表示报文主体的 对象类型。

```
Content-Type: text/html
```

字段值对应单个HTTP首部字段可以有多个值，如下所示。

```
Keep-Alive: timeout=15,max=100
```

#### 4种HTTP首部字段类型

HTTP首部字段根据实际用途被分为以下4中类型。

##### 通用首部字段（General Header Fields）

请求报文和响应报文两方都会使用的首部。

##### 请求首部字段（Request Header Fields）

从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。

##### 响应首部字段（Response Header Fields）

从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。

##### 实体首部字段（Entity Header Fields）

针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等于实体有关的信息。

#### HTTP/1.1首部字段一览

通用首部字段

![HTTP首部字段1.png](/images/HTTP首部字段1.png)

![请求首部字段.png](/images/请求首部字段.png)

![响应首部字段.png](/images/响应首部字段.png)

![实体首部字段.png](/images/实体首部字段.png)

#### End-to-end 首部和 Hop-by-hop 首部

HTTP首部字段将定义成缓存代理和非缓存代理的行为，分为2种类型。

##### 端到端首部(End-to-end Header)

分在此类别中的首部会转发给请求 / 响应对应的最终接收目标，且必须保存在由缓存生成的响应中，另外规定它必定被转发。

##### 逐跳首部（Hop-by-hop Header）

分在此类别中的首部只对单次转发有效，会因通过缓存或代理而不再转发。



### HTTP / 1.1 通用首部字段

通用首部字段是指，请求报文和响应报文双方都会使用的首部。

#### Cache-Control

通过指定首部字段Cache-Control的指令，就能操作缓存的工作机制。

指令的参数是可选的，多个指令之间通过 “，”分割。首部字段Cache-Control的指令可用于请求及响应式。

```
Cache-Control:private, max-age=0, no-cache
```

####  Cache-Control指令一览

![缓存请求指令.png](/images/缓存请求指令.png)



![缓存响应指令.png](/images/缓存响应指令.png)



#### Connection

Connection首部字段具备如下两个作用。

- 控制不再转发给代理的首部字段
- 管理持久连接

##### 控制不在转发给代理的首部字段

![不在转发给代理的首部字段.png](/images/不在转发给代理的首部字段.png)

在客户端发送请求和服务器返回响应内，使用Connection首部字段，可控制不再转发给代理的首部字段。

##### 管理持久连接

HTTP/1.1版本的默认连接都是持久连接。为此，客户端会在持久连接上连续发送请求。当服务器端想明确断开连接时，则指定Connection首部字段的值为Close。

![HTTP警告码.png](/images/HTTP警告码.png)



### 请求首部字段

请求首部字段是从客户端往服务器端发送请求报文中所使用的字段，用于补充请求的附加信息、客户端信息、对响应内容相关的优先级等内容。

### 响应首部字段

响应首部字段是由服务器端向客户端返回响应报文中所使用的字段，用于补充响应的附加信息、服务器信息，以及对客户端的附加要求等信息。

### 为Cookie服务的首部字段

Cookie的工作机制是用户识别及状态管理。Web网站为了管理用户的状态会通过Web浏览器，把一些数据临时写入用户的计算机内。接着当用户访问该Web网站时，可通过通信方式取回之前发放的Cookie。

调用Cookie时，由于可校验Cookie的有效期，以及发送方的域、路径、协议等信息，所以正规发布的Cookie内的数据不会因来自其他Web站点和攻击者的攻击而泄露。



## 确保Web安全的HTTPS

### HTTP的缺点

HTTP主要有这些不足：

- 通信使用明文，内容可能会被窃听
- 不验证通信方的身份，因此有可能遭遇伪装
- 无法证明报文的完整性，所以有可能已遭篡改

#### 通信使用明文可能会被窃听

由于HTTP本身不具备加密的功能，所以也无法做到对通信整体进行加密。即，HTTP报文使用明文方式发送。

##### TCP/IP 是可能被窃听的网络

互联网是由能连通到全世界的网络组成的。无论世界哪个角落的服务器在和客户端通信时，再次通信线路上的某些网络设备、光缆、计算机等都不可能是个人的私有物。

##### 加密处理防止被窃听

- 通信的加密

  一种方式就是将通信加密。HTTP协议中没有加密机制，但可以通过和SSL（Secure Socket Layer，安全套接层）或TLS（Transport Layer Security，安全层传输协议）的组合使用，加密HTTP的通信内容。

  用SSL建立安全通信线路之后，就可以在这条线路上进行HTTP通信了。与SSL组合使用的HTTP被称为HTTPS（HTTP Secure，超文本传输安全协议）或HTTP over SSL。

  ![通信的加密.png](/images/通信的加密.png)

- 内容的加密

  还有一种将参与通信的内容本身加密的方式。由于HTTP协议中没有加密机制，那么久对HTTP协议传输的内容本身加密。即把HTTP报文里所含的内容进行加密处理。

#### 不验证通信方的身份就可能遭遇伪装

HTTP协议中的请求和响应不会对通信方进行确认。也就是说存在 “服务器是否就是发送请求中URI真正指定的主机，返回的响应是否真的返回到实际提出请求的客户端”等类似问题。

- 任何人都可发起请求

  在HTTP协议通信时，由于不存在确认通信方的处理步骤，任何人都可以发起请求。因此不确认通信方，会存在以下各种隐患。

  - 无法确定请求发送至目标的Web服务器是否是按真实意图返回响应的那台服务器。有可能是已伪装的Web服务器。
  - 无法确定响应返回的客户端是否是按真实意图接收响应的那个客户端。有可能是已伪装的客户端。
  - 无法确定正在通信的对方是否具备访问权限。因为某些Web服务器上保存着重要的信息，只想发给特定用户通信的权限。
  - 无法判定请求时来自何方、出自谁手。
  - 即使是无意义的请求也会照单全收。无法组织海量请求下的DoS攻击（Denial of Service，拒绝服务攻击）

- 查明对方的证书

  虽然使用HTTP协议无法确定通信方，但如果使用SSL则可以。SSL不仅提供加密处理，而且还使用了一种被称为证书的手段，可用于确定方。

  证书由值得信任的第三方机构颁发，用以证明服务器和客户端是实际存在的。

#### 无法证明报文完整性，可能已遭篡改

所谓完整性是指信息的准确度。如无法证明其完整性，通常也就意味着无法判断信息是否准确。

- 接收到的内容可能有误

  由于HTTP协议无法证明通信的报文完整性，因此，在请求或响应送出之后直到对方接收之前的这段时间内，即使请求或响应的内容遭到篡改，也没有办法获悉。

  请求或响应在传输途中，遭攻击者拦截并篡改内容的攻击称为中间人攻击。

- 如何防止篡改

  常用的是MD5和SHA-1等散列值校验的方法，以及用来确认文件的数字签名方法。

  PGP是用来证明创建文件的数字签名，MD5是由单向函数生成的散列值。

### HTTP +  加密 + 认证 + 完整性保护 = HTTPS

#### HTTP加上加密处理和认证以及完整性保护后即是HTTPS

![使用HTTP通信.png](/images/使用HTTP通信.png)

#### HTTPS是身披SSL外壳的HTTP

HTTPS并非是应用层的一种新协议。只是HTTP通信接口部分用SSL（Secure Socket Layer）和TLS（Transport Layer Security）协议代替而已。

通常HTTP直接和TCP通信。当使用SSL时，则演变成先和SSL通信，再由SSL和TCP通信了。

![https-https](/images/HTTP-HTTPS.png)

在采用SSL后，HTTP就拥有了HTTPS的加密、证书和完整性保护这些功能。

SSL是独立于HTTP的协议，所以不光是HTTP协议，其他运行在应用层的SMTP和Telnet等协议均可配合SSL协议使用。可以说SSL是当今世界上应用最为广泛的网络安全技术。

#### 相互交换密钥的公开密钥加密技术

SSL采用一种叫做公开密钥加密（Public-key cryptography）的加密处理方式。

近代的加密方法中加密算法是公开的，而密钥却是保密的。

加密和解密都会用到密钥。没有密钥就无法对密码解密。

- 共享密钥加密的困境

  ​	加密和解密同用一个密钥的方式称为共享密钥加密，也被叫做对称密钥加密。

  ![对称密钥加密.png](/images/对称密钥加密.png)

  以共享密钥方式加密时必须将密钥也发给对方。但是怎样才能安全地转交？在互联网上转发密钥时，如果通信被监听那么密钥就可能会落入攻击者之手，同时也就失去了加密的意义。

  

- 使用两把密钥的公开密钥加密

  公开密钥加密方式很好地解决了共享密钥加密的困难。

  公开密钥加密使用一对非对称的密钥。一把叫做私有密钥，另一把叫做公开密钥。顾名思义，私有密钥不能让其他任何人知道，而公开密钥则可以随意发布，任何人都可以获得。

  使用公开密钥加密方式，发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。利用这种方式，不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走。

  另外，要想根据密文和公开密钥，恢复到信息原文是异常困难的，因为解密过程就是在对离散对数进行求值。如果能对一个非常大的整数做到快速地因式分解，那么密码破解还是存在希望的。

  

  ![使用两把密钥加密.png](/images/使用两把密钥加密.png)

  

- HTTPS采用混合加密机制

  HTTPS采用共享密钥加密和公开密钥加密两者并用的混合加密机制。若密钥能够实现安全交换，那么有可能会考虑仅使用公开密钥加密来通信。但是公开密钥加密与共享密钥加密相比，其处理速度要慢。

  所以应充分利用两者各自的优势，将多种方法组合起来用于通信。在交换密钥环节使用公开密钥加密方式，之后的建立通信交换报文阶段则使用共享密钥加密方式。

  ![混合加密机制.png](/images/混合加密机制.png)

  

#### 证明公开密钥正确性的证书

为了防止公开密钥在传输途中被攻击者替换掉，可以使用由数字证书认证机构（CA，Certificate Authority）和其相关机关颁发的公开密钥证书。

数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场上。

数字证书认证机构的业务流程：

1. 服务器的运营人员向数字证书认证机构提出公开密钥的申请。
2. 数字证书认证机构在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公钥证书后绑定在一起。

服务器会将这份由数字证书认证机构颁发的公钥证书发送给客户端，以进行公开密钥加密方式通信。公钥证书也可叫做数字证书或直接称为证书。

接到证书的客户端可使用数字证书认证机构的公开密钥，对那张证书上的数字签名进行验证，一旦验证通过，客户端便可明确两件事：

一，认证服务器的公开密钥的是真实有效的数字证书认证机构。二，服务器的公开密钥时值得信赖的。

![证明公开密钥正确性的证书.png](/images/证明公开密钥正确性的证书.png)

- 可证明组织真实性的EV SSL证书

  证书的一个作用是用来证明作为通信一方的服务是否规范，另外一个作用是可去人对方服务器背后运营的企业是否真实存在。拥有该特性的证书就是EV SSL证书（Extend Validation SSL Certificate）。

  EV SSL证书是基于国际标准的认证指导方针颁发的证书。

  持有EV SSL证书的Web网站的浏览器地址栏处的背景色是绿色的。

- 用以确认客户端的客户端证书

  HTTPS还可以使用客户端证书。以客户端证书进行客户端认证，证明服务器正在通信的对方始终是预料之内的客户端，其作用跟服务器证书如出一辙。

- 认证机构信誉第一

- 由自认证机构颁发的证书称为自签名证书

#### HTTPS的安全通信机制

HTTPS的通信步骤。

![HTTPS通信.png](/images/HTTPS通信.png)

步骤1：客户端通过发送Client Hello报文开始SSL通信。报文中包含客户端支持的SSL的指定版本、加密组件列表（所使用的加密算法以及密钥长度等）。

步骤2：服务器可进行SSL通信时，会以Server Hello报文作为应答。和客户端一样，在报文中包含SSL版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。

步骤3：之后服务器发送Certificate报文。报文中包含公开密钥证书。

步骤4：最后服务器发送Server Hello Done报文通知客户端，最初阶段的SSL握手协商部分结束。

步骤5：SSL第一次握手结束之后，客户端以Client Key Exchange报文作为回应。报文中包含通信加密中使用的一种被称为Per-master secret的随机密码串。该报文已用步骤3中的公开密钥进行加密。

步骤6：接着客户端继续发送Change Cipher Spec报文。该报文会提示服务器，在此报文之后的通信会采用Pre-master secret密钥加密。

步骤7：客户端发送Finished报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准。

步骤8：服务器同样发送Change Cipher Spec报文。

步骤9：服务器同样发送Finished报文。

步骤10：服务器和客户端的Finished报文交换完毕之后，SSL连接就算建立完成。当然，通信会受到SSL的保护。从此处开始进行应用层协议的通信，即发送HTTP请求。

步骤11：应用层协议通信，即发送HTTP响应。

步骤12：最后由客户端断开连接，断开连接时，发送close_notify报文。

![仅使用公开密钥进行通信的过程.png](/images/仅使用公开密钥进行通信的过程.png)

- SSL速度慢吗

  HTTPS也存在一些问题，当使用SSL时，它的处理速度会变慢。

  SSL的慢分两种。一种是通信慢。另一种是由于大量消耗CPU及内存等资源，导致处理速度变慢。

  和使用HTTP相比，网络负载可能会变慢2到100倍。除去和TCP连接、发送HTTP请求、响应以外，还必须进行SSL通信，因此整体上处理通信量不可避免会增加。

  另一点是SSL必须进行加密处理。在服务器和客户端都需要进行加密和解密的运算处理。因此从结果上讲，比起HTTP会更多地消耗服务器和客户端的硬件资源，导致负载增强。

  ```
  为什么不一直使用 HTTPS
  既然 HTTPS 那么安全可靠，那为何所有的 Web 网站不一直使用
  HTTPS ？ 
  其中一个原因是，因为与纯文本通信相比，加密通信会消耗更多的
  CPU 及内存资源。如果每次通信都加密，会消耗相当多的资源，平摊到一
  台计算机上时，能够处理的请求数量必定也会随之减少。 
  因此，如果是非敏感信息则使用 HTTP 通信，只有在包含个人信息等敏
  感数据时，才利用 HTTPS 加密通信。 
  特别是每当那些访问量较多的 Web 网站在进行加密处理时，它们所承
  担着的负载不容小觑。在进行加密处理时，并非对所有内容都进行加密处理，
  而是仅在那些需要信息隐藏时才会加密，以节约资源。
  ```

## 确认访问用户身份的认证

### 何为认证

计算机本身无法判断使用者身份。

核对的信息通常是指以下这些。

- 密码：只有本人才会知道的字符串信息。
- 动态令牌：仅限本人持有的设备内显示的一次性密码。
- 数字证书：仅限本人（终端）持有的信息。
- 生物认证：指纹和虹膜的本人的生理信息。
- IC卡等：仅限本人持有的信息。

#### HTTP使用的认证方式

HTTP/1.1 使用的认证方式如下所示。

- BASIC认证（基本认证）
- DIGEST认证（摘要认证）
- SSL客户端认证
- FormBase认证（基于表单认证）

### BASIC认证

BASIC认证（基本认证）是从HTTP/1.0 就定义的认证方式。是Web服务器与通信客户端之间进行的认证方式。

#### BASIC认证的认证步骤

![BASIC认证概要.png](/images/BASIC认证概要.png)

1. 当请求的资源需要BASIC认证时，服务器会随状态码401 Authorization Required，返回带WWW-Authenticate首部字段的响应。该字段内包含认证的方式（BASIC）及Request-URI安全域字符串（realm）。
2. 接收到状态码401的客户端为了通过BASIC认证，需要将用户ID及密码发送给服务器。发送的字符串内容是由用户ID和密码构成，两者中间以冒号（：）连接后，再经过Base64编码处理。
3. 接收到包含首部字段Authorization请求的服务器，会对认证信息的正确性进行验证。如验证通过，则返回一条包含Request-URI资源的响应。

### SSL客户端认证

SSL客户端认证是借由HTTPS的客户端证书完成认证的方式。凭借客户端证书认证，服务器可确认访问是否来自已登录的客户端。

#### SSL客户端认证的认证步骤

为达到SSL客户端认证的目的，需要事先将客户端证书分发给客户端，且客户端必须安装此证书。

1. 接收到需要认证资源的请求，服务器会发送Certificate Request报文，要求客户端提供客户端证书。
2. 用户选择将发送的客户端证书后，客户端会把客户端证书信息以Client Certificate报文方式发送给服务器。
3. 服务器验证客户端证书通过后方可领取证书内客户端的公开密钥，然后开始HTTPS加密通信。

#### SSL客户端认证采用双因素认证

在多数情况下，SSL客户端认证不会仅依靠证书完成认证，一般会基于表单认证组合形成一种双因素认证来使用。所谓双因素认证就是指，认证过程中不仅需要密码这一个因素，还需要申请认证者提供其他持有信息，从而作为另一个因素，与其组合使用的认证方式。

### 基于表单认证

基于表单的认证方法不是在HTTP协议中定义的。客户端会向服务器上的Web应用程序发送登录信息，按登录信息的验证结果认证。

多数情况下，输入已事先登录的用户ID和密码等登录信息后，发送给Web应用程序，基于认证结果来决定认证是否成功。

#### 认证多半为基于表单认证

#### Session管理及Cookie应用

基于表单认证本身是通过服务器端的Web应用，将客户端发送过来的用户ID和密码和之前登录过的信息做匹配来进行认证的。

但鉴于HTTP是无状态协议，之前已认证成功用户状态无法通过协议层面保存下来。即，无法实现状态管理，因此即使当该用户下一次继续访问，也无法区分他与其他的用户。于是我们会使用Cookie来管理Session，以弥补HTTP协议中不存在的状态管理功能。

![Session管理及Cookie状态管理.png](/images/Session管理及Cookie状态管理.png)

1. 客户端把用户ID和密码等登录信息放入报文的实体部分，通常是以POST方法把请求发送给服务器。
2. 服务器会发放用以识别用户的Session ID。通过验证从客户端发送过来的登录信息进行身份认证，然后把用户的认证状态与Session ID绑定后记录在服务器端。
   向客户端返回响应时，会在首部字段Set-Cookie内写入Session ID。
3. 客户端接收到从服务器端发来的Session ID后，会将其作为Cookie保存在本地。下次向服务器发送请求时，浏览器会自动发送Cookie，所以Session ID也随之发送到服务器。服务器端可通过验证接收到额Session ID识别用户和其认证状态。

## 基于HTTP的功能追加协议

### 基于HTTP的协议

HTTP功能上的不足可通过创建一套全新的协议来弥补。可是目前基于HTTP的Web浏览器的使用环境已遍布全球，因此无法完全抛弃HTTP。有一些新协议的规则是基于HTTP的，并在此基础上添加了新的功能。

### 消除HTTP瓶颈的SPDY

#### HTTP的瓶颈

使用HTTP协议探知服务器上是否有内容更新，就必须频繁地从客户端到服务器端进行确认。如果服务器上没有内容更新，那么就会产生徒劳的通信。

若想在现有Web实现所需的功能，以下这些HTTP标准就会成为瓶颈。

- 一条连接上只可发送一个请求
- 请求只能从客户端开始。客户端不可以接收除响应以外的指令。
- 请求 / 响应首部未经压缩就发送。首部信息越多延迟越大。
- 发送冗长的首部。每次互相发送相同的首部造成的浪费较多。
- 可任意选择数据压缩格式。非强制压缩发送。

![以前的HTTP通信.png](/images/以前的HTTP通信.png)

**Ajax的解决方法**

Ajax（Asynchronous JavaScript and XML，异步JavaScript与XML技术）是一种有效利用JavaScript和DOM（Document Object Model）的操作，以达到局部Web页面替换加载的异步通信手段。和以前的同步通信相比，由于它只更新一部分页面，响应中传输的数据量会因此而减少，这一优点显而易见。

Ajax的核心技术是名为XMLHttpRequest的API，通过JavaScript脚本语言的调用就能和服务器进行HTTP通信。借由这种手段，就能从已加载完毕的Web页面上发起请求，只更新局部页面。

而利用Ajax实时地从服务器获取内容，有可能会导致大量请求产生，另外，Ajax仍未解决HTTP协议本身存在的问题。

![Ajax通信.png](/images/Ajax通信.png)

**Comet的解决办法**

一旦服务器端有内容更新了，Comet不会让请求等待，而是直接给客户端返回响应。这是一种通过延迟应答，模拟实现服务器端向客户端推送的功能。

通常，服务器端接收到请求，在处理完毕后就会立即返回响应，但为了实现推送功能，Comet会先将响应置于挂起状态，当服务器端有内容更新时，再返回该响应。

内容上虽然可以做到实时更新，但为了保留响应，一次连接的持续时间也变长了。期间，为了维持连接会消耗更多的资源。另外Comet也仍未解决HTTP协议本身存在的问题。

![Comet通信.png](/images/Comet通信.png)

#### SPDY的设计与功能

SPDY没有完全改写HTTP协议，而是在TCP/IP的应用层与运输层之间通过新加会话层的形式运作。同时，考虑到安全性问题，SPDY规定通信中使用SSL。

SPDY以会话层的形式加入，控制对数据的流动，但还是采用HTTP建立通信连接。因此，可照常使用HTTP的GET和POST等方法、Cookie以及HTTP报文等。

![SPDY的设计.png](/images/SPDY的设计.png)

使用SPDY后，HTTP协议额外获得以下功能。

- **多路复用流**

  通过单一的TCP连接，可以无限制处理多个HTTP请求。所有请求的处理都在一条TCP连接上完成，因此TCP的处理效率得到提高。

- **赋予请求优先级**

  SPDY不仅可以无限制地并发处理请求，还可以给请求逐个分配优先级顺序。这样主要是为了在发送多个请求时，解决因带宽低而导致响应变慢的问题。

- **压缩HTTP首部**

  压缩HTTP请求和响应的首部。这样一来，通信产生的数据包数量和发送的字节数就更少了。

- **推送功能**

  支持服务器主动向客户端推送数据的功能。这样，服务器可直接发送数据，而不必等待客户端的请求。

- **服务器提示功能**

  服务器可以主动提示客户端请求所需的资源。由于在客户端发现资源之前就可以获知资源的存在，因此在资源已缓存等情况下，可以避免发送不必要的请求。

#### SPDY消除Web瓶颈了吗

因为SPDY基本上只是将单个域名的通信多路复用，所以当一个Web网站上使用多个域名下的资源，改善效果就会受到限制。

SPDY的确是一个可有效清除HTTP瓶颈的技术，但很多Web网站存在的问题并非仅仅是由HTTP瓶颈所导致。对Web本身的速度提升，还应该从其他可细致钻研的地方入手。

### 使用浏览器进行全双工通信的WebSocket

利用Ajax和Comet技术进行通信可以提升Web的浏览速度。但问题在于通信若使用HTTP协议，就无法彻底解决瓶颈问题。WebSocket网络技术正是为解决这些问题而实现的一套新协议以及API。

#### WebSocket的设计与功能

WebSocket，即Web浏览器与Web服务器之间全双工通信标准。其中，WebSocket协议由IETF定位标准，WebSocket API由W3C定位标准。

#### WebSocket协议

一旦Web服务器与客户端之间建立起WebSocket协议的通信连接，之后所有的通信都依靠这个专用协议进行。通信过程中可互相发送JSON、XML、HTML或图片等任意格式的数据。

由于是建立在HTTP基础上的协议，因此连接的发起方仍是客户端，而一旦确立WebSockt通信连接，不论服务器还是客户端，任意一方都可直接向对方发送报文。

- **推送功能**

  支持由服务器向客户端推送数据的推送功能。这样，服务器可直接发送数据，而不必等待客户端的请求。

- **减少通信量**

  只要建立起WebSocket连接，就希望一直保持连接状态。和HTTP相比，不但每次连接时的总开销减少，而且由于WebSocket的首部信息很小，通信量也相应减少了。

为了实现WebSocket通信，在HTTP连接建立之后，需要完成一次握手的步骤。

- 握手请求

  为了实现WebSocket通信，需要用到HTTP的Upgrade首部字段，告知服务器通信协议发生改变，以达到握手的目的。

  ![WebSocket握手请求.png](/images/WebSocket握手请求.png)

  Sec-WebSocket-Key字段内记录着握手过程中必不可少的键值。Sec-WebSocket-Protocol字段内记录使用的子协议。

  子协议按WebSocket协议标准在连接分开使用时，定义那些连接的名称。

- 握手响应

  ![WebSocket握手响应.png](/images/WebSocket握手响应.png)

  Sec-WebSocket-Accept的字段值是由握手请求中的Sec-WebScoket-Key的字段值生成的。

  成功握手确立WebSocket连接之后，通信时不再使用HTTP的数据帧，而采用WebSocket独立的数据帧。

  ![WebSocket通信.png](/images/WebSocket通信.png)

- WebSocket API

  调用WebSocket API，每50ms发送一次数据的实例。

  ```js
  var socket = new WebSocket('ws://game.example.com:12010/updates');
  socket.onopen = function () {
   setInterval(function() {
   if (socket.bufferedAmount == 0)
   socket.send(getUpdateData());
   }, 50);
  };
  ```

### 期盼已久的HTTP/2.0

#### **HTTP/2.0的特点**

HTTP/2.0的目标是改善用户在使用Web时的速度体验，由于基本上都会先通过HTTP/1.1与TCP连接。

- SPDY
- HTTP Speed + Mobility
- Network-Friendly HTTP Upgrade

HTTP Speed ＋ Mobility 由微软公司起草，是用于改善并提高移动 端通信时的通信速度和性能的标准。它建立在Google公司提出的SPDY与WebSocket的基础之上。

Network-Friendly HTTP Upgrade主要是在移动端通信时改善HTTP性能的标准。

#### HTTP/2.0的7项技术及讨论

| 压缩                                                | SPDY、Friendly             |
| --------------------------------------------------- | -------------------------- |
| 多路复用                                            | SPDY                       |
| TLS义务化                                           | Speed + Mobility           |
| 协商                                                | Speed + Mobility，Friendly |
| 客户端拉曳（Client Pull）/服务器推送（Server Push） | Speed + Mobility           |
| 流量控制                                            | SPDY                       |
| WebSocket                                           | Speed + Mobility           |

### Web服务器管理文件的WebDAV

webDAV（Web-based Distributed Authoring and Versioning，基于万维网的分布式创作和版本控制）是一个可对Web服务器上的内容直接进行文件复制、编辑等操作的分布式文件系统。

除了创建、删除文件等基本功能，它还具备文件创建者管理、文件编辑过程中禁止其他用户内容覆盖的加锁功能，以及对文件内容修改的版本控制功能。

![WebDAV.png](/images/WebDAV.png)

使用HTTP/1.1的PUT方法和DELETE方法，就可以对Web服务器上的文件进行创建和删除操作。

## 构建Web内容的技术

### 与Web服务器及程序协作的CGI

CGI是指Web服务器在接收到客户端发送过来的请求后转发给程序的一组机制。在CGI的作用下，程序会对请求内容做出响应的动作，比如创建HTML等动态内容。

使用CGI的程序叫做CGI程序，通常是用Perl、PHP、Ruby和C等编程语言编写而成。

![CGI.png](/images/CGI.png)

### 数据发布的格式及语言

#### 可扩展标记语言

XML（eXtensible Markup Language，可扩展标记语言）是一种可按应用目标进行扩展的通用标记语言。旨在通过使用XML，使互联网数据共享变得更容易。

XML和HTML都是从标准通用标记语言SGML（Standard Generalized Markup Languag）简化而成。与HTML相比，它对数据的记录方式做了特殊处理。

#### 发布更新的信息的RSS/Atom

RSS（简易信息聚合，也叫聚合内容）和Atom都是发布新闻或博客日志等更新信息文档的格式的总称。两者都用到了XML。

#### JavaScript衍生的轻量级易用JSON

JSON（JavaScript Object Notation）是一种以JavaScript的对象表示法为基础的轻量级数据标记语言。能够处理的数据类型有false/null/true/对象/数组/数字/字符串，这7种类型。



## Web的攻击技术

### 针对Web的攻击技术

简单的HTTP协议本身并不存在安全问题，因此协议本身几乎不会成为攻击的对象。应用HTTP协议的服务器和客户端，以及运行在服务器上的Web应用等资源才是攻击目标。

#### HTTP不具备必要的安全功能

几乎现今所有的Web网站都会使用会话（session）管理、加密处理等安全性方面的功能，而HTTP协议内并不具备这些功能。

HTTP就是一个通用的单纯协议机制。因此它具备较多优势，但是在安全性方面则呈劣势。

拿远程登录时会用到的SSH协议来说，SSH具备协议级别的认证及会话管理等功能，HTTP协议则没有。另外在架设SSH服务方面，任何人都可以轻易地创建安全等级高的服务，而HTTP即使已架设好服务器，但若想提供服务器基础上的Web应用，很多情况下都需要重新开发。

#### 在客户端即可篡改请求

在Web应用中，从浏览器那接收到的HTTP请求的全部内容，都可以在客户端自由地变更、篡改。所以Web应用可能会接收到与预期数据不相同的内容。

在HTTP请求报文内加载攻击代码，就能发起对Web应用的攻击。通过URL查询字段或表单、HTTP首部、Cookie等途径把攻击代码传入，若这时Web应用存在安全漏洞，那内部信息就会遭到窃取，或被攻击者拿到管理权限。

#### 针对Web应用的攻击模式

- 主动攻击
- 被动攻击

##### 以服务器为目标的主动攻击

主动攻击是指攻击者通过直接访问Web应用，把攻击代码传入的攻击模式。由于该模式是直接针对服务器上的资源进行攻击，因此攻击者需要能够访问到那些资源。

主动攻击模式里具有代表性的攻击是SQL注入攻击和OS命令注入攻击。

![主动攻击.png](/images/主动攻击.png)

##### 以服务器为目标的被动攻击

被动攻击是指利用圈套策略执行攻击代码的攻击模式。在被动攻击过程中，攻击者不直接对目标Web应用访问发起攻击。

被动攻击通常的攻击模式如下所示。

1. 攻击者诱使用户触发已设置好的陷阱，而陷阱会启动发送已嵌入攻击代码的HTTP请求。
2. 当用户不知不觉中招之后，用户的浏览器或邮件客户端就会触发这个陷阱。
3. 中招后的用户浏览器会把含有攻击代码的HTTP请求发送给作为攻击目标的Web应用，运行攻击代码。
4. 执行完攻击代码，存在安全漏洞的Web应用会成为攻击者的跳板，可能导致用户所持的Cookie等个人信息被窃取，登录状态中的用户权限遭恶意滥用等后果。
   被动攻击模式中具有代表性的攻击是跨站脚本攻击和跨站点请求伪造。

![被动攻击.png](/images/被动攻击.png)

##### 利用用户的身份攻击企业内部网络

利用被动攻击，可发起对原本从互联网上无法直接访问的企业内网等网络的攻击。只要用户踏入攻击者预先设好的陷阱，在用户能够访问到的网络范围内，即使是企业内网也同样会受到攻击。

![利用被动攻击对企业内网发动攻击.png](/images/利用被动攻击对企业内网发动攻击.png)

### 因输出值转义不完全引发的安全漏洞

实施Web应用的安全对策可大致分为以下两部分。

- 客户端的验证
- Web应用端的验证
  - 输入值验证
  - 输出值转义

#### 跨站脚本攻击

跨站脚本攻击（Cross-Site Scripting, XSS）是指通过存在安全漏洞的Web网站注册用户的浏览器内运行非法的HTML标签或JavaScript进行的一种攻击。

跨站脚本攻击有可能造成以下影响。

- 利用虚假输入表单骗取用户个人信息。
- 利用脚本窃取用户的Cookie值，被害者在不知情的情况下，帮助攻击者发送恶意请求。
- 显示伪造的文章或图片。

##### XSS是攻击者利用预先设置的陷阱触发的被动攻击

跨站脚本攻击属于被动攻击模式，因此攻击者会事先布置好用于攻击的陷阱。

#### SQL注入攻击

SQL注入是指针对Web应用使用的数据库，通过运行非法的SQL而产生的的攻击。

#### OS命令注入攻击

OS命令注入攻击（OS Command Injection）是指通过Web应用，执行非法的操作系统命令达到攻击的目的。只要在能调用Shell函数的地方就有存在被攻击的风险。

#### HTTP首部注入攻击

HTTP首部注入攻击（HTTP Header Injection）是指攻击者通过在响应首部字段内插入换行，添加任意响应首部或主题的一种攻击。属于被动攻击模式。

向首部主体内添加内容的攻击被称为HTTP响应阶段攻击（HTTP Response Splitting Attack）。

HTTP首部注入攻击有可能会造成以下一些影响。

- 设置任何Cookie信息
- 重定向至任意URL
- 显示任意的主题（HTTP响应截断攻击）

#### 邮件首部注入攻击

邮件首部注入是指Web应用中的邮件发送功能，攻击者通过向邮件首部To或Subject内任意添加非法内容发起的攻击。

#### 目录遍历攻击

目录遍历攻击是指对本无意公开的文件目录，通过非法截断其目录路径后，达成访问目的的一种攻击。这种攻击有时也称为路径遍历攻击。

#### 远程文件包含漏洞

远程文件包含漏洞是指当部分脚本内容需要从其他文件读入时，攻击者利用指定外部服务器的URL充当依赖文件，让脚本读取之后，就可运行任意脚本的一种攻击。

### 因设置或设计上的缺陷引发的安全漏洞

因设置或设计上的缺陷引发的安全漏洞是指，错误设置Web服务器，或是由设计上的一些问题引起的安全漏洞。

#### 强制浏览

强制浏览安全漏洞是指从安置在Web服务器上的公开目录下的文件中，浏览那些原本非资源公开的文件。

强制浏览有可能会造成以下一些影响。

- 泄露顾客的个人信息等重要情报
- 泄露原本需要具有访问权限的用户才可查阅的信息内容
- 泄露为外连到外界的文件

#### 不正确的错误消息处理

不正确的错误消息处理的安全漏洞是指，Web应用的错误信息内包含对攻击者有用的信息。与Web应用有关的主要错误信息如下所示。

- Web应用抛出的错误消息
- 数据库等系统抛出的错误消息

#### 开放重定向

开放重定向是一种对指定的任意URL作重定向跳转的功能。

### 因会话管理疏忽引发的安全漏洞

会话管理是用来管理用户状态的必备功能，但是如果在会话管理上有所疏忽，就会导致用户的认证状态被窃取等后果。

#### 会话劫持

会话劫持是指攻击者通过某种手段拿到了用户的会话ID，并非法使用此会话ID伪装成用户，达到攻击的目的。

几种攻击者可获得会话ID的途径

- 通过非正规的生成方法推测会话ID
- 通过窃听或XSS攻击盗取会话ID
- 通过会话固定攻击强行获取会话ID

#### 会话固定攻击

对以窃取目标会话ID为主动攻击手段的会话劫持而言，会话固定攻击会导致用户使用攻击者指定的会话ID，属于被动攻击。

![会话固定攻击案例.png](/images/会话固定攻击案例.png)

#### 跨站点请求伪造

跨站点请求伪造攻击是指攻击者通过设置好的陷阱，强制对已完成认证的用户进行非预期的个人信息或设定信息等某些状态更新，属于被动攻击。

跨站点请求伪造有可能会造成以下等影响。

- 利用已通过认证的用户权限更新设定信息等
- 利用已通过认证的用户权限购买商品
- 利用已通过认证的用户权限在留言板上发表言论

![跨站点请求伪造的攻击案例.png](/images/跨站点请求伪造的攻击案例.png)



### 其他安全漏洞

#### 密码破解

密码破解攻击即算出密码，突破认证。攻击不仅限于Web应用，还包括其他的系统（FTP或SSH等）。

密码破解有以下两种手段。

- 通过网络的密码试错
- 对已加密密码的破解（指攻击者入侵系统，已获得加密或散列处理的密码数据的情况）

##### 通过网络进行密码试错

对Web应用提供的认证功能，通过网络尝试候选密码进行的一种攻击。主要有以下两种方式。

- 穷举法
- 字典攻击

###### 穷举法

穷举法是指对所有密钥集合构成的密钥空间进行穷举。

###### 字典攻击

字典攻击是指利用事先收集好的候选密码，枚举字典中的密码，尝试通过认证的一种攻击手法。

##### 对已加密密码的破解

Web应用在保存密码时，一般不会直接以明文的方式保存，通过散列函数做散列处理或加salt的手段对要保存的密码本身加密。那即使攻击者使用某些手段窃取密码数据，如果想要真正使用这些密码，则必须先通过解码等手段，把加密处理的密码还原成明文形式。

从加密过的数据中导出明文通常有以下几种方法。

- 通过穷举法字典攻击进行类推
- 彩虹表
- 拿到密钥
- 加密算法的漏洞

###### 通过穷举法，字典攻击进行类推

针对密码使用散列函数进行加密处理的情况，采用和穷举法或字典攻击相同的手法，尝试调用相同的散列函数加密候选密码，然后把计算出的散列值与目标散列值匹配，类推出密码。

![穷举法字典攻击进行类推.png](/images/穷举法字典攻击进行类推.png)

###### 彩虹表

彩虹表是由明文密码及与之对应的散列值构成的一张数据库表，是一种通过事先制作庞大的彩虹表，可在穷举法字典攻击等实际破解过程中缩短消耗时间的技巧。

###### 拿到密钥

使用共享密钥加密方式对密码数据进行加密的情况下，如果能通过某种手段拿到加密使用的密钥，也就可以对密码数据解密了。

###### 加密算法的漏洞

考虑到加密算法本身可能存在的漏洞，利用该漏洞尝试解密也是一种可行的方法。

#### 点击劫持

点击劫持是利用透明的按钮或链接做成陷阱，覆盖在Web页面之上。然后诱使用户在不知情的情况下，点击那个链接访问内容的一种手段。这种行为又称为界面伪装。

已设置陷阱的Web页面，表面上内容并无不妥，但早已埋入想让用户点击的链接。当用户点击到透明的按钮时，实际上是点击了已指定透明属性元素的iframe页面。

![点击劫持.png](/images/点击劫持.png)

攻击者在预料用户会点击的Web页面上设下陷阱。

在做过手脚的Web页面上，目标的注销功能页面将作为透明层覆盖在游戏网页上。覆盖时，要保证PLAY按钮与注销按钮的页面所在位置保持一致。

#### DoS攻击

DoS攻击（Denial of Service attack）是一种让运行中的服务呈停止状态的攻击。有时也叫做服务停止攻击或拒绝服务攻击。DoS攻击的对象不仅限于Web网站，还包括网络设备及服务器。

主要有以下两种DoS攻击方式

- 集中利用访问请求造成资源过载，资源用尽的同时，实际上服务也就呈停止状态。
- 通过攻击安全漏洞使服务停止。

其中，集中利用访问请求的DoS攻击，单纯来讲就是发送大量的合法请求。服务器很难分辨何为正常请求，何为攻击请求，因此很难防止DoS攻击。

多台计算机发起的DoS攻击称为DDoS攻击（Distributed Denial of Service attack）。DDoS攻击通常利用那些感染病毒的计算机作为攻击者的攻击跳板。

#### 后门程序

后门程序是指开发设置的隐藏入口，可不按正常步骤使用受限功能。利用后门程序就能使用原本受限制的功能。

通常的后门程序分为以下3中类型。

- 开发阶段作为Debug调用的后门程序
- 开发者为了自身利益植入的后门程序
- 攻击者通过某种方法设置的后门程序

可通过监视进程和通信的状态发现被植入的后门程序。但设定在Web应用中的后门程序，由于和正常使用时区别不大，通常很难发现。



